{"linkia.dam.whatacookrecipes.model":{"name":"linkia.dam.whatacookrecipes.model","classes":[{"name":"CategoryDto","methods":[]},{"name":"IngredientDto","methods":[]},{"name":"RecipeDto","methods":[]},{"name":"MeasureDto","methods":[]},{"name":"NamedEntity","methods":[]}]},"linkia.dam.whatacookrecipes.utilities":{"name":"linkia.dam.whatacookrecipes.utilities","classes":[{"name":"ServiceUtil","methods":[{"name":"getSortByName","returnType":"Sort","parameters":"[String mode]","javadoc":"","body":"{\\n    Sort.Direction direction = isNotNullAndStartWithD(mode) ? Sort.Direction.DESC : Sort.Direction.ASC;\\n    return Sort.by(direction, \\\"name\\\");\\n}"},{"name":"isNotNullAndStartWithD","returnType":"boolean","parameters":"[String mode]","javadoc":"","body":"{\\n    return mode != null && mode.toLowerCase().startsWith(\\\"d\\\");\\n}"}]},{"name":"PaginationUtil","methods":[{"name":"createPagedResult","returnType":"Mono<Page<T>>","parameters":"[List<T> items, int page, int size, String mode]","javadoc":"","body":"{\\n    return Mono.just(items.stream().sorted(getComparator(mode)).skip((long) page * size).limit(size).collect(Collectors.collectingAndThen(Collectors.toList(), list -> new PageImpl<>(list, PageRequest.of(page, size, getSortByName(mode)), items.size()))));\\n}"},{"name":"getComparator","returnType":"Comparator<T>","parameters":"[String mode]","javadoc":"","body":"{\\n    Comparator<T> comparator = Comparator.comparing(NamedEntity::getName);\\n    return isNotNullAndStartWithD(mode) ? comparator.reversed() : comparator;\\n}"}]}]},"linkia.dam.whatacookrecipes":{"name":"linkia.dam.whatacookrecipes","classes":[{"name":"WhataCookRecipesApplication","methods":[{"name":"main","returnType":"void","parameters":"[String[] args]","javadoc":"","body":"{\\n    SpringApplication.run(WhataCookRecipesApplication.class, args);\\n}"}]}]},"linkia.dam.whatacookrecipes.model.exception":{"name":"linkia.dam.whatacookrecipes.model.exception","classes":[{"name":"ResourceNotFoundException","methods":[]}]},"linkia.dam.whatacookrecipes.controller":{"name":"linkia.dam.whatacookrecipes.controller","classes":[{"name":"JavaDocController","methods":[{"name":"getJavadoc","returnType":"ResponseEntity<byte[]>","parameters":"[]","javadoc":"","body":"{\\n    try {\\n        Resource resource = new FileSystemResource(\\\"/app/javadoc/index.html\\\");\\n        if (!resource.exists()) {\\n            log.error(\\\"Javadoc file not found at /app/javadoc/index.html\\\");\\n            return new ResponseEntity<>(HttpStatus.NOT_FOUND);\\n        }\\n        byte[] content = Files.readAllBytes(resource.getFile().toPath());\\n        HttpHeaders headers = new HttpHeaders();\\n        headers.add(\\\"Content-Type\\\", \\\"text/html\\\");\\n        return new ResponseEntity<>(content, headers, HttpStatus.OK);\\n    } catch (IOException e) {\\n        log.error(\\\"Error reading Javadoc file: \\\", e);\\n        return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);\\n    }\\n}"}]},{"name":"MeasureController","methods":[{"name":"getMeasureById","returnType":"Mono<MeasureDto>","parameters":"[@PathVariable String id]","javadoc":"","body":"{\\n    return measureService.getMeasureById(id);\\n}"},{"name":"getMeasureByName","returnType":"Mono<MeasureDto>","parameters":"[@PathVariable String name]","javadoc":"","body":"{\\n    return measureService.getMeasureByNameIgnoreCase(name);\\n}"},{"name":"createMeasure","returnType":"Mono<MeasureDto>","parameters":"[@RequestBody MeasureDto categoryDto]","javadoc":"","body":"{\\n    return measureService.createMeasure(categoryDto);\\n}"},{"name":"createMeasures","returnType":"Flux<MeasureDto>","parameters":"[@RequestBody Flux<MeasureDto> categories]","javadoc":"","body":"{\\n    return measureService.createMeasures(categories);\\n}"},{"name":"deleteMeasureById","returnType":"Mono<String>","parameters":"[@PathVariable String id]","javadoc":"","body":"{\\n    return measureService.deleteMeasure(id);\\n}"},{"name":"deleteAllMeasures","returnType":"Mono<Void>","parameters":"[]","javadoc":"","body":"{\\n    return measureService.deleteAllMeasures();\\n}"}]},{"name":"CategoryController","methods":[{"name":"getAllCategories","returnType":"Mono<Page<CategoryDto>>","parameters":"[@RequestParam(required = false) String mode, @RequestParam int page, @RequestParam int size]","javadoc":"","body":"{\\n    return categoryService.getAllCategories(page, size, mode);\\n}"},{"name":"getCategoriesByNameContaining","returnType":"Mono<Page<CategoryDto>>","parameters":"[@RequestParam String name, @RequestParam(required = false) String mode, @RequestParam int page, @RequestParam int size]","javadoc":"","body":"{\\n    return categoryService.getCategoriesByNameContaining(name, page, size, mode);\\n}"},{"name":"getCategoryById","returnType":"Mono<CategoryDto>","parameters":"[@PathVariable String id]","javadoc":"","body":"{\\n    return categoryService.getCategoryById(id);\\n}"},{"name":"getCategoryByName","returnType":"Mono<CategoryDto>","parameters":"[@PathVariable String name]","javadoc":"","body":"{\\n    return categoryService.getCategoryByNameIgnoreCase(name);\\n}"},{"name":"createCategory","returnType":"Mono<CategoryDto>","parameters":"[@RequestBody CategoryDto categoryDto]","javadoc":"","body":"{\\n    return categoryService.createCategory(categoryDto);\\n}"},{"name":"createCategories","returnType":"Flux<CategoryDto>","parameters":"[@RequestBody Flux<CategoryDto> categories]","javadoc":"","body":"{\\n    return categoryService.createCategories(categories);\\n}"},{"name":"deleteCategoryById","returnType":"Mono<String>","parameters":"[@PathVariable String id]","javadoc":"","body":"{\\n    return categoryService.deleteCategory(id);\\n}"},{"name":"deleteAllCategories","returnType":"Mono<Void>","parameters":"[]","javadoc":"","body":"{\\n    return categoryService.deleteAllCategories();\\n}"}]},{"name":"RecipeController","methods":[{"name":"getAllRecipes","returnType":"Mono<Page<RecipeDto>>","parameters":"[@RequestParam(required = false) String mode, @RequestParam int page, @RequestParam int size]","javadoc":"","body":"{\\n    return recipeService.getAllRecipes(page, size, mode);\\n}"},{"name":"getRecipesByNameContaining","returnType":"Mono<Page<RecipeDto>>","parameters":"[@RequestParam String name, @RequestParam(required = false) String mode, @RequestParam int page, @RequestParam int size]","javadoc":"","body":"{\\n    return recipeService.getRecipesByNameContaining(name, page, size, mode);\\n}"},{"name":"searchRecipesByIngredients","returnType":"Mono<Page<RecipeDto>>","parameters":"[@RequestParam List<String> ingredients, @RequestParam(required = false) String mode, @RequestParam int page, @RequestParam int size]","javadoc":"","body":"{\\n    return recipeService.findRecipesByIngredients(ingredients, page, size, mode);\\n}"},{"name":"searchRecipesByAllIngredients","returnType":"Mono<Page<RecipeDto>>","parameters":"[@RequestParam List<String> ingredients, @RequestParam(required = false) String mode, @RequestParam int page, @RequestParam int size]","javadoc":"","body":"{\\n    return recipeService.findRecipesByAllIngredients(ingredients, page, size, mode);\\n}"},{"name":"getRecipeById","returnType":"Mono<RecipeDto>","parameters":"[@PathVariable String id]","javadoc":"","body":"{\\n    return recipeService.getRecipeById(id);\\n}"},{"name":"getRecipesByIds","returnType":"Mono<Map<String,Object>>","parameters":"[@RequestBody List<String> ids]","javadoc":"","body":"{\\n    return recipeService.getRecipesByIds(ids);\\n}"},{"name":"getRecipeByName","returnType":"Mono<RecipeDto>","parameters":"[@PathVariable String name]","javadoc":"","body":"{\\n    return recipeService.getRecipeByName(name);\\n}"},{"name":"createRecipe","returnType":"Mono<RecipeDto>","parameters":"[@RequestBody RecipeDto recipeDto]","javadoc":"","body":"{\\n    return recipeService.createRecipe(recipeDto);\\n}"},{"name":"createRecipes","returnType":"Flux<RecipeDto>","parameters":"[@RequestBody Flux<RecipeDto> recipes]","javadoc":"","body":"{\\n    return recipeService.createRecipes(recipes);\\n}"},{"name":"deleteRecipeById","returnType":"Mono<String>","parameters":"[@PathVariable String id]","javadoc":"","body":"{\\n    return recipeService.deleteRecipe(id);\\n}"},{"name":"deleteAllRecipes","returnType":"Mono<Void>","parameters":"[]","javadoc":"","body":"{\\n    return recipeService.deleteAllRecipes();\\n}"}]},{"name":"IngredientController","methods":[{"name":"getAllCategories","returnType":"Mono<Page<IngredientDto>>","parameters":"[@RequestParam(required = false) String mode, @RequestParam int page, @RequestParam int size]","javadoc":"","body":"{\\n    return ingredientService.getAllCategories(page, size, mode);\\n}"},{"name":"getCategoriesByNameContaining","returnType":"Mono<Page<IngredientDto>>","parameters":"[@RequestParam String name, @RequestParam(required = false) String mode, @RequestParam int page, @RequestParam int size]","javadoc":"","body":"{\\n    return ingredientService.getCategoriesByNameContaining(name, page, size, mode);\\n}"},{"name":"getIngredientById","returnType":"Mono<IngredientDto>","parameters":"[@PathVariable String id]","javadoc":"","body":"{\\n    return ingredientService.getIngredientById(id);\\n}"},{"name":"getIngredientsByIds","returnType":"Mono<Map<String,Object>>","parameters":"[@RequestBody List<String> ids]","javadoc":"","body":"{\\n    return ingredientService.getIngredientsByIds(ids);\\n}"},{"name":"getIngredientByName","returnType":"Mono<IngredientDto>","parameters":"[@PathVariable String name]","javadoc":"","body":"{\\n    return ingredientService.getIngredientByName(name);\\n}"},{"name":"createIngredient","returnType":"Mono<IngredientDto>","parameters":"[@RequestBody IngredientDto ingredientDto]","javadoc":"","body":"{\\n    return ingredientService.createIngredient(ingredientDto);\\n}"},{"name":"createCategories","returnType":"Flux<IngredientDto>","parameters":"[@RequestBody Flux<IngredientDto> ingredients]","javadoc":"","body":"{\\n    return ingredientService.createCategories(ingredients);\\n}"},{"name":"deleteIngredientById","returnType":"Mono<String>","parameters":"[@PathVariable String id]","javadoc":"","body":"{\\n    return ingredientService.deleteIngredient(id);\\n}"},{"name":"deleteAllCategories","returnType":"Mono<Void>","parameters":"[]","javadoc":"","body":"{\\n    return ingredientService.deleteAllCategories();\\n}"}]}]},"linkia.dam.whatacookrecipes.service.components":{"name":"linkia.dam.whatacookrecipes.service.components","classes":[{"name":"CreateRecipesComponent","methods":[{"name":"createRecipes","returnType":"Flux<RecipeDto>","parameters":"[Flux<RecipeDto> recipes]","javadoc":"","body":"{\\n    return recipes.concatMap(recipe -> Mono.just(recipe).flatMap(this::createRecipe).onErrorResume(e -> {\\n        log.error(\\\"Error occurred while processing recipe '{}': {}\\\", recipe.getName(), e.getMessage(), e);\\n        return Mono.empty();\\n    })).onErrorResume(e -> {\\n        log.error(\\\"Error occurred: {}\\\", e.getMessage(), e);\\n        return Flux.empty();\\n    });\\n}"},{"name":"createRecipe","returnType":"Mono<RecipeDto>","parameters":"[RecipeDto recipeDto]","javadoc":"","body":"{\\n    return recipeDao.findByNameIgnoreCase(recipeDto.getName()).switchIfEmpty(createIngredientsAndCategories(recipeDto).flatMap(saved -> recipeDao.save(recipeDto)).retryWhen(Retry.backoff(3, Duration.ofSeconds(1)).filter(this::isDuplicateKeyException).doBeforeRetry(retrySignal -> getWarned(recipeDto.getName(), retrySignal)))).flatMap(Mono::just).onErrorResume(MongoWriteException.class, e -> {\\n        log.error(\\\"Duplicate key error for recipe '{}': {}\\\", recipeDto.getName(), e.getMessage(), e);\\n        return recipeDao.findByNameIgnoreCase(recipeDto.getName());\\n    });\\n}"},{"name":"createIngredientsAndCategories","returnType":"Mono<RecipeDto>","parameters":"[RecipeDto recipeDto]","javadoc":"","body":"{\\n    return Flux.fromIterable(recipeDto.getIngredients()).concatMap(this::createOrFindIngredient).collectList().flatMap(savedIngredients -> {\\n        recipeDto.setIngredients(savedIngredients);\\n        return Flux.fromIterable(recipeDto.getCategories()).concatMap(this::createOrFindCategory).collectList();\\n    }).flatMap(savedCategories -> {\\n        recipeDto.setCategories(savedCategories);\\n        return Mono.just(recipeDto);\\n    });\\n}"},{"name":"createOrFindIngredient","returnType":"Mono<IngredientDto>","parameters":"[IngredientDto ingredientDto]","javadoc":"","body":"{\\n    return ingredientDao.findByNameIgnoreCase(ingredientDto.getName()).switchIfEmpty(createOrFindMeasure(ingredientDto.getMeasure()).flatMap(measureSaved -> {\\n        ingredientDto.setMeasure(measureSaved);\\n        return ingredientDao.save(ingredientDto).retryWhen(Retry.backoff(3, Duration.ofSeconds(1)).filter(this::isDuplicateKeyException).doBeforeRetry(retrySignal -> getWarned(ingredientDto.getName(), retrySignal)));\\n    })).flatMap(Mono::just).onErrorResume(MongoWriteException.class, e -> {\\n        log.error(\\\"Duplicate key error for ingredient '{}': {}\\\", ingredientDto.getName(), e.getMessage(), e);\\n        return ingredientDao.findByNameIgnoreCase(ingredientDto.getName());\\n    });\\n}"},{"name":"createOrFindMeasure","returnType":"Mono<MeasureDto>","parameters":"[MeasureDto measureDto]","javadoc":"","body":"{\\n    return measureDao.findByNameIgnoreCase(measureDto.getName()).switchIfEmpty(measureDao.save(measureDto).retryWhen(Retry.backoff(3, Duration.ofSeconds(1)).filter(this::isDuplicateKeyException).doBeforeRetry(retrySignal -> getWarned(measureDto.getName(), retrySignal)))).flatMap(Mono::just).onErrorResume(MongoWriteException.class, e -> {\\n        log.error(\\\"Duplicate key error for measure '{}': {}\\\", measureDto.getName(), e.getMessage(), e);\\n        return measureDao.findByNameIgnoreCase(measureDto.getName());\\n    });\\n}"},{"name":"createOrFindCategory","returnType":"Mono<CategoryDto>","parameters":"[CategoryDto categoryDto]","javadoc":"","body":"{\\n    return categoryDao.findByNameIgnoreCase(categoryDto.getName()).switchIfEmpty(categoryDao.save(categoryDto).retryWhen(Retry.backoff(3, Duration.ofSeconds(1)).filter(this::isDuplicateKeyException).doBeforeRetry(retrySignal -> getWarned(categoryDto.getName(), retrySignal)))).flatMap(Mono::just).onErrorResume(MongoWriteException.class, e -> {\\n        log.error(\\\"Duplicate key error for category '{}': {}\\\", categoryDto.getName(), e.getMessage(), e);\\n        return categoryDao.findByNameIgnoreCase(categoryDto.getName());\\n    });\\n}"},{"name":"isDuplicateKeyException","returnType":"boolean","parameters":"[Throwable throwable]","javadoc":"","body":"{\\n    return throwable instanceof MongoWriteException && ((MongoWriteException) throwable).getCode() == 11000;\\n}"},{"name":"getWarned","returnType":"void","parameters":"[String recipeDto, Retry.RetrySignal retrySignal]","javadoc":"","body":"{\\n    log.warn(RETRYING_DUE_TO_DUPLICATE_KEY_ERROR, recipeDto, retrySignal.failure().getMessage());\\n}"}]},{"name":"CreateIngredientsComponent","methods":[{"name":"createIngredients","returnType":"Flux<IngredientDto>","parameters":"[Flux<IngredientDto> ingredients]","javadoc":"","body":"{\\n    return ingredients.concatMap(ingredient -> Mono.just(ingredient).flatMap(this::createIngredient).onErrorResume(e -> {\\n        log.error(\\\"Error occurred while processing ingredient '{}': {}\\\", ingredient.getName(), e.getMessage(), e);\\n        return Mono.empty();\\n    })).onErrorResume(e -> {\\n        log.error(\\\"Error occurred: {}\\\", e.getMessage(), e);\\n        return Flux.empty();\\n    });\\n}"},{"name":"createIngredient","returnType":"Mono<IngredientDto>","parameters":"[IngredientDto ingredientDto]","javadoc":"","body":"{\\n    return measureDao.findByNameIgnoreCase(ingredientDto.getMeasure().getName()).switchIfEmpty(Mono.defer(() -> measureDao.save(ingredientDto.getMeasure()))).flatMap(measureSaved -> {\\n        ingredientDto.setMeasure(measureSaved);\\n        return ingredientDao.findByNameIgnoreCase(ingredientDto.getName()).switchIfEmpty(Mono.defer(() -> ingredientDao.save(ingredientDto)).retryWhen(Retry.backoff(3, Duration.ofSeconds(1)).filter(this::isDuplicateKeyException).doBeforeRetry(retrySignal -> getWarned(ingredientDto.getName(), retrySignal))));\\n    }).flatMap(Mono::just).onErrorResume(MongoWriteException.class, e -> {\\n        log.error(\\\"Duplicate key error for ingredient '{}': {}\\\", ingredientDto.getName(), e.getMessage(), e);\\n        return ingredientDao.findByNameIgnoreCase(ingredientDto.getName());\\n    });\\n}"},{"name":"isDuplicateKeyException","returnType":"boolean","parameters":"[Throwable throwable]","javadoc":"","body":"{\\n    return throwable instanceof MongoWriteException && ((MongoWriteException) throwable).getCode() == 11000;\\n}"},{"name":"getWarned","returnType":"void","parameters":"[String ingredientName, Retry.RetrySignal retrySignal]","javadoc":"","body":"{\\n    log.warn(RETRYING_DUE_TO_DUPLICATE_KEY_ERROR, ingredientName, retrySignal.failure().getMessage());\\n}"}]}]},"linkia.dam.whatacookrecipes.service":{"name":"linkia.dam.whatacookrecipes.service","classes":[{"name":"RecipeService","methods":[{"name":"getAllRecipes","returnType":"Mono<Page<RecipeDto>>","parameters":"[int page, int size, String mode]","javadoc":"","body":"{\\n    return recipeDao.findAll().collectList().flatMap(list -> PaginationUtil.createPagedResult(list, page, size, mode));\\n}"},{"name":"getRecipesByNameContaining","returnType":"Mono<Page<RecipeDto>>","parameters":"[String name, int page, int size, String mode]","javadoc":"","body":"{\\n    return recipeDao.findByNameContainingIgnoreCase(name).collectList().flatMap(list -> PaginationUtil.createPagedResult(list, page, size, mode));\\n}"},{"name":"findRecipesByIngredients","returnType":"Mono<Page<RecipeDto>>","parameters":"[List<String> ingredientNames, int page, int size, String mode]","javadoc":"","body":"{\\n    return recipeDao.findByIngredientsNameIn(ingredientNames).collectList().flatMap(list -> PaginationUtil.createPagedResult(list, page, size, mode));\\n}"},{"name":"findRecipesByAllIngredients","returnType":"Mono<Page<RecipeDto>>","parameters":"[List<String> ingredientNames, int page, int size, String mode]","javadoc":"","body":"{\\n    return recipeDao.findByAllIngredientsNameIn(ingredientNames).collectList().flatMap(list -> PaginationUtil.createPagedResult(list, page, size, mode));\\n}"},{"name":"getRecipeById","returnType":"Mono<RecipeDto>","parameters":"[String id]","javadoc":"","body":"{\\n    return recipeDao.findById(id).switchIfEmpty(Mono.error(new ResourceNotFoundException(\\\"Recipe not found with id=\\\" + id)));\\n}"},{"name":"getRecipesByIds","returnType":"Mono<Map<String,Object>>","parameters":"[List<String> ids]","javadoc":"","body":"{\\n    return recipeDao.findAllById(ids).collectList().flatMap(recipes -> {\\n        List<String> foundIds = recipes.stream().map(RecipeDto::getId).toList();\\n        List<String> notFoundIds = ids.stream().filter(id -> !foundIds.contains(id)).toList();\\n        Map<String, Object> result = new HashMap<>();\\n        result.put(\\\"found\\\", recipes);\\n        result.put(\\\"notFound\\\", notFoundIds);\\n        return Mono.just(result);\\n    });\\n}"},{"name":"getRecipeByName","returnType":"Mono<RecipeDto>","parameters":"[String name]","javadoc":"","body":"{\\n    return recipeDao.findByNameIgnoreCase(name).switchIfEmpty(Mono.error(new ResourceNotFoundException(\\\"Recipe not found with name=\\\" + name)));\\n}"},{"name":"createRecipes","returnType":"Flux<RecipeDto>","parameters":"[Flux<RecipeDto> recipes]","javadoc":"","body":"{\\n    return createRecipesComponent.createRecipes(recipes);\\n}"},{"name":"createRecipe","returnType":"Mono<RecipeDto>","parameters":"[RecipeDto recipeDto]","javadoc":"","body":"{\\n    return createRecipesComponent.createRecipe(recipeDto);\\n}"},{"name":"deleteRecipe","returnType":"Mono<String>","parameters":"[String id]","javadoc":"","body":"{\\n    return recipeDao.findById(id).flatMap(existingRecipe -> recipeDao.delete(existingRecipe).then(Mono.just(\\\"Recipe \\\" + existingRecipe.getName() + \\\" has been deleted.\\\"))).switchIfEmpty(Mono.error(new ResourceNotFoundException(\\\"Recipe not found with id=\\\" + id)));\\n}"},{"name":"deleteAllRecipes","returnType":"Mono<Void>","parameters":"[]","javadoc":"","body":"{\\n    return recipeDao.deleteAll();\\n}"}]},{"name":"MeasureService","methods":[{"name":"getMeasureById","returnType":"Mono<MeasureDto>","parameters":"[String id]","javadoc":"","body":"{\\n    return measureDao.findById(id).switchIfEmpty(Mono.error(new ResourceNotFoundException(\\\"Measure not found with id=\\\" + id)));\\n}"},{"name":"getMeasureByNameIgnoreCase","returnType":"Mono<MeasureDto>","parameters":"[String name]","javadoc":"","body":"{\\n    return measureDao.findByNameIgnoreCase(name).switchIfEmpty(Mono.error(new ResourceNotFoundException(\\\"Measure not found with name=\\\" + name)));\\n}"},{"name":"createMeasure","returnType":"Mono<MeasureDto>","parameters":"[MeasureDto measureDto]","javadoc":"","body":"{\\n    return measureDao.findByNameIgnoreCase(measureDto.getName()).switchIfEmpty(Mono.defer(() -> measureDao.save(measureDto)));\\n}"},{"name":"createMeasures","returnType":"Flux<MeasureDto>","parameters":"[Flux<MeasureDto> measures]","javadoc":"","body":"{\\n    return measures.flatMap(this::createMeasure);\\n}"},{"name":"deleteMeasure","returnType":"Mono<String>","parameters":"[String id]","javadoc":"","body":"{\\n    return measureDao.findById(id).flatMap(existingMeasure -> measureDao.delete(existingMeasure).then(Mono.just(\\\"Measure \\\" + existingMeasure.getName() + \\\" has been deleted.\\\"))).switchIfEmpty(Mono.error(new ResourceNotFoundException(\\\"Measure not found with id=\\\" + id)));\\n}"},{"name":"deleteAllMeasures","returnType":"Mono<Void>","parameters":"[]","javadoc":"","body":"{\\n    return measureDao.deleteAll();\\n}"}]},{"name":"IngredientService","methods":[{"name":"getAllCategories","returnType":"Mono<Page<IngredientDto>>","parameters":"[int page, int size, String mode]","javadoc":"","body":"{\\n    return ingredientDao.findAll().collectList().flatMap(list -> PaginationUtil.createPagedResult(list, page, size, mode));\\n}"},{"name":"getCategoriesByNameContaining","returnType":"Mono<Page<IngredientDto>>","parameters":"[String name, int page, int size, String mode]","javadoc":"","body":"{\\n    return ingredientDao.findByNameContainingIgnoreCase(name).collectList().flatMap(list -> PaginationUtil.createPagedResult(list, page, size, mode));\\n}"},{"name":"getIngredientById","returnType":"Mono<IngredientDto>","parameters":"[String id]","javadoc":"","body":"{\\n    return ingredientDao.findById(id).switchIfEmpty(Mono.error(new ResourceNotFoundException(\\\"Ingredient not found with id=\\\" + id)));\\n}"},{"name":"getIngredientsByIds","returnType":"Mono<Map<String,Object>>","parameters":"[List<String> ids]","javadoc":"","body":"{\\n    return ingredientDao.findAllById(ids).collectList().flatMap(ingredients -> {\\n        List<String> foundIds = ingredients.stream().map(IngredientDto::getId).toList();\\n        List<String> notFoundIds = ids.stream().filter(id -> !foundIds.contains(id)).toList();\\n        Map<String, Object> result = new HashMap<>();\\n        result.put(\\\"found\\\", ingredients);\\n        result.put(\\\"notFound\\\", notFoundIds);\\n        return Mono.just(result);\\n    });\\n}"},{"name":"getIngredientByName","returnType":"Mono<IngredientDto>","parameters":"[String name]","javadoc":"","body":"{\\n    return ingredientDao.findByNameIgnoreCase(name).switchIfEmpty(Mono.error(new ResourceNotFoundException(\\\"Ingredient not found with name=\\\" + name)));\\n}"},{"name":"createIngredient","returnType":"Mono<IngredientDto>","parameters":"[IngredientDto ingredientDto]","javadoc":"","body":"{\\n    return createIngredientsComponent.createIngredient(ingredientDto);\\n}"},{"name":"createCategories","returnType":"Flux<IngredientDto>","parameters":"[Flux<IngredientDto> ingredients]","javadoc":"","body":"{\\n    return createIngredientsComponent.createIngredients(ingredients);\\n}"},{"name":"deleteIngredient","returnType":"Mono<String>","parameters":"[String id]","javadoc":"","body":"{\\n    return ingredientDao.findById(id).flatMap(existingIngredient -> ingredientDao.delete(existingIngredient).then(Mono.just(\\\"Ingredient \\\" + existingIngredient.getName() + \\\" has been deleted.\\\"))).switchIfEmpty(Mono.error(new ResourceNotFoundException(\\\"Ingredient not found with id=\\\" + id)));\\n}"},{"name":"deleteAllCategories","returnType":"Mono<Void>","parameters":"[]","javadoc":"","body":"{\\n    return ingredientDao.deleteAll();\\n}"}]},{"name":"CategoryService","methods":[{"name":"getAllCategories","returnType":"Mono<Page<CategoryDto>>","parameters":"[int page, int size, String mode]","javadoc":"","body":"{\\n    return categoryDao.findAll().collectList().flatMap(list -> PaginationUtil.createPagedResult(list, page, size, mode));\\n}"},{"name":"getCategoriesByNameContaining","returnType":"Mono<Page<CategoryDto>>","parameters":"[String name, int page, int size, String mode]","javadoc":"","body":"{\\n    return categoryDao.findByNameContainingIgnoreCase(name).collectList().flatMap(list -> PaginationUtil.createPagedResult(list, page, size, mode));\\n}"},{"name":"getCategoryById","returnType":"Mono<CategoryDto>","parameters":"[String id]","javadoc":"","body":"{\\n    return categoryDao.findById(id).switchIfEmpty(Mono.error(new ResourceNotFoundException(\\\"Category not found with id=\\\" + id)));\\n}"},{"name":"getCategoryByNameIgnoreCase","returnType":"Mono<CategoryDto>","parameters":"[String name]","javadoc":"","body":"{\\n    return categoryDao.findByNameIgnoreCase(name).switchIfEmpty(Mono.error(new ResourceNotFoundException(\\\"Category not found with name=\\\" + name)));\\n}"},{"name":"createCategory","returnType":"Mono<CategoryDto>","parameters":"[CategoryDto categoryDto]","javadoc":"","body":"{\\n    return categoryDao.findByNameIgnoreCase(categoryDto.getName()).switchIfEmpty(Mono.defer(() -> categoryDao.save(categoryDto)));\\n}"},{"name":"createCategories","returnType":"Flux<CategoryDto>","parameters":"[Flux<CategoryDto> categories]","javadoc":"","body":"{\\n    return categories.flatMap(this::createCategory);\\n}"},{"name":"deleteCategory","returnType":"Mono<String>","parameters":"[String id]","javadoc":"","body":"{\\n    return categoryDao.findById(id).flatMap(existingCategory -> categoryDao.delete(existingCategory).then(Mono.just(\\\"Category \\\" + existingCategory.getName() + \\\" has been deleted.\\\"))).switchIfEmpty(Mono.error(new ResourceNotFoundException(\\\"Category not found with id=\\\" + id)));\\n}"},{"name":"deleteAllCategories","returnType":"Mono<Void>","parameters":"[]","javadoc":"","body":"{\\n    return categoryDao.deleteAll();\\n}"}]}]},"linkia.dam.whatacookrecipes.config":{"name":"linkia.dam.whatacookrecipes.config","classes":[{"name":"JavaParserAnalyzer","methods":[{"name":"analyze","returnType":"void","parameters":"[]","javadoc":"","body":"{\\n    File projectDir = new File(OUTPUT_DIR);\\n    if (!projectDir.exists() || !projectDir.isDirectory()) {\\n        log.error(\\\"El directorio especificado no existe: {}\\\", OUTPUT_DIR);\\n        return;\\n    }\\n    Map<String, PackageInfo> packageMap = new HashMap<>();\\n    try {\\n        Files.createDirectories(Paths.get(OUTPUT_DIR));\\n        final Path pathTo_OUTPUT_FILE = Paths.get(OUTPUT_FILE);\\n        Files.deleteIfExists(pathTo_OUTPUT_FILE);\\n        extractData(projectDir, packageMap);\\n        String jsonString = toJsonString(packageMap);\\n        Files.write(pathTo_OUTPUT_FILE, jsonString.getBytes());\\n    } catch (IOException e) {\\n        log.error(\\\"Error while analyzing Java parser: {}\\\", e.getMessage(), e);\\n    }\\n}"},{"name":"escapeJson","returnType":"String","parameters":"[String input]","javadoc":"","body":"{\\n    if (input == null) {\\n        return \\\"\\\";\\n    }\\n    return input.replace(\\\"\\\\\\\\\\\", \\\"\\\\\\\\\\\\\\\\\\\").replace(\\\"\\\\\\\"\\\", \\\"\\\\\\\\\\\\\\\"\\\").replace(\\\"\\\\n\\\", \\\"\\\\\\\\n\\\").replace(\\\"\\\\r\\\", \\\"\\\\\\\\r\\\").replace(\\\"\\\\t\\\", \\\"\\\\\\\\t\\\");\\n}"},{"name":"toJsonString","returnType":"String","parameters":"[Map<String, PackageInfo> packageMap]","javadoc":"","body":"{\\n    ObjectMapper mapper = new ObjectMapper();\\n    try {\\n        return mapper.writeValueAsString(packageMap);\\n    } catch (IOException e) {\\n        log.error(\\\"Error converting to JSON string: {}\\\", e.getMessage(), e);\\n        return \\\"{}\\\";\\n    }\\n}"},{"name":"extractData","returnType":"void","parameters":"[File projectDir, Map<String, PackageInfo> packageMap]","javadoc":"","body":"{\\n    ParserConfiguration parserConfiguration = new ParserConfiguration().setAttributeComments(false);\\n    JavaParser javaParser = new JavaParser(parserConfiguration);\\n    try (Stream<java.nio.file.Path> paths = Files.walk(projectDir.toPath())) {\\n        paths.filter(Files::isRegularFile).filter(path -> path.toString().endsWith(\\\".java\\\")).forEach(path -> {\\n            try {\\n                CompilationUnit cu = javaParser.parse(path).getResult().orElseThrow(IOException::new);\\n                cu.accept(new PackageVisitor(), packageMap);\\n            } catch (IOException e) {\\n                log.error(\\\"Error while extractData() in JavaParserAnalyzer: {}\\\", e.getMessage(), e);\\n            }\\n        });\\n    }\\n}"}]},{"name":"PackageVisitor","methods":[{"name":"visit","returnType":"void","parameters":"[CompilationUnit cu, Map<String, PackageInfo> collector]","javadoc":"","body":"{\\n    super.visit(cu, collector);\\n    String packageName = cu.getPackageDeclaration().map(pd -> pd.getName().toString()).orElse(\\\"default\\\");\\n    PackageInfo packageInfo = collector.computeIfAbsent(packageName, PackageInfo::new);\\n    cu.findAll(ClassOrInterfaceDeclaration.class).forEach(c -> {\\n        ClassInfo classInfo = new ClassInfo();\\n        classInfo.setName(c.getNameAsString());\\n        c.getMethods().forEach(m -> {\\n            MethodInfo methodInfo = new MethodInfo();\\n            methodInfo.setName(m.getNameAsString());\\n            methodInfo.setReturnType(m.getTypeAsString());\\n            methodInfo.setParameters(m.getParameters().toString());\\n            methodInfo.setJavadoc(m.getJavadoc().map(javadoc -> escapeJson(javadoc.toString())).orElse(\\\"\\\"));\\n            methodInfo.setBody(m.getBody().map(body -> escapeJson(body.toString())).orElse(\\\"\\\"));\\n            classInfo.getMethods().add(methodInfo);\\n        });\\n        packageInfo.getClasses().add(classInfo);\\n    });\\n}"}]},{"name":"PackageInfo","methods":[]},{"name":"ClassInfo","methods":[]},{"name":"MethodInfo","methods":[]},{"name":"JavaSourceAggregator","methods":[{"name":"aggregateSourceCode","returnType":"void","parameters":"[]","javadoc":"","body":"{\\n    File sourceDir = new File(SOURCE_DIR);\\n    if (!sourceDir.exists() || !sourceDir.isDirectory()) {\\n        log.error(\\\"El directorio especificado no existe: {}\\\", SOURCE_DIR);\\n        return;\\n    }\\n    try {\\n        final Path pathToOutputFile = Paths.get(OUTPUT_FILE);\\n        Files.deleteIfExists(pathToOutputFile);\\n        try (BufferedWriter writer = Files.newBufferedWriter(pathToOutputFile, StandardOpenOption.CREATE)) {\\n            aggregateSourceFiles(sourceDir, writer);\\n        }\\n    } catch (IOException e) {\\n        log.error(\\\"Error while aggregating source code: {}\\\", e.getMessage(), e);\\n    }\\n}"},{"name":"aggregateSourceFiles","returnType":"void","parameters":"[File directory, BufferedWriter writer]","javadoc":"","body":"{\\n    try (Stream<Path> paths = Files.walk(directory.toPath())) {\\n        paths.filter(Files::isRegularFile).filter(path -> path.toString().endsWith(\\\".java\\\")).forEach(path -> {\\n            try (Stream<String> lines = Files.lines(path)) {\\n                lines.forEach(line -> {\\n                    try {\\n                        writer.write(line);\\n                        writer.newLine();\\n                    } catch (IOException e) {\\n                        log.error(\\\"Error writing line to output file: {}\\\", e.getMessage(), e);\\n                    }\\n                });\\n                writer.write(System.lineSeparator());\\n            } catch (IOException e) {\\n                log.error(\\\"Error reading file {}: {}\\\", path, e.getMessage(), e);\\n            }\\n        });\\n    }\\n}"}]},{"name":"LocalEnvironmentCondition","methods":[{"name":"matches","returnType":"boolean","parameters":"[ConditionContext context, AnnotatedTypeMetadata metadata]","javadoc":"","body":"{\\n    String environment = System.getenv(\\\"WHATA_COOK_ENV\\\");\\n    return \\\"local\\\".equals(environment);\\n}"}]},{"name":"MongoConfig","methods":[{"name":"mongoClient","returnType":"MongoClient","parameters":"[]","javadoc":"","body":"{\\n    return MongoClients.create(mongoUri);\\n}"},{"name":"reactiveMongoDatabaseFactory","returnType":"ReactiveMongoDatabaseFactory","parameters":"[MongoClient mongoClient]","javadoc":"","body":"{\\n    return new SimpleReactiveMongoDatabaseFactory(mongoClient, DB_NAME);\\n}"},{"name":"reactiveMongoTemplate","returnType":"ReactiveMongoTemplate","parameters":"[ReactiveMongoDatabaseFactory reactiveMongoDatabaseFactory, MappingMongoConverter mappingMongoConverter]","javadoc":"","body":"{\\n    return new ReactiveMongoTemplate(reactiveMongoDatabaseFactory, mappingMongoConverter);\\n}"},{"name":"mappingMongoConverter","returnType":"MappingMongoConverter","parameters":"[MongoMappingContext mongoMappingContext]","javadoc":"","body":"{\\n    MappingMongoConverter converter = new MappingMongoConverter(NoOpDbRefResolver.INSTANCE, mongoMappingContext);\\n    converter.setTypeMapper(new DefaultMongoTypeMapper(null));\\n    return converter;\\n}"}]},{"name":"WebConfig","methods":[{"name":"addResourceHandlers","returnType":"void","parameters":"[ResourceHandlerRegistry registry]","javadoc":"","body":"{\\n    registry.addResourceHandler(\\\"/api/javadoc/**\\\").addResourceLocations(\\\"file:/app/javadoc/\\\");\\n}"}]}]},"linkia.dam.whatacookrecipes.service.repository":{"name":"linkia.dam.whatacookrecipes.service.repository","classes":[{"name":"MeasureDao","methods":[{"name":"findByNameIgnoreCase","returnType":"Mono<MeasureDto>","parameters":"[String name]","javadoc":"","body":""}]},{"name":"RecipeDao","methods":[{"name":"findByNameContainingIgnoreCase","returnType":"Flux<RecipeDto>","parameters":"[String name]","javadoc":"","body":""},{"name":"findByNameIgnoreCase","returnType":"Mono<RecipeDto>","parameters":"[String name]","javadoc":"","body":""},{"name":"findByIngredientsNameIn","returnType":"Flux<RecipeDto>","parameters":"[List<String> ingredientNames]","javadoc":"","body":""},{"name":"findByAllIngredientsNameIn","returnType":"Flux<RecipeDto>","parameters":"[List<String> ingredientNames]","javadoc":"","body":""}]},{"name":"IngredientDao","methods":[{"name":"findByNameContainingIgnoreCase","returnType":"Flux<IngredientDto>","parameters":"[String name]","javadoc":"","body":""},{"name":"findByNameIgnoreCase","returnType":"Mono<IngredientDto>","parameters":"[String name]","javadoc":"","body":""}]},{"name":"CategoryDao","methods":[{"name":"findByNameContainingIgnoreCase","returnType":"Flux<CategoryDto>","parameters":"[String name]","javadoc":"","body":""},{"name":"findByNameIgnoreCase","returnType":"Mono<CategoryDto>","parameters":"[String name]","javadoc":"","body":""}]}]}}