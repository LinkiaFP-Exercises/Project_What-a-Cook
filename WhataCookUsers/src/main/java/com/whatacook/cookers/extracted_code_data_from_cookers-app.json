[
  {
    "javadoc": "",
    "name": "getSecretKey",
    "body": "{\n    return Keys.hmacShaKeyFor(this.secret.getBytes());\n}",
    "parameters": "[]",
    "returnType": "SecretKey"
  },
  {
    "javadoc": "",
    "name": "getUsernameFromToken",
    "body": "{\n    return getClaimFromToken(token, Claims::getSubject);\n}",
    "parameters": "[String token]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "getExpirationDateFromToken",
    "body": "{\n    return getClaimFromToken(token, Claims::getExpiration);\n}",
    "parameters": "[String token]",
    "returnType": "Date"
  },
  {
    "javadoc": "",
    "name": "getClaimFromToken",
    "body": "{\n    final Claims claims = getAllClaimsFromToken(token);\n    return claimsResolver.apply(claims);\n}",
    "parameters": "[String token, Function<Claims, T> claimsResolver]",
    "returnType": "T"
  },
  {
    "javadoc": "",
    "name": "getAllClaimsFromToken",
    "body": "{\n    return Jwts.parser().verifyWith(getSecretKey()).build().parseSignedClaims(token.replace(prefix, \"\")).getPayload();\n}",
    "parameters": "[String token]",
    "returnType": "Claims"
  },
  {
    "javadoc": "",
    "name": "isExpired",
    "body": "{\n    final Date expiration = getExpirationDateFromToken(token);\n    return expiration.before(new Date());\n}",
    "parameters": "[String token]",
    "returnType": "Boolean"
  },
  {
    "javadoc": "",
    "name": "generateToken",
    "body": "{\n    Map<String, Object> claims = new HashMap<>();\n    return doGenerateToken(claims, authRequestDto.getUsername());\n}",
    "parameters": "[AuthRequestDto authRequestDto]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "doGenerateToken",
    "body": "{\n    return Jwts.builder().claims(claims).subject(subject).audience().add(audience).and().issuer(issuer).issuedAt(new Date(System.currentTimeMillis())).expiration(new Date(System.currentTimeMillis() + expiration)).signWith(getSecretKey()).compact();\n}",
    "parameters": "[Map<String, Object> claims, String subject]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "generateExpiredTokenForTest",
    "body": "{\n    long nowMillis = System.currentTimeMillis();\n    Date now = new Date(nowMillis - expiration * 2);\n    Date expiredDate = new Date(nowMillis - expiration);\n    return Jwts.builder().claims(claims).subject(subject).audience().add(audience).and().issuer(issuer).issuedAt(now).expiration(expiredDate).signWith(getSecretKey()).compact();\n}",
    "parameters": "[Map<String, Object> claims, String subject]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "hasToken",
    "body": "{\n    return StringUtils.hasText(token);\n}",
    "parameters": "[String token]",
    "returnType": "boolean"
  },
  {
    "javadoc": "",
    "name": "extractPrefix",
    "body": "{\n    return token.substring(7);\n}",
    "parameters": "[String token]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "isValidToken",
    "body": "{\n    if (!token.startsWith(prefix))\n        throw new JwtException(\"This Token is not Bearer\");\n    else if (token.split(\"\\\\.\").length != 3)\n        throw new JwtException(\"This Token is not ours\");\n    else if (isExpired(token))\n        throw new JwtException(\"This Token has Expired\");\n    else\n        return true;\n}",
    "parameters": "[String token]",
    "returnType": "Boolean"
  },
  {
    "javadoc": "",
    "name": "executeIfAuthorized",
    "body": "{\n    return getAuthentication().flatMap(authentication -> isAuthorized(userJson, authentication).flatMap(isAuthorized -> isAuthorized ? action.apply(userJson, (UserDetails) authentication.getPrincipal()) : UserServiceException.mono(\"No tienes permiso para acceder a esta información.\")));\n}",
    "parameters": "[UserJson userJson, BiFunction<UserJson, UserDetails, Mono<Response>> action]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "",
    "name": "getAuthentication",
    "body": "{\n    return ReactiveSecurityContextHolder.getContext().map(SecurityContext::getAuthentication);\n}",
    "parameters": "[]",
    "returnType": "Mono<Authentication>"
  },
  {
    "javadoc": "",
    "name": "isAuthorized",
    "body": "{\n    return Mono.just(isAdmin(authentication) || isOwnUser(userJson, getUserDetails(authentication)));\n}",
    "parameters": "[UserJson userJson, Authentication authentication]",
    "returnType": "Mono<Boolean>"
  },
  {
    "javadoc": "",
    "name": "isAdmin",
    "body": "{\n    return authentication.getAuthorities().stream().anyMatch(grantedAuthority -> grantedAuthority.getAuthority().equals(\"ROLE_ADMIN\"));\n}",
    "parameters": "[Authentication authentication]",
    "returnType": "boolean"
  },
  {
    "javadoc": "",
    "name": "isOwnUser",
    "body": "{\n    String username = userDetails.getUsername();\n    return (userJson.get_id() == null) ? username.contains(userJson.getEmail()) : username.contains(userJson.get_id());\n}",
    "parameters": "[UserJson userJson, UserDetails userDetails]",
    "returnType": "boolean"
  },
  {
    "javadoc": "",
    "name": "getUserDetails",
    "body": "{\n    return (UserDetails) authentication.getPrincipal();\n}",
    "parameters": "[Authentication authentication]",
    "returnType": "UserDetails"
  },
  {
    "javadoc": "",
    "name": "isSelfOrAdmin",
    "body": "{\n    CustomUserDetails userDetails = (CustomUserDetails) authentication.getPrincipal();\n    return (userDetails.getId().equals(userId)) || (userDetails.getEmail().equals(email)) || authentication.getAuthorities().stream().anyMatch(grantedAuthority -> grantedAuthority.getAuthority().equals(\"ROLE_ADMIN\"));\n}",
    "parameters": "[Authentication authentication, String userId, String email]",
    "returnType": "boolean"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Configures the security filter chain.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ServerHttpSecurity instance.'}]}', name=Optional[httpSecurity]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The custom request filter.'}]}', name=Optional[anyRequestFilter]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The reactive authentication manager.'}]}', name=Optional[reactiveAuthenticationManager]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The configured SecurityWebFilterChain.'}]}', name=Optional.empty}]}",
    "name": "filterChain",
    "body": "{\n    return httpSecurity.csrf(ServerHttpSecurity.CsrfSpec::disable).httpBasic(ServerHttpSecurity.HttpBasicSpec::disable).formLogin(ServerHttpSecurity.FormLoginSpec::disable).authenticationManager(reactiveAuthenticationManager).securityContextRepository(NoOpServerSecurityContextRepository.getInstance()).authorizeExchange(authorizeExchangeSpec -> authorizeExchangeSpec.pathMatchers(globalValues.getPathToCheckIfEmailAlreadyExists()).permitAll().pathMatchers(globalValues.getPathToJavaDoc()).permitAll().pathMatchers(globalValues.getPathToDirectoryJavadoc()).permitAll().pathMatchers(jwtUtil.getLoginUrl()).permitAll().pathMatchers(jwtUtil.getSignInUrl()).permitAll().pathMatchers(jwtUtil.getForgotPass()).permitAll().anyExchange().authenticated()).addFilterAt(anyRequestFilter, SecurityWebFiltersOrder.AUTHENTICATION).build();\n}",
    "parameters": "[ServerHttpSecurity httpSecurity, AnyRequestFilter anyRequestFilter, ReactiveAuthenticationManager reactiveAuthenticationManager]",
    "returnType": "SecurityWebFilterChain"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Provides a PasswordEncoder bean for encoding passwords.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The BCryptPasswordEncoder instance.'}]}', name=Optional.empty}]}",
    "name": "passwordEncoder",
    "body": "{\n    return new BCryptPasswordEncoder();\n}",
    "parameters": "[]",
    "returnType": "PasswordEncoder"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Configures the ReactiveAuthenticationManager.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ReactiveUserDetailsService instance.'}]}', name=Optional[userDetailsService]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The PasswordEncoder instance.'}]}', name=Optional[passwordEncoder]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The configured ReactiveAuthenticationManager.'}]}', name=Optional.empty}]}",
    "name": "reactiveAuthenticationManager",
    "body": "{\n    var authenticationManager = new UserDetailsRepositoryReactiveAuthenticationManager(userDetailsService);\n    authenticationManager.setPasswordEncoder(passwordEncoder);\n    return authenticationManager;\n}",
    "parameters": "[ReactiveUserDetailsService userDetailsService, PasswordEncoder passwordEncoder]",
    "returnType": "ReactiveAuthenticationManager"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Configures the resource handlers for the application.\n<p>\nThis method overrides the '}, JavadocInlineTag{tagName='code', type=CODE, content=' addResourceHandlers'}, JavadocSnippet{text=' method from the\n'}, JavadocInlineTag{tagName='code', type=CODE, content=' WebFluxConfigurer'}, JavadocSnippet{text=' interface to add a specific resource handler.\nThe resource handler configures the path to serve static files\nfrom the file system directory '}, JavadocInlineTag{tagName='code', type=CODE, content=' /app/javadoc'}, JavadocSnippet{text=' via the path\n'}, JavadocInlineTag{tagName='code', type=CODE, content=' /api/javadoc/**'}, JavadocSnippet{text='.\n</p>'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the resource handler registry to be used to add the handlers.'}]}', name=Optional[registry]}]}",
    "name": "addResourceHandlers",
    "body": "{\n    registry.addResourceHandler(\"/api/javadoc/**\").addResourceLocations(\"file:/app/javadoc/\");\n}",
    "parameters": "[ResourceHandlerRegistry registry]",
    "returnType": "void"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Initializes the MongoDB URI by reading Docker secrets.\nSets the system property for the MongoDB URI.'}]}, blockTags=[]}",
    "name": "init",
    "body": "{\n    try {\n        String URI = \"MONGO_URI_WHATACOOK_USERS\";\n        String mongoUri = DockerConfig.readSecret(URI);\n        if (StringUtils.hasText(mongoUri))\n            System.setProperty(URI, mongoUri.trim());\n        log.warn(\"Mongo URI : {}\", StringUtils.hasText(mongoUri));\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='PostConstruct method that initiates the analysis process.\nIt creates the output directory and file, then extracts method data from the Java source files.'}]}, blockTags=[]}",
    "name": "analyze",
    "body": "{\n    File projectDir = new File(OUTPUT_DIR);\n    if (!projectDir.exists() || !projectDir.isDirectory()) {\n        log.error(\"El directorio especificado no existe: {}\", OUTPUT_DIR);\n        return;\n    }\n    List<MethodInfo> extractedData = new ArrayList<>();\n    try {\n        // Crear el directorio de salida si no existe\n        Files.createDirectories(Paths.get(OUTPUT_DIR));\n        // Borrar el contenido existente del archivo\n        final Path pathTo_OUTPUT_FILE = Paths.get(OUTPUT_FILE);\n        Files.deleteIfExists(pathTo_OUTPUT_FILE);\n        extractData(projectDir, extractedData);\n        // Guardar los datos extraídos en un archivo JSON\n        List<Map<String, String>> jsonList = extractedData.stream().map(methodInfo -> {\n            Map<String, String> jsonObject = new HashMap<>();\n            jsonObject.put(\"name\", escapeJson(methodInfo.getName()));\n            jsonObject.put(\"returnType\", escapeJson(methodInfo.getReturnType()));\n            jsonObject.put(\"parameters\", escapeJson(methodInfo.getParameters()));\n            jsonObject.put(\"javadoc\", escapeJson(methodInfo.getJavadoc()));\n            jsonObject.put(\"body\", escapeJson(methodInfo.getBody()));\n            return jsonObject;\n        }).collect(Collectors.toList());\n        String jsonString = toJsonString(jsonList);\n        Files.write(pathTo_OUTPUT_FILE, jsonString.getBytes());\n    } catch (IOException e) {\n        log.error(\"Error while analyzing Java parser: {}\", e.getMessage(), e);\n    }\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Escapes special characters in a JSON string.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the input string'}]}', name=Optional[input]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the escaped string'}]}', name=Optional.empty}]}",
    "name": "escapeJson",
    "body": "{\n    if (input == null) {\n        return \"\";\n    }\n    return input.replace(\"\\\\\", \"\\\\\\\\\").replace(\"\\\"\", \"\\\\\\\"\").replace(\"\\n\", \"\\\\n\").replace(\"\\r\", \"\\\\r\").replace(\"\\t\", \"\\\\t\");\n}",
    "parameters": "[String input]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Converts a list of maps to a JSON string.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the list of maps'}]}', name=Optional[jsonList]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the JSON string'}]}', name=Optional.empty}]}",
    "name": "toJsonString",
    "body": "{\n    StringBuilder jsonString = new StringBuilder(\"[\\n\");\n    for (Map<String, String> jsonObject : jsonList) {\n        jsonString.append(\"  {\\n\");\n        for (Map.Entry<String, String> entry : jsonObject.entrySet()) {\n            jsonString.append(\"    \\\"\").append(entry.getKey()).append(\"\\\": \\\"\").append(entry.getValue()).append(\"\\\",\\n\");\n        }\n        // Remove last comma and newline, then add closing brace\n        jsonString.setLength(jsonString.length() - 2);\n        jsonString.append(\"\\n  },\\n\");\n    }\n    // Remove last comma and newline, then add closing bracket\n    if (!jsonList.isEmpty()) {\n        jsonString.setLength(jsonString.length() - 2);\n    }\n    jsonString.append(\"\\n]\");\n    return jsonString.toString();\n}",
    "parameters": "[List<Map<String, String>> jsonList]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Extracts method information from Java source files in the specified directory.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the project directory'}]}', name=Optional[projectDir]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the list to store extracted method information'}]}', name=Optional[extractedData]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if an I/O error occurs'}]}', name=Optional[IOException]}]}",
    "name": "extractData",
    "body": "{\n    JavaParser javaParser = new JavaParser();\n    try (Stream<java.nio.file.Path> paths = Files.walk(projectDir.toPath())) {\n        paths.filter(Files::isRegularFile).filter(path -> path.toString().endsWith(\".java\")).forEach(path -> {\n            try {\n                CompilationUnit cu = javaParser.parse(path).getResult().orElseThrow(IOException::new);\n                cu.accept(new MethodVisitor(), extractedData);\n            } catch (IOException e) {\n                log.error(\"Error while extractData() in JavaParserAnalyzer: {}\", e.getMessage(), e);\n            }\n        });\n    }\n}",
    "parameters": "[File projectDir, List<MethodInfo> extractedData]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "visit",
    "body": "{\n    super.visit(md, collector);\n    MethodInfo methodInfo = new MethodInfo();\n    methodInfo.setName(md.getNameAsString());\n    methodInfo.setReturnType(md.getTypeAsString());\n    methodInfo.setParameters(md.getParameters().toString());\n    methodInfo.setJavadoc(md.getJavadoc().map(Object::toString).orElse(\"\"));\n    methodInfo.setBody(md.getBody().map(Object::toString).orElse(\"\"));\n    collector.add(methodInfo);\n}",
    "parameters": "[MethodDeclaration md, List<MethodInfo> collector]",
    "returnType": "void"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Condition function to check if the environment is local.'}]}, blockTags=[]}",
    "name": "matches",
    "body": "{\n    String environment = System.getenv(\"WHATA_COOK_ENV\");\n    return \"local\".equals(environment);\n}",
    "parameters": "[ConditionContext context, AnnotatedTypeMetadata metadata]",
    "returnType": "boolean"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Reads the secret value from the specified path or environment variable.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The name of the secret.'}]}', name=Optional[secret]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The secret value as a string.'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='If an I/O error occurs.'}]}', name=Optional[IOException]}]}",
    "name": "readSecret",
    "body": "{\n    try {\n        return new String(Files.readAllBytes(Paths.get(rootPath + secret))).trim();\n    } catch (IOException e) {\n        return System.getenv(secret);\n    }\n}",
    "parameters": "[String secret]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "handle",
    "body": "",
    "parameters": "[String requestToken, ServerWebExchange exchange, WebFilterChain chain]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "",
    "name": "setAuthenticated",
    "body": "",
    "parameters": "[String userEmailOrId, String token, ServerWebExchange exchange, WebFilterChain chain]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "",
    "name": "handle",
    "body": "",
    "parameters": "[String emailToResend, ServerWebExchange exchange, WebFilterChain chain]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "",
    "name": "handle",
    "body": "",
    "parameters": "[String resetCode, ServerWebExchange exchange, WebFilterChain chain]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "",
    "name": "handle",
    "body": "",
    "parameters": "[String codeToSet, ServerWebExchange exchange, WebFilterChain chain]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "",
    "name": "handle",
    "body": "",
    "parameters": "[String activationCode, ServerWebExchange exchange, WebFilterChain chain]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "",
    "name": "handle",
    "body": "{\n    return Mono.just(Objects.requireNonNull(emailToResend)).filter(Util::isValidEmail).flatMap(DAO::findByEmail).flatMap(userDTO -> activationService.findById(userDTO.get_id())).flatMap(activationDto -> authenticationManager.setAuthenticated(activationDto.getId(), null, exchange, chain)).switchIfEmpty(Mono.defer(() -> respondWithJson(exchange, error(\"Email not found.\"))));\n}",
    "parameters": "[String emailToResend, ServerWebExchange exchange, WebFilterChain chain]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "",
    "name": "respondWithJson",
    "body": "{\n    if (!exchange.getResponse().isCommitted()) {\n        exchange.getResponse().setStatusCode(HttpStatus.OK);\n        exchange.getResponse().getHeaders().setContentType(MediaType.APPLICATION_JSON);\n        byte[] jsonBytes = convertToJsonAsBytes(response);\n        DataBuffer dataBuffer = exchange.getResponse().bufferFactory().wrap(jsonBytes);\n        return exchange.getResponse().writeWith(Mono.just(dataBuffer));\n    } else {\n        return Mono.empty();\n    }\n}",
    "parameters": "[ServerWebExchange exchange, Object response]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "",
    "name": "send",
    "body": "{\n    if (!exchange.getResponse().isCommitted()) {\n        exchange.getResponse().setStatusCode(HttpStatus.BAD_REQUEST);\n        exchange.getResponse().getHeaders().setContentType(MediaType.TEXT_HTML);\n        DataBuffer dataBuffer = exchange.getResponse().bufferFactory().wrap(htmlContent.getBytes(StandardCharsets.UTF_8));\n        return exchange.getResponse().writeWith(Mono.just(dataBuffer));\n    } else {\n        return Mono.empty();\n    }\n}",
    "parameters": "[ServerWebExchange exchange, String htmlContent]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "",
    "name": "setAuthenticated",
    "body": "{\n    return userService.findByUsername(userEmailOrId).map(user -> new UsernamePasswordAuthenticationToken(user, token, user.getAuthorities())).cast(Authentication.class).flatMap(authentication -> chain.filter(exchange).contextWrite(ReactiveSecurityContextHolder.withAuthentication(authentication))).then();\n}",
    "parameters": "[String userEmailOrId, String token, ServerWebExchange exchange, WebFilterChain chain]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "",
    "name": "handle",
    "body": "{\n    String FAIL_HTML_FOR_ACTIVATION = Htmls.FailActivation.get().replace(\"LOGO_WAC\", globalValues.getUrlWacLogoPngSmall()).replace(\"PATH_TO_RESEND\", globalValues.getPathToResendActvationMail()).replace(\"EMAIL_WAC\", globalValues.getMailToWac());\n    return activationService.findByCode(activationCode).flatMap(activationDto -> authenticationManager.setAuthenticated(activationDto.getId(), null, exchange, chain)).switchIfEmpty(Mono.defer(() -> responseErrorHtml.send(exchange, FAIL_HTML_FOR_ACTIVATION)));\n}",
    "parameters": "[String activationCode, ServerWebExchange exchange, WebFilterChain chain]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "",
    "name": "handle",
    "body": "{\n    String FAIL_HTML_FOR_RESET = Htmls.FailReset.get().replace(\"LOGO_WAC\", globalValues.getUrlWacLogoPngSmall()).replace(\"EMAIL_WAC\", globalValues.getMailToWac());\n    return resetService.findByCode(resetCode).flatMap(resetDto -> authenticationManager.setAuthenticated(resetDto.getId(), null, exchange, chain)).switchIfEmpty(Mono.defer(() -> responseErrorHtml.send(exchange, FAIL_HTML_FOR_RESET.replace(\"errorDescriptionValue\", \"Code Not Found\")))).onErrorResume(throwable -> Mono.defer(() -> responseErrorHtml.send(exchange, FAIL_HTML_FOR_RESET.replace(\"errorDescriptionValue\", throwable.getMessage()))));\n}",
    "parameters": "[String resetCode, ServerWebExchange exchange, WebFilterChain chain]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "",
    "name": "handle",
    "body": "{\n    String FAIL_HTML_FOR_RESET = Htmls.FailSetNewPassword.get().replace(\"LOGO_WAC\", globalValues.getUrlWacLogoPngSmall()).replace(\"URL_FORGOT_PASS\", globalValues.getUrlForgotPassword()).replace(\"EMAIL_WAC\", globalValues.getMailToWac());\n    return resetService.findByCode(codeToSet).flatMap(resetDto -> authenticationManager.setAuthenticated(resetDto.getId(), null, exchange, chain)).switchIfEmpty(Mono.defer(() -> responseErrorHtml.send(exchange, FAIL_HTML_FOR_RESET.replace(\"errorDescriptionValue\", \"Code Not Found\")))).onErrorResume(throwable -> Mono.defer(() -> responseErrorHtml.send(exchange, FAIL_HTML_FOR_RESET.replace(\"errorDescriptionValue\", throwable.getMessage()))));\n}",
    "parameters": "[String codeToSet, ServerWebExchange exchange, WebFilterChain chain]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "",
    "name": "handle",
    "body": "{\n    return Mono.justOrEmpty(requestToken).filter(token -> jwtUtil.hasToken(token) && jwtUtil.isValidToken(token)).flatMap(token -> {\n        String tokenWithoutPrefix = jwtUtil.extractPrefix(token);\n        String username = jwtUtil.getUsernameFromToken(tokenWithoutPrefix);\n        return authenticationManager.setAuthenticated(username, tokenWithoutPrefix, exchange, chain);\n    }).onErrorResume(// Handle error globally\n    e -> handleError(e, exchange));\n}",
    "parameters": "[String requestToken, ServerWebExchange exchange, WebFilterChain chain]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "",
    "name": "handleError",
    "body": "{\n    if (!exchange.getResponse().isCommitted()) {\n        String errorMessage;\n        if (e instanceof ExpiredJwtException)\n            errorMessage = \"Token expired. Please login again.\";\n        else if (e instanceof JwtException)\n            errorMessage = \"Invalid token.\";\n        else\n            errorMessage = e.getMessage();\n        return sendUnauthorizedResponse(exchange, errorMessage);\n    } else {\n        return Mono.empty();\n    }\n}",
    "parameters": "[Throwable e, ServerWebExchange exchange]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "",
    "name": "sendUnauthorizedResponse",
    "body": "{\n    HttpStatus status = HttpStatus.UNAUTHORIZED;\n    ServerHttpResponse response = exchange.getResponse();\n    response.setStatusCode(status);\n    response.getHeaders().setContentType(MediaType.APPLICATION_JSON);\n    Response errorResponse = error(errorMessage);\n    byte[] bytes = convertToJsonAsBytes(errorResponse);\n    DataBuffer buffer = response.bufferFactory().wrap(bytes);\n    return response.writeWith(Mono.just(buffer));\n}",
    "parameters": "[ServerWebExchange exchange, String errorMessage]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "",
    "name": "send",
    "body": "",
    "parameters": "[ServerWebExchange exchange, String htmlContent]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a request handler that processes requests based on the specified handler function and JWT key.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The function to handle the request.'}]}', name=Optional[handlerFunction]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The JWT key used to identify the request.'}]}', name=Optional[jwtKey]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A RequestHandler that processes the request.'}]}', name=Optional.empty}]}",
    "name": "createHandler",
    "body": "{\n    return (exchange, chain) -> {\n        String paramValue = getHeaderOrParamValue(exchange, jwtKey);\n        return handlerFunction.apply(paramValue, exchange, chain);\n    };\n}",
    "parameters": "[TriFunction<String, ServerWebExchange, WebFilterChain, Mono<Void>> handlerFunction, String jwtKey]",
    "returnType": "RequestHandler"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Filters the web exchange and delegates to the appropriate handler based on the presence of specific headers or query parameters.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The current server web exchange.'}]}', name=Optional[exchange]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The web filter chain.'}]}', name=Optional[chain]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Mono<Void> that indicates when request processing is complete.'}]}', name=Optional.empty}]}",
    "name": "filter",
    "body": "{\n    return handlers.entrySet().stream().filter(entry -> requestContainsKey(exchange, entry.getKey())).findFirst().map(entry -> entry.getValue().handle(exchange, chain)).orElseGet(() -> chain.filter(exchange));\n}",
    "parameters": "[@NotNull ServerWebExchange exchange, @NotNull WebFilterChain chain]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Checks if the request contains the specified key in headers or query parameters.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The current server web exchange.'}]}', name=Optional[exchange]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The key to check in the request.'}]}', name=Optional[key]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='True if the request contains the specified key, false otherwise.'}]}', name=Optional.empty}]}",
    "name": "requestContainsKey",
    "body": "{\n    return exchange.getRequest().getHeaders().containsKey(key) || exchange.getRequest().getQueryParams().containsKey(key);\n}",
    "parameters": "[ServerWebExchange exchange, String key]",
    "returnType": "boolean"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves the value of the specified key from the request headers or query parameters.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The current server web exchange.'}]}', name=Optional[exchange]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The key to retrieve the value for.'}]}', name=Optional[key]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The value of the specified key, or null if not found.'}]}', name=Optional.empty}]}",
    "name": "getHeaderOrParamValue",
    "body": "{\n    return Optional.ofNullable(exchange.getRequest().getHeaders().getFirst(key)).orElse(exchange.getRequest().getQueryParams().getFirst(key));\n}",
    "parameters": "[ServerWebExchange exchange, String key]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "handle",
    "body": "",
    "parameters": "[ServerWebExchange exchange, WebFilterChain chain]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "",
    "name": "apply",
    "body": "",
    "parameters": "[T t, U u, V v]",
    "returnType": "R"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Initializes the email credentials by reading Docker secrets.\nSets the system properties for email user and password.'}]}, blockTags=[]}",
    "name": "init",
    "body": "{\n    try {\n        String USER = \"SPRING_MAIL_VALIDATION\";\n        String APP_PASS = \"GMAIL_APP_PASSWORD\";\n        springMailUser = DockerConfig.readSecret(USER);\n        gMailAppPass = DockerConfig.readSecret(APP_PASS);\n        if (StringUtils.hasText(springMailUser))\n            System.setProperty(USER, springMailUser.trim());\n        log.warn(\"springMailUser : {}\", StringUtils.hasText(springMailUser));\n        if (StringUtils.hasText(gMailAppPass))\n            System.setProperty(APP_PASS, gMailAppPass.trim());\n        log.warn(\"springMailPass : {}\", StringUtils.hasText(gMailAppPass));\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Configures and returns a JavaMailSender instance.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The configured JavaMailSender instance.'}]}', name=Optional.empty}]}",
    "name": "getJavaMailSender",
    "body": "{\n    JavaMailSenderImpl mailSender = new JavaMailSenderImpl();\n    mailSender.setHost(\"smtp.gmail.com\");\n    mailSender.setPort(587);\n    mailSender.setUsername(springMailUser);\n    mailSender.setPassword(gMailAppPass);\n    Properties props = mailSender.getJavaMailProperties();\n    props.put(\"mail.transport.protocol\", \"smtp\");\n    props.put(\"mail.smtp.auth\", \"true\");\n    props.put(\"mail.smtp.starttls.enable\", \"true\");\n    // props.put(\"mail.debug\", \"true\");\n    return mailSender;\n}",
    "parameters": "[]",
    "returnType": "JavaMailSender"
  },
  {
    "javadoc": "",
    "name": "getJavadoc",
    "body": "{\n    try {\n        Resource resource = new FileSystemResource(\"/app/javadoc/index.html\");\n        if (!resource.exists()) {\n            log.error(\"Javadoc file not found at /app/javadoc/index.html\");\n            return new ResponseEntity<>(HttpStatus.NOT_FOUND);\n        }\n        byte[] content = Files.readAllBytes(resource.getFile().toPath());\n        HttpHeaders headers = new HttpHeaders();\n        headers.add(\"Content-Type\", \"text/html\");\n        return new ResponseEntity<>(content, headers, HttpStatus.OK);\n    } catch (IOException e) {\n        log.error(\"Error reading Javadoc file: \", e);\n        return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n}",
    "parameters": "[]",
    "returnType": "ResponseEntity<byte[]>"
  },
  {
    "javadoc": "",
    "name": "register",
    "body": "{\n    return auth.registerNewUser(userJson);\n}",
    "parameters": "[@Valid @RequestBody UserJustToSave userJson]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "",
    "name": "createAuthenticationTokenByLogin",
    "body": "{\n    return auth.authenticationByLogin(AuthRequestDto);\n}",
    "parameters": "[@RequestBody AuthRequestDto AuthRequestDto]",
    "returnType": "Mono<ResponseEntity<Response>>"
  },
  {
    "javadoc": "",
    "name": "forgotPassword",
    "body": "{\n    return auth.sendEmailCodeToResetPassword(userJson);\n}",
    "parameters": "[@RequestBody UserJson userJson]",
    "returnType": "Mono<ResponseEntity<Response>>"
  },
  {
    "javadoc": "",
    "name": "getFavorites",
    "body": "{\n    return AuthorizationUtil.executeIfAuthorized(favoriteRequest, (json, userDetails) -> favoriteService.getFavorites(favoriteRequest));\n}",
    "parameters": "[@RequestBody @Nonnull FavoriteRequest favoriteRequest]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "",
    "name": "addFavoriteRecipe",
    "body": "{\n    return AuthorizationUtil.executeIfAuthorized(favoriteRequest, (json, userDetails) -> favoriteService.addFavoriteRecipe(favoriteRequest));\n}",
    "parameters": "[@RequestBody @Nonnull FavoriteRequest favoriteRequest]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "",
    "name": "addFavoriteIngredient",
    "body": "{\n    return AuthorizationUtil.executeIfAuthorized(favoriteRequest, (json, userDetails) -> favoriteService.addFavoriteIngredient(favoriteRequest));\n}",
    "parameters": "[@RequestBody @Nonnull FavoriteRequest favoriteRequest]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "",
    "name": "removeFavoriteRecipe",
    "body": "{\n    return AuthorizationUtil.executeIfAuthorized(favoriteRequest, (json, userDetails) -> favoriteService.removeFavoriteRecipe(favoriteRequest));\n}",
    "parameters": "[@RequestBody @Nonnull FavoriteRequest favoriteRequest]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "",
    "name": "removeFavoriteIngredient",
    "body": "{\n    return AuthorizationUtil.executeIfAuthorized(favoriteRequest, (json, userDetails) -> favoriteService.removeFavoriteIngredient(favoriteRequest));\n}",
    "parameters": "[@RequestBody @Nonnull FavoriteRequest favoriteRequest]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "",
    "name": "handleValidationExceptions",
    "body": "{\n    Map<String, String> errorMsg = ex.getBindingResult().getFieldErrors().stream().collect(Collectors.groupingBy(FieldError::getField, Collectors.mapping(FieldError::getDefaultMessage, Collectors.joining(\"; \"))));\n    return createErrorResponse(HttpStatus.BAD_REQUEST, \"Invalid or incorrect format!!!\", errorMsg);\n}",
    "parameters": "[MethodArgumentNotValidException ex]",
    "returnType": "Response"
  },
  {
    "javadoc": "",
    "name": "handleValidationExceptions",
    "body": "{\n    @SuppressWarnings(\"DataFlowIssue\")\n    Map<String, String> errors = ex.getFieldErrors().stream().collect(Collectors.toMap(FieldError::getField, FieldError::getDefaultMessage, (existing, replacement) -> existing));\n    return createErrorResponse(HttpStatus.BAD_REQUEST, \"Invalid or incorrect format!!!\", errors);\n}",
    "parameters": "[WebExchangeBindException ex]",
    "returnType": "Response"
  },
  {
    "javadoc": "",
    "name": "handleConstraintViolationException",
    "body": "{\n    var errors = ex.getConstraintViolations().stream().collect(Collectors.toMap(violation -> {\n        String path = violation.getPropertyPath().toString();\n        // Retorna solo el nombre del campo\n        return path.substring(path.lastIndexOf('.') + 1);\n    }, // El mensaje de error para esa violación\n    ConstraintViolation::getMessage, // En caso de campos duplicados, mantiene el primer mensaje de error encontrado\n    (existingValue, newValue) -> existingValue));\n    return createErrorResponse(HttpStatus.BAD_REQUEST, \"Validation error\", errors);\n}",
    "parameters": "[ConstraintViolationException ex]",
    "returnType": "Response"
  },
  {
    "javadoc": "",
    "name": "handleValidationExceptions",
    "body": "{\n    String errorMessage = \"Invalid request body or not present: A valid request body is required.\";\n    return createErrorResponse(HttpStatus.BAD_REQUEST, errorMessage, ex);\n}",
    "parameters": "[DecodingException ex]",
    "returnType": "Response"
  },
  {
    "javadoc": "",
    "name": "handleInvalidRequest",
    "body": "{\n    return createErrorResponse(HttpStatus.BAD_REQUEST, \"Invalid or incorrect requisition!!!\", ex);\n}",
    "parameters": "[Exception ex]",
    "returnType": "Response"
  },
  {
    "javadoc": "",
    "name": "handleCantFoundWhatYouWant",
    "body": "{\n    return createErrorResponse(HttpStatus.INTERNAL_SERVER_ERROR, \"Couldn't find what you want\", ex);\n}",
    "parameters": "[Exception ex]",
    "returnType": "Response"
  },
  {
    "javadoc": "",
    "name": "handleRequestNotFound",
    "body": "{\n    return createErrorResponse(HttpStatus.NOT_FOUND, \"SORRY BABY, the fault is ours!!!\", ex);\n}",
    "parameters": "[Exception ex]",
    "returnType": "Response"
  },
  {
    "javadoc": "",
    "name": "handleJwtException",
    "body": "{\n    return createErrorResponse(HttpStatus.UNAUTHORIZED, \"Please, Log in again!!!\", ex);\n}",
    "parameters": "[Exception ex]",
    "returnType": "Response"
  },
  {
    "javadoc": "",
    "name": "createErrorResponse",
    "body": "{\n    return Response.error(httpMessageError(status, customMessage), Map.of(\"ERROR\", ex.getMessage().split(\":\")[0]));\n}",
    "parameters": "[HttpStatus status, String customMessage, Exception ex]",
    "returnType": "Response"
  },
  {
    "javadoc": "",
    "name": "createErrorResponse",
    "body": "{\n    return Response.error(httpMessageError(status, customMessage), map);\n}",
    "parameters": "[HttpStatus status, String customMessage, Map map]",
    "returnType": "Response"
  },
  {
    "javadoc": "",
    "name": "httpMessageError",
    "body": "{\n    return String.format(\"[%s - %d] 8==> %s\", status.getReasonPhrase().toUpperCase(), status.value(), msg);\n}",
    "parameters": "[HttpStatus status, String msg]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "existsByEmail",
    "body": "{\n    return service.existsByEmail(userJson);\n}",
    "parameters": "[@Valid @RequestBody UserJson userJson]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "",
    "name": "readOne",
    "body": "{\n    return AuthorizationUtil.executeIfAuthorized(userJson, (json, userDetails) -> service.readOne(json));\n}",
    "parameters": "[@Valid @RequestBody UserJson userJson]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "",
    "name": "update",
    "body": "{\n    return AuthorizationUtil.executeIfAuthorized(userJson, (json, userDetails) -> service.updateOne(json));\n}",
    "parameters": "[@RequestBody UserJson userJson]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "",
    "name": "deleteOne",
    "body": "{\n    return AuthorizationUtil.executeIfAuthorized(new UserJson(id), (json, userDetails) -> service.deleteOne(json));\n}",
    "parameters": "[@RequestParam(\"id\") String id]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "",
    "name": "activate",
    "body": "{\n    return service.activateAccount(activationCode);\n}",
    "parameters": "[@RequestParam(\"activationCode\") String activationCode]",
    "returnType": "Mono<ResponseEntity<String>>"
  },
  {
    "javadoc": "",
    "name": "resendActivation",
    "body": "{\n    return service.resendActivateCode(emailToResend);\n}",
    "parameters": "[@ValidEmail @RequestParam(\"emailToResend\") String emailToResend]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "",
    "name": "resetPassword",
    "body": "{\n    return service.resetPasswordByCode(resetCode);\n}",
    "parameters": "[@RequestParam(\"resetCode\") String resetCode]",
    "returnType": "Mono<ResponseEntity<String>>"
  },
  {
    "javadoc": "",
    "name": "setNewPassword",
    "body": "{\n    return service.setNewPasswordByCode(userJson);\n}",
    "parameters": "[@RequestBody UserJson userJson]",
    "returnType": "Mono<ResponseEntity<String>>"
  },
  {
    "javadoc": "",
    "name": "isValidBirthdate",
    "body": "{\n    return birthdate != null && !birthdate.isAfter(LocalDate.now().minusYears(7));\n}",
    "parameters": "[LocalDate birthdate]",
    "returnType": "boolean"
  },
  {
    "javadoc": "",
    "name": "notValidBirthdate",
    "body": "{\n    return birthdate == null || birthdate.isAfter(LocalDate.now().minusYears(7));\n}",
    "parameters": "[LocalDate birthdate]",
    "returnType": "boolean"
  },
  {
    "javadoc": "",
    "name": "isNullOrEmpty",
    "body": "{\n    return !StringUtils.hasText(something);\n}",
    "parameters": "[String something]",
    "returnType": "boolean"
  },
  {
    "javadoc": "",
    "name": "isNullOrEmptyOrLiteralNull",
    "body": "{\n    return isNullOrEmpty(something) || \"null\".equalsIgnoreCase(something.trim());\n}",
    "parameters": "[String something]",
    "returnType": "boolean"
  },
  {
    "javadoc": "",
    "name": "notNullOrEmpty",
    "body": "{\n    return StringUtils.hasText(something) && !\"null\".equalsIgnoreCase(something.trim());\n}",
    "parameters": "[String something]",
    "returnType": "boolean"
  },
  {
    "javadoc": "",
    "name": "TitleCase",
    "body": "{\n    return isNullOrEmptyOrLiteralNull(toConvert) ? null : TitleCase.all(toConvert);\n}",
    "parameters": "[String toConvert]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "encryptPassword",
    "body": "{\n    return BCrypt.encode(toEncrypt);\n}",
    "parameters": "[String toEncrypt]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "encryptMatches",
    "body": "{\n    return notNullOrEmpty(rawPassword) && BCrypt.matches(rawPassword, encodedPassword);\n}",
    "parameters": "[String rawPassword, String encodedPassword]",
    "returnType": "boolean"
  },
  {
    "javadoc": "",
    "name": "encryptNotMatches",
    "body": "{\n    return !encryptMatches(rawPassword, encodedPassword);\n}",
    "parameters": "[String rawPassword, String encodedPassword]",
    "returnType": "boolean"
  },
  {
    "javadoc": "",
    "name": "isValidEmail",
    "body": "{\n    return notNullOrEmpty(email) && email.matches(buildEmailRegex());\n}",
    "parameters": "[String email]",
    "returnType": "boolean"
  },
  {
    "javadoc": "",
    "name": "notValidEmail",
    "body": "{\n    return isNullOrEmpty(email) || !email.matches(buildEmailRegex());\n}",
    "parameters": "[String email]",
    "returnType": "boolean"
  },
  {
    "javadoc": "",
    "name": "buildEmailRegex",
    "body": "{\n    String front = \"[\\\\p{L}\\\\p{N}!#$%&'*+/=?^_`{|}~-]+\";\n    String back = \"[\\\\p{L}\\\\p{N}](?:[a-z0-9-]*[\\\\p{L}\\\\p{N}]\";\n    String domain = String.format(\"(?:%s)?.)+%s)?\", back, back);\n    return String.format(\"%s(?:.%s)*@%s\", front, front, domain);\n}",
    "parameters": "[]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "isValidPassword",
    "body": "{\n    return notNullOrEmpty(password) && password.matches(buildPassRegex());\n}",
    "parameters": "[String password]",
    "returnType": "boolean"
  },
  {
    "javadoc": "",
    "name": "notValidPassword",
    "body": "{\n    return isNullOrEmpty(password) || !password.matches(buildPassRegex());\n}",
    "parameters": "[String password]",
    "returnType": "boolean"
  },
  {
    "javadoc": "",
    "name": "buildPassRegex",
    "body": "{\n    // String characters = \"!¡|'´`¨\\\\^*+@·#$%&/{}()=\\\\-_:.;,<>?¿\";\n    String charactersUnicode = \"\\\\u0021\\\\u00A1\\\\u007C\\\\u0027\\\\u00B4\\\\u0060\\\\u00A8\\\\u005E\\\\u002A\\\\u002B\\\\u0040\\\\u00B7\\\\u0023\\\\u0024\\\\u0025\\\\u0026\\\\u002F\\\\u007B\\\\u007D\\\\u0028\\\\u0029\\\\u003D\\\\u005C\\\\u002D\\\\u005F\\\\u003A\\\\u002E\\\\u003B\\\\u002C\\\\u003C\\\\u003E\\\\u003F\\\\u00BF\";\n    String regex = \"^(?=.*[\\\\p{Ll}])(?=.*[\\\\p{Lu}])(?=.*\\\\p{N})(?=.*[%s])[\\\\p{L}\\\\p{N}%s]{8,}$\";\n    return String.format(regex, charactersUnicode, charactersUnicode);\n}",
    "parameters": "[]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "convertToJsonAsString",
    "body": "{\n    try {\n        return new ObjectMapper().writeValueAsString(obj);\n    } catch (JsonProcessingException e) {\n        return \"{\\\"error\\\": \\\"Error converting to JSON.\\\"}\";\n    }\n}",
    "parameters": "[Object obj]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "convertToJsonAsBytes",
    "body": "{\n    try {\n        return new ObjectMapper().writeValueAsBytes(obj);\n    } catch (JsonProcessingException e) {\n        return \"{\\\"error\\\": \\\"Error converting to JSON.\\\"}\".getBytes();\n    }\n}",
    "parameters": "[Object obj]",
    "returnType": "byte[]"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Public static method that processes the string to be converted: eliminates\nany space characters that may be at the beginning and at the end, then\nremoves any double-spacing, after all, proceed with the conversion into Title\nCase.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string sentence that will be converted.'}]}', name=Optional[toConvert]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The same string sentence converted to a Title Case.'}]}', name=Optional.empty}]}",
    "name": "all",
    "body": "{\n    setExceptions();\n    setCapitalWord(false);\n    return toTitleSentence(toConvert);\n}",
    "parameters": "[String toConvert]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Public static method that processes the string to be converted: eliminates\nany space characters that may be at the beginning and at the end, then\nremoves any double-spacing, if you have any exceptions set to be ignored, after\nall, send everything to conversion.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string sentence that will be converted.'}]}', name=Optional[toConvert]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='array of strings with all words that will be ignored when\n                  converting OR words strings separated by a comma: \"word1\",\n                  \"word2\", \"word3\"...'}]}', name=Optional[exceptions]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the same string sentence converted to a Title Case.'}]}', name=Optional.empty}]}",
    "name": "withExceptions",
    "body": "{\n    setExceptions(exceptions);\n    setCapitalWord(false);\n    return toTitleSentence(toConvert);\n}",
    "parameters": "[String toConvert, String... exceptions]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Public static method that processes the string to be converted: eliminates\nany space characters that may be at the beginning and at the end, then\nremoves any double-spacing, if you have any exceptions set to be ignored, after\nall, send everything to conversion. This method ignores any word that is fully\ncapitalized if the whole sentence is not all in upper case, in this case it\nis necessary to configure the exceptions that will be ignored.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string sentence that will be converted.'}]}', name=Optional[toConvert]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='array of all words that will be ignored when converting\n                  OR words strings separated by a comma: \"word1\", \"word2\",\n                  \"word3\"...'}]}', name=Optional[exceptions]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the same string sentence converted to a Title Case.'}]}', name=Optional.empty}]}",
    "name": "withCAPITAL",
    "body": "{\n    setExceptions(exceptions);\n    setCapitalWord(!toConvert.matches(UPPER_SENTENCE));\n    return toTitleSentence(toConvert);\n}",
    "parameters": "[String toConvert, String... exceptions]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Public instance method that processes the string to be converted: eliminates\nany space characters that may be at the beginning and at the end, then\nremoves any double-spacing, use instance global exceptions to set the words\nto be ignored, after all, send everything to conversion.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string sentence that will be converted.'}]}', name=Optional[toConvert]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the same string sentence converted to a Title Case.'}]}', name=Optional.empty}]}",
    "name": "titleCase",
    "body": "{\n    setCapitalWord(false);\n    return toTitleSentence(toConvert);\n}",
    "parameters": "[String toConvert]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Public instance method that processes the string to be converted: eliminates\nany space characters that may be at the beginning and at the end, then\nremoves any double-spacing, use global instance exceptions to set the words\nto be ignored, after all, send everything to conversion. This method ignores\nany word that is fully capitalized if the whole sentence is not all in upper\ncase, in this case it is necessary to configure the exceptions that will be\nignored.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string sentence that will be converted.'}]}', name=Optional[toConvert]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the same string sentence converted to a Title Case.'}]}', name=Optional.empty}]}",
    "name": "titleCAPITAL",
    "body": "{\n    setCapitalWord(!toConvert.matches(UPPER_SENTENCE));\n    return toTitleSentence(toConvert);\n}",
    "parameters": "[String toConvert]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Private method that processes the string sentence to be converted: first\neliminates any space characters that may be at the beginning and at the end,\nthen removes any double-spacing, then split the string from its spaces in an\narray of words. For each one of them proceeds with the verification of your\nspecific case, then if '}, JavadocInlineTag{tagName='code', type=CODE, content=' capitalWord'}, JavadocSnippet{text=' is true will check if every word\nmatches with a fully capitalized word, if so it does not convert into a Title\nCase.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string sentence that will be converted.'}]}', name=Optional[toConvert]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the same string sentence converted to a Title Case.'}]}', name=Optional.empty}]}",
    "name": "toTitleSentence",
    "body": "{\n    setTheInput(toConvert);\n    setArrayOfConvertedWords();\n    if (hasExceptions())\n        rateFirstWordOfArray();\n    return String.join(\" \", arrayWords);\n}",
    "parameters": "[String toConvert]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Private auxiliary method that prepares the string that will be converted.\nFirst eliminate spaces that may exist at the beginning and at the end\n(TRIM), then replace any multiple space with single spaces.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to be converted'}]}', name=Optional[input]}]}",
    "name": "setTheInput",
    "body": "{\n    TitleCase.theInput = input.trim().replaceAll(\"( )+\", \" \");\n}",
    "parameters": "[String input]",
    "returnType": "void"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Private auxiliary method that break theInput to be converted into an array by\nsplit in spaces, then put that into a stream, then map to convert and collect\na new array. If there are exceptions, the first word may be one and thus\nensures that it is in title case'}]}, blockTags=[]}",
    "name": "setArrayOfConvertedWords",
    "body": "{\n    TitleCase.arrayWords = Arrays.stream(theInput.split(\" \")).map(TitleCase::rateWords).toArray(String[]::new);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Private auxiliary method that checks whether the word fits the exception rule\nor whether it should be converted to TitleCase, depending on the case invokes\nrelevant auxiliary methods'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string each word in an array'}]}', name=Optional[word]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='string treated word (converted if is the case)'}]}', name=Optional.empty}]}",
    "name": "rateWords",
    "body": "{\n    return isExceptions(word) ? rateExceptions(word) : toTitleCase(word);\n}",
    "parameters": "[String word]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Private auxiliary method that checks whether the word is an exception or not.\nCompare the word with the list of exceptions ignoring the Case, or if\ncapitalWord is true, check if the word is capitalized'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string each word in an array'}]}', name=Optional[word]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='boolean false if it doesn't match any type of exception or true if it\nmatches'}]}', name=Optional.empty}]}",
    "name": "isExceptions",
    "body": "{\n    boolean isException = Arrays.stream(exceptions.split(\" \")).parallel().anyMatch(w -> w.equalsIgnoreCase(word));\n    boolean isCapitalWord = capitalWord && word.matches(CAPITAL_WORD);\n    return isException || isCapitalWord;\n}",
    "parameters": "[String word]",
    "returnType": "boolean"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Private auxiliary method that checks if the word exists identically among the\nexceptions, if negative it returns all lower cases.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string each word in an array'}]}', name=Optional[word]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='returns the same string if it is an exception with Case variation or\nreturns all lower case if it is a word that needs to be ignored when\nconverting.'}]}', name=Optional.empty}]}",
    "name": "rateExceptions",
    "body": "{\n    boolean isException = Arrays.stream(exceptions.split(\" \")).parallel().anyMatch(w -> w.equals(word));\n    return capitalWord || isException ? word : word.toLowerCase();\n}",
    "parameters": "[String word]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Private auxiliary method that checks if there are exceptions, simply to\nimprove readability'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='boolean true if there are and false if not.'}]}', name=Optional.empty}]}",
    "name": "hasExceptions",
    "body": "{\n    return !TitleCase.exceptions.isEmpty();\n}",
    "parameters": "[]",
    "returnType": "boolean"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Private auxiliary method that converts the first word of the array to a title\ncase if necessary.'}]}, blockTags=[]}",
    "name": "rateFirstWordOfArray",
    "body": "{\n    boolean isFirstWordNonCapital = capitalWord && !arrayWords[0].matches(CAPITAL_WORD);\n    if (!capitalWord || isFirstWordNonCapital) {\n        arrayWords[0] = toTitleCase(arrayWords[0]);\n    }\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Private method that really does the heavy lifting of this utility class, it\nchecks if the word is made up of letters only or has special characters, for\neach case proceeds with the conversion in a different way.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string word itself that will be converted'}]}', name=Optional[word]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string word converted to a Title Case'}]}', name=Optional.empty}]}",
    "name": "toTitleCase",
    "body": "{\n    return (word.matches(JUST_LETTERS)) ? titleJustLetters(word) : titleWithPunts(word);\n}",
    "parameters": "[String word]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Private auxiliary method, if the word is only letters proceed with the\nsimplest conversion using substring.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string word itself that will be converted'}]}', name=Optional[word]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string word converted to a Title Case'}]}', name=Optional.empty}]}",
    "name": "titleJustLetters",
    "body": "{\n    return word.substring(0, 1).toUpperCase().concat(word.substring(1).toLowerCase());\n}",
    "parameters": "[String word]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Private auxiliary method that create a new Builder instance and add each\nconverted character then return it as a string'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string word itself that will be converted'}]}', name=Optional[word]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string word converted to a Title Case'}]}', name=Optional.empty}]}",
    "name": "titleWithPunts",
    "body": "{\n    builder = new StringBuilder();\n    Arrays.stream(word.split(\"\")).forEach(TitleCase::append);\n    return builder.toString();\n}",
    "parameters": "[String word]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Private auxiliary method which adds to the Builder each character converted\nfrom the word'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the character to be appended in builder'}]}', name=Optional[letter]}]}",
    "name": "append",
    "body": "{\n    builder.append(lowOrUp(letter));\n}",
    "parameters": "[String letter]",
    "returnType": "void"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Private auxiliary method, which evaluates each letter, needs to be capitalized\nor not.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the character in question that is being analyzed'}]}', name=Optional[letter]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the same character in upper or lower case'}]}', name=Optional.empty}]}",
    "name": "lowOrUp",
    "body": "{\n    return conditionToUpper() ? letter.toUpperCase() : letter.toLowerCase();\n}",
    "parameters": "[String letter]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Private auxiliary method, verify if is the first letter of the word, if there\nwas a space before or if there were any of these chars before:\n!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='boolean true if it is the first letter of the word or if it has a\nspecial char, false if not.'}]}', name=Optional.empty}]}",
    "name": "conditionToUpper",
    "body": "{\n    if (builder.isEmpty())\n        return true;\n    String lastCharOnBuilder = String.valueOf(builder.charAt(builder.length() - 1));\n    return lastCharOnBuilder.matches(\"\\\\p{Punct}|\\\\s\");\n}",
    "parameters": "[]",
    "returnType": "boolean"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='method that configures whether the conversion will ignore capitalized words\nor convert them too'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='boolean true to ignore words capitalized on conversion and\n                   false to convert them too'}]}', name=Optional[capitalWord]}]}",
    "name": "setCapitalWord",
    "body": "{\n    TitleCase.capitalWord = capitalWord;\n}",
    "parameters": "[boolean capitalWord]",
    "returnType": "void"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Method that configures exceptions, that is, the words that will be ignored\nwhen converting to TitleCase. This method has Varargs as a parameter, and\ntherefore the way of passing multiple words is in the form of strings\nseparated by a comma or an array of strings.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='Varargs with de words to be ignored'}]}', name=Optional[words]}]}",
    "name": "setExceptions",
    "body": "{\n    TitleCase.exceptions = Arrays.stream(words).parallel().map(TitleCase::concatAllVariations).collect(Collectors.joining(\" \"));\n}",
    "parameters": "[String... words]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "concatAllVariations",
    "body": "{\n    return word.concat(withSymbols(word)).concat(withWraps(word));\n}",
    "parameters": "[String word]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "withSymbols",
    "body": "{\n    return Arrays.stream(SYMBOLS.split(\"\")).parallel().map(s -> String.format(\" %s%s %s%s%s %s%s\", s, word, s, word, s, word, s)).collect(Collectors.joining());\n}",
    "parameters": "[String word]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "withWraps",
    "body": "{\n    builder = new StringBuilder();\n    for (int i = 0; i < RIGHT_WRAPS.length; i++) {\n        builder.append(String.format(\" %s%s%s\", RIGHT_WRAPS[i], word, LEFT_WRAPS[i]));\n    }\n    return builder.toString();\n}",
    "parameters": "[String word]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Converts a UserDto to an ActivationDto.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The user to convert.'}]}', name=Optional[user]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The corresponding ActivationDto.'}]}', name=Optional.empty}]}",
    "name": "to",
    "body": "{\n    ActivationDto activationDto = new ActivationDto();\n    activationDto.setId(user.get_id());\n    return activationDto;\n}",
    "parameters": "[UserDto user]",
    "returnType": "ActivationDto"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Generates a secure random activation code.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The generated activation code.'}]}', name=Optional.empty}]}",
    "name": "generateCode",
    "body": "{\n    SecureRandom random = new SecureRandom();\n    byte[] bytes = new byte[24];\n    random.nextBytes(bytes);\n    return Base64.getUrlEncoder().withoutPadding().encodeToString(bytes);\n}",
    "parameters": "[]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Converts a UserDto to a ResetDto.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The user to convert.'}]}', name=Optional[user]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The corresponding ResetDto.'}]}', name=Optional.empty}]}",
    "name": "to",
    "body": "{\n    var resetDto = new ResetDto();\n    resetDto.setId(user.get_id());\n    return resetDto;\n}",
    "parameters": "[UserDto user]",
    "returnType": "ResetDto"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Generates a secure random reset code.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The generated reset code.'}]}', name=Optional.empty}]}",
    "name": "generateCode",
    "body": "{\n    SecureRandom random = new SecureRandom();\n    byte[] bytes = new byte[64];\n    random.nextBytes(bytes);\n    return Base64.getUrlEncoder().withoutPadding().encodeToString(bytes);\n}",
    "parameters": "[]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the message associated with the status.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The status message.'}]}', name=Optional.empty}]}",
    "name": "getDetails",
    "body": "{\n    return message;\n}",
    "parameters": "[]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "get",
    "body": "{\n    return code;\n}",
    "parameters": "[]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the role string associated with the role.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The role string.'}]}', name=Optional.empty}]}",
    "name": "get",
    "body": "{\n    return role;\n}",
    "parameters": "[]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Adds a recipe to the list of favorite recipes if not already present.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ID of the recipe to add.'}]}', name=Optional[recipeId]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Mono emitting this FavoriteDto.'}]}', name=Optional.empty}]}",
    "name": "addRecipe",
    "body": "{\n    return Mono.just(recipeId).filterWhen(this::notContainsRecipe).doOnNext(recipes::add).thenReturn(this);\n}",
    "parameters": "[String recipeId]",
    "returnType": "Mono<FavoriteDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Removes a recipe from the list of favorite recipes.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ID of the recipe to remove.'}]}', name=Optional[recipeId]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Mono emitting this FavoriteDto.'}]}', name=Optional.empty}]}",
    "name": "removeRecipe",
    "body": "{\n    return Mono.just(recipeId).doOnNext(recipes::remove).thenReturn(this);\n}",
    "parameters": "[String recipeId]",
    "returnType": "Mono<FavoriteDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Checks if a recipe is in the list of favorite recipes.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ID of the recipe to check.'}]}', name=Optional[recipeId]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Mono emitting true if the recipe is in the list, otherwise false.'}]}', name=Optional.empty}]}",
    "name": "containsRecipe",
    "body": "{\n    return Mono.just(recipes.contains(recipeId));\n}",
    "parameters": "[String recipeId]",
    "returnType": "Mono<Boolean>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Checks if a recipe is not in the list of favorite recipes.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ID of the recipe to check.'}]}', name=Optional[recipeId]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Mono emitting true if the recipe is not in the list, otherwise false.'}]}', name=Optional.empty}]}",
    "name": "notContainsRecipe",
    "body": "{\n    return containsRecipe(recipeId).map(exists -> !exists);\n}",
    "parameters": "[String recipeId]",
    "returnType": "Mono<Boolean>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Adds an ingredient to the list of favorite ingredients if not already present.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ID of the ingredient to add.'}]}', name=Optional[ingredientId]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Mono emitting this FavoriteDto.'}]}', name=Optional.empty}]}",
    "name": "addIngredient",
    "body": "{\n    return Mono.just(ingredientId).filterWhen(this::notContainsFavoriteIngredient).doOnNext(ingredients::add).thenReturn(this);\n}",
    "parameters": "[String ingredientId]",
    "returnType": "Mono<FavoriteDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Removes an ingredient from the list of favorite ingredients.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ID of the ingredient to remove.'}]}', name=Optional[ingredientId]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Mono emitting this FavoriteDto.'}]}', name=Optional.empty}]}",
    "name": "removeIngredient",
    "body": "{\n    return Mono.just(ingredientId).doOnNext(ingredients::remove).thenReturn(this);\n}",
    "parameters": "[String ingredientId]",
    "returnType": "Mono<FavoriteDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Checks if an ingredient is in the list of favorite ingredients.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ID of the ingredient to check.'}]}', name=Optional[ingredientId]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Mono emitting true if the ingredient is in the list, otherwise false.'}]}', name=Optional.empty}]}",
    "name": "containsFavoriteIngredient",
    "body": "{\n    return Mono.just(ingredients.contains(ingredientId));\n}",
    "parameters": "[String ingredientId]",
    "returnType": "Mono<Boolean>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Checks if an ingredient is not in the list of favorite ingredients.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ID of the ingredient to check.'}]}', name=Optional[ingredientId]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Mono emitting true if the ingredient is not in the list, otherwise false.'}]}', name=Optional.empty}]}",
    "name": "notContainsFavoriteIngredient",
    "body": "{\n    return containsFavoriteIngredient(ingredientId).map(exists -> !exists);\n}",
    "parameters": "[String ingredientId]",
    "returnType": "Mono<Boolean>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Gets the user ID.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The user ID.'}]}', name=Optional.empty}]}",
    "name": "get_id",
    "body": "{\n    return userId;\n}",
    "parameters": "[]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates an error response with a message.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The error message.'}]}', name=Optional[message]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Response object indicating an error.'}]}', name=Optional.empty}]}",
    "name": "error",
    "body": "{\n    Response response = new Response();\n    response.put(SUCCESS, false);\n    response.put(MESSAGE, setMessage(message));\n    return response;\n}",
    "parameters": "[String message]",
    "returnType": "Response"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a Mono wrapping an error response with a message.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The error message.'}]}', name=Optional[message]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Mono wrapping a Response object indicating an error.'}]}', name=Optional.empty}]}",
    "name": "monoError",
    "body": "{\n    return Mono.just(error(message));\n}",
    "parameters": "[String message]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a Mono wrapping an error response from an exception.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The exception.'}]}', name=Optional[e]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Mono wrapping a Response object indicating an error.'}]}', name=Optional.empty}]}",
    "name": "monoError",
    "body": "{\n    return monoError(e.getMessage());\n}",
    "parameters": "[Exception e]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a Mono wrapping an error response from a throwable.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The throwable.'}]}', name=Optional[e]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Mono wrapping a Response object indicating an error.'}]}', name=Optional.empty}]}",
    "name": "monoError",
    "body": "{\n    return monoError(e.getMessage());\n}",
    "parameters": "[Throwable e]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates an error response with a message and additional content.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The error message.'}]}', name=Optional[message]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The additional content.'}]}', name=Optional[content]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Response object indicating an error.'}]}', name=Optional.empty}]}",
    "name": "error",
    "body": "{\n    Response response = error(message);\n    if (content != null)\n        response.put(CONTENT, content);\n    return response;\n}",
    "parameters": "[String message, @Nullable Object content]",
    "returnType": "Response"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a Mono wrapping an error response with a message and additional content.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The error message.'}]}', name=Optional[message]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The additional content.'}]}', name=Optional[content]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Mono wrapping a Response object indicating an error.'}]}', name=Optional.empty}]}",
    "name": "monoError",
    "body": "{\n    return Mono.just(error(message, content));\n}",
    "parameters": "[String message, @Nullable Object content]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a Mono wrapping an error response from a UserServiceException.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The UserServiceException.'}]}', name=Optional[e]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Mono wrapping a Response object indicating an error.'}]}', name=Optional.empty}]}",
    "name": "monoError",
    "body": "{\n    return monoError(e.getMessage(), e.getErrors());\n}",
    "parameters": "[UserServiceException e]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a success response with a message and additional content.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The success message.'}]}', name=Optional[message]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The additional content.'}]}', name=Optional[content]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Response object indicating success.'}]}', name=Optional.empty}]}",
    "name": "success",
    "body": "{\n    Response response = new Response();\n    response.put(SUCCESS, true);\n    response.put(MESSAGE, setMessage(message));\n    if (content != null)\n        response.put(CONTENT, content);\n    return response;\n}",
    "parameters": "[String message, @Nullable Object content]",
    "returnType": "Response"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Sets the message if it's not null or empty.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The message to set.'}]}', name=Optional[message]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The message if not null or empty, otherwise a default error message.'}]}', name=Optional.empty}]}",
    "name": "setMessage",
    "body": "{\n    return (notNullOrEmpty(message)) ? message : MESSAGE_ERROR;\n}",
    "parameters": "[String message]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Gets the message from the response.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The message from the response.'}]}', name=Optional.empty}]}",
    "name": "getMessage",
    "body": "{\n    return (get(MESSAGE) == null) ? MESSAGE_ERROR : (String) get(MESSAGE);\n}",
    "parameters": "[]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Checks if the response indicates success.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='True if the response indicates success, otherwise false.'}]}', name=Optional.empty}]}",
    "name": "isSuccess",
    "body": "{\n    return (boolean) get(SUCCESS);\n}",
    "parameters": "[]",
    "returnType": "boolean"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Gets the content from the response.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The content from the response.'}]}', name=Optional.empty}]}",
    "name": "getContent",
    "body": "{\n    return map.containsKey(CONTENT) ? map.get(CONTENT) : map.remove(CONTENT);\n}",
    "parameters": "[]",
    "returnType": "Object"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Adds a message to the response.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The message to add.'}]}', name=Optional[message]}]}",
    "name": "addMessage",
    "body": "{\n    if (notNullOrEmpty(message))\n        this.put(MESSAGE, this.get(MESSAGE) + message);\n}",
    "parameters": "[String message]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "toString",
    "body": "{\n    return this.map.toString();\n}",
    "parameters": "[]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "put",
    "body": "{\n    map.put(key, value);\n}",
    "parameters": "[String key, Object value]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "get",
    "body": "{\n    return map.get(key);\n}",
    "parameters": "[String key]",
    "returnType": "Object"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a Mono that emits this exception with the specified message.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The detail message.'}]}', name=Optional[message]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The type parameter.'}]}', name=Optional[<T>]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Mono that emits this exception.'}]}', name=Optional.empty}]}",
    "name": "mono",
    "body": "{\n    return Mono.error(new UserServiceException(message));\n}",
    "parameters": "[String message]",
    "returnType": "Mono<T>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a Mono that emits this exception with the specified message and errors.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The detail message.'}]}', name=Optional[message]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The errors map.'}]}', name=Optional[errors]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The type parameter.'}]}', name=Optional[<T>]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Mono that emits this exception.'}]}', name=Optional.empty}]}",
    "name": "mono",
    "body": "{\n    return Mono.error(new UserServiceException(message, errors));\n}",
    "parameters": "[String message, Map<String, Object> errors]",
    "returnType": "Mono<T>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a Mono that emits this exception based on another throwable.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The throwable to base the exception on.'}]}', name=Optional[e]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The type parameter.'}]}', name=Optional[<T>]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Mono that emits this exception.'}]}', name=Optional.empty}]}",
    "name": "mono",
    "body": "{\n    return Mono.error(new UserServiceException(e.getMessage()));\n}",
    "parameters": "[Throwable e]",
    "returnType": "Mono<T>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Throws this exception based on another throwable.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The throwable to base the exception on.'}]}', name=Optional[throwable]}]}",
    "name": "doOnErrorMap",
    "body": "{\n    throw new UserServiceException(throwable.getMessage());\n}",
    "parameters": "[Throwable throwable]",
    "returnType": "void"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns this exception based on another throwable.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The throwable to base the exception on.'}]}', name=Optional[throwable]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='This exception.'}]}', name=Optional.empty}]}",
    "name": "onErrorMap",
    "body": "{\n    return new UserServiceException(throwable.getMessage());\n}",
    "parameters": "[Throwable throwable]",
    "returnType": "Throwable"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a new instance of this exception indicating a password mismatch.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A new UserServiceException indicating a password mismatch.'}]}', name=Optional.empty}]}",
    "name": "passNotMatch",
    "body": "{\n    return new UserServiceException(\"Password doesn't match!\");\n}",
    "parameters": "[]",
    "returnType": "UserServiceException"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Converts this UserJustToSave to a UserDto object.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A UserDto object representing this UserJustToSave.'}]}', name=Optional.empty}]}",
    "name": "toUserDTO",
    "body": "{\n    UserDto userDTO = new UserDto();\n    userDTO.setEmail(email);\n    userDTO.setPassword(encryptPassword(password));\n    userDTO.setFirstName(firstName);\n    userDTO.setSurNames(surNames);\n    userDTO.setBirthdate(birthdate);\n    return userDTO;\n}",
    "parameters": "[]",
    "returnType": "UserDto"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a UserJson object from a UserDto object.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The UserDto object to convert.'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A UserJson object.'}]}', name=Optional.empty}]}",
    "name": "from",
    "body": "{\n    return new UserJson(userDTO);\n}",
    "parameters": "[UserDto userDTO]",
    "returnType": "UserJson"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Converts this UserDto to a UserJson object.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A UserJson object representing this UserDto.'}]}', name=Optional.empty}]}",
    "name": "toJson",
    "body": "{\n    return UserJson.from(this);\n}",
    "parameters": "[]",
    "returnType": "UserJson"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Converts this UserDto to a UserJson object without the ID.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A UserJson object representing this UserDto without the ID.'}]}', name=Optional.empty}]}",
    "name": "toJsonWithoutId",
    "body": "{\n    this.set_id(null);\n    return UserJson.from(this);\n}",
    "parameters": "[]",
    "returnType": "UserJson"
  },
  {
    "javadoc": "",
    "name": "main",
    "body": "{\n    SpringApplication.run(WhataCookUsersApplication.class, args);\n}",
    "parameters": "[String[] args]",
    "returnType": "void"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Checks if a user exists by email.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userJson]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a response indicating whether the user exists'}]}', name=Optional.empty}]}",
    "name": "existsByEmail",
    "body": "{\n    return read.checkIfExistsByEmail(userJson).map(alreadyExists -> alreadyExists ? success(\"User already exists\", true) : success(\"User does not exist yet\", false)).onErrorResume(UserServiceException.class, Response::monoError).onErrorResume(Exception.class, Response::monoError);\n}",
    "parameters": "[UserJson userJson]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Activates a user account using an activation code.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the activation code'}]}', name=Optional[activationCode]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a response entity indicating the result of the activation'}]}', name=Optional.empty}]}",
    "name": "activateAccount",
    "body": "{\n    return activate.byActivationCodeSentByEmail(activationCode).map(ResponseEntity::ok).onErrorResume(UserServiceException.class, uEx -> Mono.just(ResponseEntity.badRequest().body(error(uEx.getMessage(), uEx.getErrors()).toString()))).onErrorResume(Exception.class, ex -> Mono.just(ResponseEntity.badRequest().body(error(ex.getMessage()).toString())));\n}",
    "parameters": "[String activationCode]",
    "returnType": "Mono<ResponseEntity<String>>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Resends the activation code to a user's email.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user's email'}]}', name=Optional[email]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a response indicating whether the activation code was resent successfully'}]}', name=Optional.empty}]}",
    "name": "resendActivateCode",
    "body": "{\n    return activate.resendActivationCode(email).map(resended -> success(\"Activation mail successfully resented\", resended)).onErrorResume(UserServiceException.class, Response::monoError).onErrorResume(Exception.class, Response::monoError);\n}",
    "parameters": "[String email]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Resets a user's password using a reset code.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the reset code'}]}', name=Optional[resetCode]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a response entity indicating the result of the password reset'}]}', name=Optional.empty}]}",
    "name": "resetPasswordByCode",
    "body": "{\n    return resetComponent.resetPasswordByCodeAndReturnNewPassForm(resetCode).map(ResponseEntity::ok).onErrorResume(UserServiceException.class, uEx -> Mono.just(ResponseEntity.badRequest().body(convertToJsonAsString(error(uEx.getMessage(), uEx.getErrors()))))).onErrorResume(Exception.class, ex -> Mono.just(ResponseEntity.badRequest().body(convertToJsonAsString(error(ex.getMessage())))));\n}",
    "parameters": "[String resetCode]",
    "returnType": "Mono<ResponseEntity<String>>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Sets a new password for a user using a reset code.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userJson]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a response entity indicating the result of setting the new password'}]}', name=Optional.empty}]}",
    "name": "setNewPasswordByCode",
    "body": "{\n    return resetComponent.setNewPasswordByCode(userJson).map(ResponseEntity::ok).onErrorResume(UserServiceException.class, uEx -> Mono.just(ResponseEntity.badRequest().body(convertToJsonAsString(error(uEx.getMessage(), uEx.getErrors()))))).onErrorResume(Exception.class, ex -> Mono.just(ResponseEntity.badRequest().body(convertToJsonAsString(error(ex.getMessage())))));\n}",
    "parameters": "[UserJson userJson]",
    "returnType": "Mono<ResponseEntity<String>>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Reads a user's information.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userJson]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a response containing the user's information'}]}', name=Optional.empty}]}",
    "name": "readOne",
    "body": "{\n    return read.findUserByEmail(userJson).map(found -> success(\"User successfully read\", found)).onErrorResume(UserServiceException.class, Response::monoError).onErrorResume(Exception.class, Response::monoError);\n}",
    "parameters": "[UserJson userJson]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Updates a user's information.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userJson]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a response indicating the result of the update'}]}', name=Optional.empty}]}",
    "name": "updateOne",
    "body": "{\n    return update.updateUser(userJson).map(updated -> success(\"User successfully UPDATED\", updated)).onErrorResume(UserServiceException.class, Response::monoError).onErrorResume(Exception.class, Response::monoError);\n}",
    "parameters": "[UserJson userJson]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Deletes a user's information.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userJson]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a response indicating the result of the deletion'}]}', name=Optional.empty}]}",
    "name": "deleteOne",
    "body": "{\n    return delete.proceedIfApplicable(userJson).onErrorResume(UserServiceException.class, Response::monoError).onErrorResume(Exception.class, Response::monoError);\n}",
    "parameters": "[UserJson userJson]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Finds a user by username (email or ID).'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user's email or ID'}]}', name=Optional[userEmailOrId]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the user is not found'}]}', name=Optional[UsernameNotFoundException]}]}",
    "name": "findByUsername",
    "body": "{\n    try {\n        return login.validSpringUserToLogin(userEmailOrId);\n    } catch (Exception e) {\n        throw new UsernameNotFoundException(userEmailOrId);\n    }\n}",
    "parameters": "[String userEmailOrId]",
    "returnType": "Mono<UserDetails>"
  },
  {
    "javadoc": "",
    "name": "findByCode",
    "body": "",
    "parameters": "[String code]",
    "returnType": "Mono<ResetDto>"
  },
  {
    "javadoc": "",
    "name": "existsByEmail",
    "body": "",
    "parameters": "[UserJson userJson]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "",
    "name": "readOne",
    "body": "",
    "parameters": "[UserJson userJson]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "",
    "name": "updateOne",
    "body": "",
    "parameters": "[UserJson userJson]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "",
    "name": "deleteOne",
    "body": "",
    "parameters": "[UserJson userJson]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "",
    "name": "findByCode",
    "body": "",
    "parameters": "[String code]",
    "returnType": "Mono<ActivationDto>"
  },
  {
    "javadoc": "",
    "name": "findByEmail",
    "body": "",
    "parameters": "[String email]",
    "returnType": "Mono<UserDto>"
  },
  {
    "javadoc": "",
    "name": "findBy_id",
    "body": "",
    "parameters": "[String _id]",
    "returnType": "Mono<UserDto>"
  },
  {
    "javadoc": "",
    "name": "existsByEmail",
    "body": "",
    "parameters": "[String email]",
    "returnType": "Mono<Boolean>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Validates and retrieves a Spring Security user.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user email or ID'}]}', name=Optional[userEmailOrId]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono of UserDetails'}]}', name=Optional.empty}]}",
    "name": "validSpringUserToLogin",
    "body": "{\n    return Mono.just(userEmailOrId).flatMap(info -> {\n        if (Util.isValidEmail(info))\n            return findUserByEmail(info);\n        else\n            return findUserById(info);\n    });\n}",
    "parameters": "[String userEmailOrId]",
    "returnType": "Mono<UserDetails>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Finds a user by email.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user email'}]}', name=Optional[email]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono of UserDetails'}]}', name=Optional.empty}]}",
    "name": "findUserByEmail",
    "body": "{\n    return DAO.findByEmail(email).switchIfEmpty(UserServiceException.mono(\"USER NOT FOUND!\")).flatMap(this::verifyAccountStatusByEmail).map(this::newValidUserByEmail);\n}",
    "parameters": "[String email]",
    "returnType": "Mono<UserDetails>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Verifies the account status by email.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono of UserDto'}]}', name=Optional.empty}]}",
    "name": "verifyAccountStatusByEmail",
    "body": "{\n    final AccountStatus accountStatus = userDTO.getAccountStatus();\n    if (EnumSet.of(OK, OFF, REQUEST_DELETE).contains(accountStatus))\n        return Mono.just(userDTO);\n    else if (MARKED_DELETE.equals(accountStatus))\n        return deleteComponent.proceedIfApplicable(userDTO.toJson()).flatMap(response -> UserServiceException.mono(response.getMessage()));\n    else\n        return UserServiceException.mono(accountStatus.getDetails());\n}",
    "parameters": "[UserDto userDTO]",
    "returnType": "Mono<UserDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a valid UserDetails object by email.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the UserDetails object'}]}', name=Optional.empty}]}",
    "name": "newValidUserByEmail",
    "body": "{\n    Set<GrantedAuthority> authorities = listAuthorities(userDTO);\n    authorities.add(new SimpleGrantedAuthority(\"ROLE_SELF\"));\n    return new CustomUserDetails(userDTO.getEmail() + userDTO.get_id(), userDTO.getPassword(), authorities, userDTO.getEmail(), userDTO.get_id());\n}",
    "parameters": "[UserDto userDTO]",
    "returnType": "UserDetails"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Lists the authorities for a user.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a set of GrantedAuthority'}]}', name=Optional.empty}]}",
    "name": "listAuthorities",
    "body": "{\n    return Arrays.stream(userDTO.getRoleType().get().split(\",\")).map(String::trim).map(role -> new SimpleGrantedAuthority(\"ROLE_\" + role)).collect(Collectors.toSet());\n}",
    "parameters": "[UserDto userDTO]",
    "returnType": "Set<GrantedAuthority>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Finds a user by ID.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user ID'}]}', name=Optional[id]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono of UserDetails'}]}', name=Optional.empty}]}",
    "name": "findUserById",
    "body": "{\n    return DAO.findBy_id(id).switchIfEmpty(UserServiceException.mono(\"USER NOT FOUND!\")).flatMap(this::verifyAccountStatusById).map(this::newValidUserById);\n}",
    "parameters": "[String id]",
    "returnType": "Mono<UserDetails>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Verifies the account status by ID.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono of UserDto'}]}', name=Optional.empty}]}",
    "name": "verifyAccountStatusById",
    "body": "{\n    String errorMsg = \"Account Status Incorrect for this request: \" + userDTO.getAccountStatus().getDetails();\n    if (EnumSet.of(AccountStatus.OK, AccountStatus.PENDING, AccountStatus.OUTDATED).contains(userDTO.getAccountStatus())) {\n        return Mono.just(userDTO);\n    } else {\n        return UserServiceException.mono(errorMsg);\n    }\n}",
    "parameters": "[UserDto userDTO]",
    "returnType": "Mono<UserDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a valid UserDetails object by ID.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the UserDetails object'}]}', name=Optional.empty}]}",
    "name": "newValidUserById",
    "body": "{\n    Set<GrantedAuthority> authorities = listAuthorities(userDTO);\n    authorities.add(new SimpleGrantedAuthority(\"ROLE_SELF\"));\n    return new CustomUserDetails(userDTO.get_id(), userDTO.getPassword(), authorities, userDTO.getEmail(), userDTO.get_id());\n}",
    "parameters": "[UserDto userDTO]",
    "returnType": "UserDetails"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Updates user information.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details to update'}]}', name=Optional[userJson]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the updated user details as UserJson'}]}', name=Optional.empty}]}",
    "name": "updateUser",
    "body": "{\n    return DAO.findBy_id(userJson.get_id()).switchIfEmpty(UserServiceException.mono(\"User not found with this ID\", Map.of(\"_id\", userJson.get_id()))).flatMap(oldUser -> updatePlayerIfNecessary(oldUser, userJson)).flatMap(this::updateUserByDtoReturnJson);\n}",
    "parameters": "[UserJson userJson]",
    "returnType": "Mono<UserJson>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Updates user attributes if necessary.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the current user details'}]}', name=Optional[oldUser]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the new user details'}]}', name=Optional[updateInfo]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the updated user details as UserDto'}]}', name=Optional.empty}]}",
    "name": "updatePlayerIfNecessary",
    "body": "{\n    AtomicBoolean updated = new AtomicBoolean(false);\n    return Mono.just(oldUser).flatMap(user -> {\n        updateFirstName(user, updateInfo, updated);\n        updateSurnames(user, updateInfo, updated);\n        updateEmail(user, updateInfo, updated);\n        updateBirthdate(user, updateInfo, updated);\n        updatePassword(user, updateInfo, updated);\n        updateAccountStatus(user, updateInfo, updated);\n        if (!updated.get()) {\n            return UserServiceException.mono(\"No update required or data is invalid.\");\n        }\n        return Mono.just(user);\n    });\n}",
    "parameters": "[UserDto oldUser, UserJson updateInfo]",
    "returnType": "Mono<UserDto>"
  },
  {
    "javadoc": "",
    "name": "updateFirstName",
    "body": "{\n    boolean isFirstNameUpdated = updateAttribute(user::getFirstName, () -> verifyNames(updateInfo.getFirstName()), user::setFirstName);\n    updated.set(isFirstNameUpdated || updated.get());\n}",
    "parameters": "[UserDto user, UserJson updateInfo, AtomicBoolean updated]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "updateSurnames",
    "body": "{\n    boolean isSurnamesUpdated = updateAttribute(user::getSurNames, () -> verifyNames(updateInfo.getSurNames()), user::setSurNames);\n    updated.set(isSurnamesUpdated || updated.get());\n}",
    "parameters": "[UserDto user, UserJson updateInfo, AtomicBoolean updated]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "updateEmail",
    "body": "{\n    boolean isEmailUpdated = updateAttribute(user::getEmail, () -> verifyEmail(updateInfo.getEmail()), user::setEmail);\n    updated.set(isEmailUpdated || updated.get());\n}",
    "parameters": "[UserDto user, UserJson updateInfo, AtomicBoolean updated]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "updateBirthdate",
    "body": "{\n    boolean isBirthdateUpdated = updateAttribute(user::getBirthdate, () -> verifyBirthdate(updateInfo.getBirthdate()), user::setBirthdate);\n    updated.set(isBirthdateUpdated || updated.get());\n}",
    "parameters": "[UserDto user, UserJson updateInfo, AtomicBoolean updated]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "updatePassword",
    "body": "{\n    if (updateInfo.getNewPassword() != null) {\n        Optional.ofNullable(updateInfo.getPassword()).filter(pwd -> Util.encryptMatches(pwd, user.getPassword())).orElseThrow(UserServiceException::passNotMatch);\n        Optional.ofNullable(updateInfo.getNewPassword()).filter(Util::isValidPassword).ifPresent(newPwd -> {\n            user.setPassword(Util.encryptPassword(newPwd));\n            updated.set(true);\n        });\n    }\n}",
    "parameters": "[UserDto user, UserJson updateInfo, AtomicBoolean updated]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "updateAccountStatus",
    "body": "{\n    if (updateInfo.getAccountStatus() != null) {\n        boolean isCurrentStatusEligibleForUpdate = EnumSet.of(AccountStatus.OK, AccountStatus.OFF, AccountStatus.OUTDATED, AccountStatus.REQUEST_DELETE).contains(user.getAccountStatus());\n        AccountStatus toUpdate = AccountStatus.valueOf(updateInfo.getAccountStatus());\n        boolean isNewStatusValid = !AccountStatus.MARKED_DELETE.equals(toUpdate);\n        if (isCurrentStatusEligibleForUpdate && isNewStatusValid) {\n            boolean isAccountStatusUpdated = updateAttribute(user::getAccountStatus, () -> toUpdate, user::setAccountStatus);\n            updated.set(isAccountStatusUpdated || updated.get());\n        }\n    }\n}",
    "parameters": "[UserDto user, UserJson updateInfo, AtomicBoolean updated]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "updateUserByDtoReturnJson",
    "body": "{\n    return Mono.just(userToSave).flatMap(DAO::save).map(UserDto::toJson);\n}",
    "parameters": "[UserDto userToSave]",
    "returnType": "Mono<UserJson>"
  },
  {
    "javadoc": "",
    "name": "updateAttribute",
    "body": "{\n    T originalValue = original.get();\n    T updatedValue = updated.get();\n    if (updatedValue != null && !Objects.equals(originalValue, updatedValue)) {\n        setter.accept(updatedValue);\n        return true;\n    }\n    return false;\n}",
    "parameters": "[Supplier<T> original, Supplier<T> updated, Consumer<T> setter]",
    "returnType": "boolean"
  },
  {
    "javadoc": "",
    "name": "verifyNames",
    "body": "{\n    return Optional.ofNullable(nameOrSurname).map(Util::TitleCase).orElse(null);\n}",
    "parameters": "[String nameOrSurname]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "verifyEmail",
    "body": "{\n    return Optional.ofNullable(email).filter(Util::isValidEmail).orElse(null);\n}",
    "parameters": "[String email]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "verifyBirthdate",
    "body": "{\n    return Optional.ofNullable(localDate).filter(Util::isValidBirthdate).orElse(null);\n}",
    "parameters": "[LocalDate localDate]",
    "returnType": "LocalDate"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Activates a user account using the provided activation code.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the activation code'}]}', name=Optional[activationCode]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='HTML content indicating the result of the activation process'}]}', name=Optional.empty}]}",
    "name": "byActivationCodeSentByEmail",
    "body": "{\n    return Mono.just(activationCode).flatMap(activationService::findByCode).switchIfEmpty(UserServiceException.mono(\"This Code is Invalid\")).flatMap(activationDto -> {\n        if (ChronoUnit.HOURS.between(activationDto.getExpiration(), LocalDateTime.now()) > 24)\n            return UserServiceException.mono(\"This Code is Expired\");\n        else\n            return Mono.just(activationDto);\n    }).flatMap(activationDto -> DAO.findBy_id(activationDto.getId()).flatMap(userDTO -> {\n        if (userDTO.getAccountStatus() == AccountStatus.PENDING) {\n            userDTO.setAccountStatus(AccountStatus.OK);\n            return DAO.save(userDTO).then(activationService.deleteById(activationDto.getId())).thenReturn(userDTO);\n        } else {\n            return UserServiceException.mono(\"The Account Status is not correct to activate account\");\n        }\n    })).map(this::buildHtmlOkAccountActivatedContent).onErrorResume(this::buildHtmlFailAccountActivatedContent);\n}",
    "parameters": "[String activationCode]",
    "returnType": "Mono<String>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Builds HTML content for successful account activation.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the HTML content'}]}', name=Optional.empty}]}",
    "name": "buildHtmlOkAccountActivatedContent",
    "body": "{\n    return Htmls.SuccessActivation.get().replace(\"LOGO_WAC\", globalValues.getUrlWacLogoPngSmall()).replace(\"USER_NAME\", userDTO.getFirstName());\n}",
    "parameters": "[UserDto userDTO]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Builds HTML content for failed account activation.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the error occurred'}]}', name=Optional[error]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the HTML content'}]}', name=Optional.empty}]}",
    "name": "buildHtmlFailAccountActivatedContent",
    "body": "{\n    return Mono.just(Htmls.FailActivation.get().replace(\"LOGO_WAC\", globalValues.getUrlWacLogoPngSmall()).replace(\"PATH_TO_RESEND\", globalValues.getPathToResendActvationMail()).replace(\"EMAIL_WAC\", globalValues.getMailToWac()));\n}",
    "parameters": "[Throwable error]",
    "returnType": "Mono<String>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Resends the activation code to the user's email.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user's email'}]}', name=Optional[email]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional.empty}]}",
    "name": "resendActivationCode",
    "body": "{\n    return DAO.findByEmail(email).switchIfEmpty(UserServiceException.mono(\"This Email is Invalid\")).flatMap(userDTO -> activationService.findById(userDTO.get_id()).flatMap(activationDto -> {\n        if (ChronoUnit.HOURS.between(activationDto.getExpiration(), LocalDateTime.now()) <= 24) {\n            return emailService.sendActivationMail(activationDto, userDTO);\n        } else {\n            return emailService.createActivationCodeAndSendEmail(userDTO);\n        }\n    })).onErrorMap(UserServiceException::onErrorMap);\n}",
    "parameters": "[String email]",
    "returnType": "Mono<UserJson>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Resets password by code and returns a new password form.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the reset code'}]}', name=Optional[resetCode]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono of the HTML form'}]}', name=Optional.empty}]}",
    "name": "resetPasswordByCodeAndReturnNewPassForm",
    "body": "{\n    return Mono.just(resetCode).flatMap(resetService::findByCode).switchIfEmpty(UserServiceException.mono(\"This Code is Invalid\")).flatMap(resetDto -> {\n        if (ChronoUnit.HOURS.between(resetDto.getExpiration(), LocalDateTime.now()) > 1)\n            return UserServiceException.mono(\"This Code is Expired\");\n        else\n            return Mono.just(resetDto);\n    }).flatMap(resetDto -> DAO.findBy_id(resetDto.getId()).flatMap(userDTO -> resetService.createNew(userDTO).flatMap(newCode -> {\n        userDTO.setPassword(encryptPassword(newCode.getCode()));\n        userDTO.setAccountStatus(AccountStatus.OUTDATED);\n        return DAO.save(userDTO).thenReturn(newCode);\n    }))).map(this::buildHtmlFormToSendNewPassword).onErrorMap(UserServiceException::onErrorMap);\n}",
    "parameters": "[String resetCode]",
    "returnType": "Mono<String>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Builds HTML form for sending new password.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the reset details'}]}', name=Optional[resetDto]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the HTML form'}]}', name=Optional.empty}]}",
    "name": "buildHtmlFormToSendNewPassword",
    "body": "{\n    String endPoint = globalValues.getUrlSetNewPassword() + resetDto.getCode();\n    return Htmls.FormToSendNewPassword.get().replace(\"LOGO_WAC\", globalValues.getUrlWacLogoPngSmall()).replace(\"RESET_CODE\", resetDto.getCode()).replace(\"ENDPOINT_RESET_PASS\", endPoint);\n}",
    "parameters": "[ResetDto resetDto]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Sets a new password by code.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userJson]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono of the HTML response'}]}', name=Optional.empty}]}",
    "name": "setNewPasswordByCode",
    "body": "{\n    return resetService.findByCode(userJson.get_id()).switchIfEmpty(UserServiceException.mono(\"No user was found\")).flatMap(resetDto -> {\n        if (ChronoUnit.HOURS.between(resetDto.getExpiration(), LocalDateTime.now()) > 1)\n            return UserServiceException.mono(\"This Code is Expired\");\n        else\n            return DAO.findBy_id(resetDto.getId());\n    }).flatMap(userDTO -> {\n        // To not expose the ID, the ID provided is the same reset password code\n        if (Util.encryptMatches(userJson.get_id(), userDTO.getPassword()) && Util.isValidPassword(userJson.getNewPassword())) {\n            userDTO.setPassword(encryptPassword(userJson.getNewPassword()));\n            return DAO.save(userDTO);\n        } else\n            return UserServiceException.mono(\"Reset code is invalid\");\n    }).flatMap(this::buildHtmlSuccessSetNewPassword).onErrorResume(this::buildHtmlFailSetNewPassword);\n}",
    "parameters": "[UserJson userJson]",
    "returnType": "Mono<String>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Builds HTML for successful password reset.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono of the HTML response'}]}', name=Optional.empty}]}",
    "name": "buildHtmlSuccessSetNewPassword",
    "body": "{\n    return resetService.deleteById(userDTO.get_id()).then(Mono.fromCallable(() -> Htmls.SuccessSetNewPassword.get().replace(\"LOGO_WAC\", globalValues.getUrlWacLogoPngSmall()).replace(\"USER_NAME\", userDTO.getFirstName())));\n}",
    "parameters": "[UserDto userDTO]",
    "returnType": "Mono<String>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Builds HTML for failed password reset.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the error'}]}', name=Optional[throwable]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono of the HTML response'}]}', name=Optional.empty}]}",
    "name": "buildHtmlFailSetNewPassword",
    "body": "{\n    return Mono.just(Htmls.FailSetNewPassword.get().replace(\"LOGO_WAC\", globalValues.getUrlWacLogoPngSmall()).replace(\"EMAIL_WAC\", globalValues.getMailToWac()).replace(\"URL_FORGOT_PASS\", globalValues.getUrlForgotPassword()).replace(\"errorDescriptionValue\", throwable.getMessage()));\n}",
    "parameters": "[Throwable throwable]",
    "returnType": "Mono<String>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Saves a new user and sends an activation email.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details to save'}]}', name=Optional[userJustToSave]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the user details as UserJson'}]}', name=Optional.empty}]}",
    "name": "saveUser",
    "body": "{\n    return Mono.just(userJustToSave).flatMap(this::validateAttributes).flatMap(this::checkEmailNotRegistered).flatMap(this::saveUserByJtsReturnDto).flatMap(emailService::createActivationCodeAndSendEmail);\n}",
    "parameters": "[@Valid UserJustToSave userJustToSave]",
    "returnType": "Mono<UserJson>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Validates the attributes of the user.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details to validate'}]}', name=Optional[userJustToSave]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the validated user details'}]}', name=Optional.empty}]}",
    "name": "validateAttributes",
    "body": "{\n    Map<String, Object> errors = new LinkedHashMap<>();\n    if (isNullOrEmptyOrLiteralNull(userJustToSave.getEmail()))\n        errors.put(\"email\", \"E-mail is missing!\");\n    if (notValidEmail(userJustToSave.getEmail()))\n        errors.put(\"email\", \"This email has invalid format!\");\n    if (isNullOrEmptyOrLiteralNull(userJustToSave.getPassword()))\n        errors.put(\"password\", \"Password is missing!\");\n    if (notValidPassword(userJustToSave.getPassword()))\n        errors.put(\"password\", \"Password is invalid format: 8 characters \" + \"-> uppercase lowercase letters numbers and special characters !\");\n    if (isNullOrEmptyOrLiteralNull(userJustToSave.getFirstName()))\n        errors.put(\"firstName\", \"First Name is missing!\");\n    if (isNullOrEmptyOrLiteralNull(userJustToSave.getSurNames()))\n        errors.put(\"surNames\", \"Last Name is missing!\");\n    if (notValidBirthdate(userJustToSave.getBirthdate()))\n        errors.put(\"birthdate\", \"Missing or invalid format : 'YYYY-MM-DD' and more than 7 years!\");\n    if (!errors.isEmpty())\n        return UserServiceException.mono(\"Look in content for errors\", errors);\n    else\n        return Mono.just(userJustToSave);\n}",
    "parameters": "[UserJustToSave userJustToSave]",
    "returnType": "Mono<UserJustToSave>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Checks if the email is not already registered.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details to check'}]}', name=Optional[userJustToSave]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the user details if email is not registered'}]}', name=Optional.empty}]}",
    "name": "checkEmailNotRegistered",
    "body": "{\n    return DAO.existsByEmail(userJustToSave.getEmail()).flatMap(exists -> exists ? UserServiceException.mono(\"This email is already registered!\") : Mono.just(userJustToSave));\n}",
    "parameters": "[UserJustToSave userJustToSave]",
    "returnType": "Mono<UserJustToSave>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Saves the user and returns the UserDto.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details to save'}]}', name=Optional[userJustToSave]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the saved UserDto'}]}', name=Optional.empty}]}",
    "name": "saveUserByJtsReturnDto",
    "body": "{\n    return Mono.just(userJustToSave).flatMap(user -> {\n        user.setFirstName(TitleCase(user.getFirstName()));\n        user.setSurNames(TitleCase(user.getSurNames()));\n        return Mono.just(user);\n    }).map(UserJustToSave::toUserDTO).flatMap(DAO::save).doOnError(UserServiceException::doOnErrorMap);\n}",
    "parameters": "[UserJustToSave userJustToSave]",
    "returnType": "Mono<UserDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Checks and proceeds with the deletion if applicable.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userJson]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a response indicating the result of the deletion process'}]}', name=Optional.empty}]}",
    "name": "proceedIfApplicable",
    "body": "{\n    return DAO.findBy_id(userJson.get_id()).switchIfEmpty(UserServiceException.mono(\"User not found\")).flatMap(this::handleStatusChange);\n}",
    "parameters": "[UserJson userJson]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Handles the account status change during deletion.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a response indicating the result of the status change'}]}', name=Optional.empty}]}",
    "name": "handleStatusChange",
    "body": "{\n    return switch(userDTO.getAccountStatus()) {\n        case OK ->\n            handleOkStatus(userDTO);\n        case REQUEST_DELETE ->\n            handleRequestDeleteStatus(userDTO);\n        case MARKED_DELETE ->\n            handleMarkedDeleteStatus(userDTO);\n        default ->\n            UserServiceException.mono(\"Invalid account status to request deletion\");\n    };\n}",
    "parameters": "[UserDto userDTO]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Handles the OK status during deletion.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a response indicating the result of setting the REQUEST_DELETE status'}]}', name=Optional.empty}]}",
    "name": "handleOkStatus",
    "body": "{\n    userDTO.setAccountStatus(AccountStatus.REQUEST_DELETE);\n    userDTO.setRequestDeleteDate(LocalDateTime.now());\n    return DAO.save(userDTO).map(savedUserDTO -> Response.success(\"REQUEST_DELETE set, you have one year to revoke the deletion\", savedUserDTO.toJson())).onErrorResume(UserServiceException::mono);\n}",
    "parameters": "[UserDto userDTO]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Handles the REQUEST_DELETE status during deletion.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a response indicating the result of handling the REQUEST_DELETE status'}]}', name=Optional.empty}]}",
    "name": "handleRequestDeleteStatus",
    "body": "{\n    LocalDateTime requestDeleteDate = userDTO.getRequestDeleteDate();\n    if (requestDeleteDate != null && ChronoUnit.YEARS.between(requestDeleteDate, LocalDateTime.now()) >= 1) {\n        userDTO.setAccountStatus(AccountStatus.MARKED_DELETE);\n        return DAO.save(userDTO).map(savedUserDTO -> Response.success(\"MARKED_DELETE set, your account has been invalidated you have one year to request your data\", savedUserDTO.toJson())).onErrorResume(UserServiceException::mono);\n    }\n    return Mono.just(Response.success(\"REQUEST_DELETE request is not yet a year old\", userDTO.toJson()));\n}",
    "parameters": "[UserDto userDTO]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Handles the MARKED_DELETE status during deletion.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a response indicating the result of handling the MARKED_DELETE status'}]}', name=Optional.empty}]}",
    "name": "handleMarkedDeleteStatus",
    "body": "{\n    LocalDateTime requestDeleteDate = userDTO.getRequestDeleteDate();\n    if (requestDeleteDate != null && ChronoUnit.YEARS.between(requestDeleteDate, LocalDateTime.now()) >= 2) {\n        return DAO.delete(userDTO).thenReturn(Response.success(\"Your account has been terminated\", true)).onErrorResume(UserServiceException::mono);\n    }\n    String message = \"Your account is set to be deleted, but you still have time to request your data\";\n    return Mono.just(Response.success(message, userDTO.toJson()));\n}",
    "parameters": "[UserDto userDTO]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Checks if a user exists by email.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userJson]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono indicating if the user exists'}]}', name=Optional.empty}]}",
    "name": "checkIfExistsByEmail",
    "body": "{\n    return Mono.just(userJson).map(UserJson::getEmail).filter(Util::isValidEmail).flatMap(DAO::existsByEmail).switchIfEmpty(UserServiceException.mono(\"Email not found!\")).doOnError(UserServiceException::onErrorMap);\n}",
    "parameters": "[UserJson userJson]",
    "returnType": "Mono<Boolean>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Finds a user by email.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userJson]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono of the user details'}]}', name=Optional.empty}]}",
    "name": "findUserByEmail",
    "body": "{\n    return Mono.just(userJson).map(UserJson::getEmail).filter(Util::isValidEmail).flatMap(DAO::findByEmail).switchIfEmpty(UserServiceException.mono(\"This user does not exist or email is invalid!\")).map(UserDto::toJson).doOnError(UserServiceException::onErrorMap);\n}",
    "parameters": "[UserJson userJson]",
    "returnType": "Mono<UserJson>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Registers a new user.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details to save'}]}', name=Optional[userJson]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the response with the saved user details'}]}', name=Optional.empty}]}",
    "name": "registerNewUser",
    "body": "{\n    return create.saveUser(userJson).map(saved -> success(\"User successfully created\", saved)).onErrorResume(UserServiceException.class, Response::monoError).onErrorResume(Exception.class, Response::monoError);\n}",
    "parameters": "[UserJustToSave userJson]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Authenticates a user by login.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the authentication request details'}]}', name=Optional[authRequestDto]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the response entity with the authentication result'}]}', name=Optional.empty}]}",
    "name": "authenticationByLogin",
    "body": "{\n    Authentication authentication = new UsernamePasswordAuthenticationToken(authRequestDto.getUsername(), authRequestDto.getPassword());\n    return reactiveAuthenticationManager.authenticate(authentication).flatMap(auth -> Mono.just(ResponseEntity.ok(success(\"TOKEN\", jwtUtil.generateToken(authRequestDto))))).onErrorResume(e -> Mono.just(ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(error(\"Authentication failed: \" + e.getMessage()))));\n}",
    "parameters": "[@Valid AuthRequestDto authRequestDto]",
    "returnType": "Mono<ResponseEntity<Response>>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Sends an email with a reset code for password reset.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details for password reset'}]}', name=Optional[userJson]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the response entity with the result of the email sending'}]}', name=Optional.empty}]}",
    "name": "sendEmailCodeToResetPassword",
    "body": "{\n    return DAO.findByEmail(userJson.getEmail()).flatMap(userDTO -> {\n        if (userDTO.getBirthdate().equals(userJson.getBirthdate())) {\n            return emailService.createResetCodeAndSendEmail(userDTO).map(user -> ResponseEntity.ok(success(\"Email sent with reset code\", user)));\n        } else {\n            return Mono.just(ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(error(\"Incorrect information\")));\n        }\n    }).switchIfEmpty(Mono.just(ResponseEntity.ok(error(\"Unregistered email\"))));\n}",
    "parameters": "[@Valid UserJson userJson]",
    "returnType": "Mono<ResponseEntity<Response>>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new reset entry for a user.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the created reset entry'}]}', name=Optional.empty}]}",
    "name": "createNew",
    "body": "{\n    return DAO.save(ResetDto.to(userDTO));\n}",
    "parameters": "[UserDto userDTO]",
    "returnType": "Mono<ResetDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Finds a reset entry by ID.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the ID of the reset entry'}]}', name=Optional[id]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the found reset entry'}]}', name=Optional.empty}]}",
    "name": "findById",
    "body": "{\n    return DAO.findById(id);\n}",
    "parameters": "[String id]",
    "returnType": "Mono<ResetDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Finds a reset entry by code.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the reset code'}]}', name=Optional[code]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the found reset entry'}]}', name=Optional.empty}]}",
    "name": "findByCode",
    "body": "{\n    return DAO.findByCode(code);\n}",
    "parameters": "[String code]",
    "returnType": "Mono<ResetDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Deletes a reset entry by ID.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the ID of the reset entry'}]}', name=Optional[id]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono signaling completion'}]}', name=Optional.empty}]}",
    "name": "deleteById",
    "body": "{\n    return DAO.deleteById(id);\n}",
    "parameters": "[String id]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves the favorites of a user.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the favorite request containing the user ID'}]}', name=Optional[favoriteRequest]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the response with the user's favorites'}]}', name=Optional.empty}]}",
    "name": "getFavorites",
    "body": "{\n    return favoriteDao.findById(favoriteRequest.getUserId()).switchIfEmpty(createEmptyFavorite(favoriteRequest)).transform(this::ensureNonNullLists).map(favorites -> success(USER_FAVORITES_RETRIEVED, favorites)).onErrorResume(e -> handleError(\"getFavorites\", e));\n}",
    "parameters": "[FavoriteRequest favoriteRequest]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Adds a recipe to the user's favorites.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the favorite request containing the user ID and recipe ID'}]}', name=Optional[favoriteRequest]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the response with the updated favorites'}]}', name=Optional.empty}]}",
    "name": "addFavoriteRecipe",
    "body": "{\n    return favoriteDao.findById(favoriteRequest.getUserId()).switchIfEmpty(createEmptyFavorite(favoriteRequest)).transform(this::ensureNonNullLists).flatMap(favorites -> favorites.addRecipe(favoriteRequest.getRecipeId())).flatMap(favoriteDao::save).map(saved -> success(RECIPE_SUCCESSFULLY_ADDED_TO_FAVORITES, saved)).onErrorResume(e -> handleError(\"addFavoriteRecipe\", e));\n}",
    "parameters": "[FavoriteRequest favoriteRequest]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Adds an ingredient to the user's favorites.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the favorite request containing the user ID and ingredient ID'}]}', name=Optional[favoriteRequest]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the response with the updated favorites'}]}', name=Optional.empty}]}",
    "name": "addFavoriteIngredient",
    "body": "{\n    return favoriteDao.findById(favoriteRequest.getUserId()).switchIfEmpty(createEmptyFavorite(favoriteRequest)).transform(this::ensureNonNullLists).flatMap(favorites -> favorites.addIngredient(favoriteRequest.getIngredientId())).flatMap(favoriteDao::save).map(saved -> success(INGREDIENT_SUCCESSFULLY_ADDED_TO_FAVORITES, saved)).onErrorResume(e -> handleError(\"addFavoriteIngredient\", e));\n}",
    "parameters": "[FavoriteRequest favoriteRequest]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Removes a recipe from the user's favorites.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the favorite request containing the user ID and recipe ID'}]}', name=Optional[favoriteRequest]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the response with the updated favorites'}]}', name=Optional.empty}]}",
    "name": "removeFavoriteRecipe",
    "body": "{\n    return favoriteDao.findById(favoriteRequest.getUserId()).switchIfEmpty(createEmptyFavorite(favoriteRequest)).transform(this::ensureNonNullLists).flatMap(favorites -> favorites.removeRecipe(favoriteRequest.getRecipeId())).flatMap(favoriteDao::save).map(saved -> success(RECIPE_SUCCESSFULLY_REMOVED_FROM_FAVORITES, saved)).onErrorResume(e -> handleError(\"removeFavoriteRecipe\", e));\n}",
    "parameters": "[FavoriteRequest favoriteRequest]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Removes an ingredient from the user's favorites.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the favorite request containing the user ID and ingredient ID'}]}', name=Optional[favoriteRequest]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the response with the updated favorites'}]}', name=Optional.empty}]}",
    "name": "removeFavoriteIngredient",
    "body": "{\n    return favoriteDao.findById(favoriteRequest.getUserId()).switchIfEmpty(createEmptyFavorite(favoriteRequest)).transform(this::ensureNonNullLists).flatMap(favorites -> favorites.removeIngredient(favoriteRequest.getIngredientId())).flatMap(favoriteDao::save).map(saved -> success(INGREDIENT_SUCCESSFULLY_REMOVED_FROM_FAVORITES, saved)).onErrorResume(e -> handleError(\"removeFavoriteIngredient\", e));\n}",
    "parameters": "[FavoriteRequest favoriteRequest]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates an empty favorite entry for a user.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the favorite request containing the user ID'}]}', name=Optional[favoriteRequest]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the created empty favorite entry'}]}', name=Optional.empty}]}",
    "name": "createEmptyFavorite",
    "body": "{\n    return Mono.defer(() -> Mono.just(new FavoriteDto(favoriteRequest.getUserId(), new ArrayList<>(), new ArrayList<>())));\n}",
    "parameters": "[FavoriteRequest favoriteRequest]",
    "returnType": "Mono<FavoriteDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Ensures that the favorite lists are not null.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the Mono containing the favorite DTO'}]}', name=Optional[favoriteDtoMono]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the favorite DTO with non-null lists'}]}', name=Optional.empty}]}",
    "name": "ensureNonNullLists",
    "body": "{\n    return favoriteDtoMono.map(favorites -> {\n        favorites.setRecipes(Optional.ofNullable(favorites.getRecipes()).orElseGet(ArrayList::new));\n        favorites.setIngredients(Optional.ofNullable(favorites.getIngredients()).orElseGet(ArrayList::new));\n        return favorites;\n    });\n}",
    "parameters": "[Mono<FavoriteDto> favoriteDtoMono]",
    "returnType": "Mono<FavoriteDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Handles errors that occur during processing.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the name of the method where the error occurred'}]}', name=Optional[methodName]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the throwable representing the error'}]}', name=Optional[e]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the response with the error message'}]}', name=Optional.empty}]}",
    "name": "handleError",
    "body": "{\n    log.error(\"Error in {}: {}\", methodName, e.getMessage(), e);\n    return Response.monoError(e);\n}",
    "parameters": "[String methodName, Throwable e]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "",
    "name": "createNew",
    "body": "{\n    return DAO.save(ActivationDto.to(userDTO));\n}",
    "parameters": "[UserDto userDTO]",
    "returnType": "Mono<ActivationDto>"
  },
  {
    "javadoc": "",
    "name": "findById",
    "body": "{\n    return DAO.findById(id);\n}",
    "parameters": "[String id]",
    "returnType": "Mono<ActivationDto>"
  },
  {
    "javadoc": "",
    "name": "findByCode",
    "body": "{\n    return DAO.findByCode(code).doOnNext(dto -> log.info(\"ActivationDto encontrado: {}\", dto)).doOnError(e -> log.error(\"Error al buscar ActivationDto\", e));\n}",
    "parameters": "[String code]",
    "returnType": "Mono<ActivationDto>"
  },
  {
    "javadoc": "",
    "name": "deleteById",
    "body": "{\n    return DAO.deleteById(id);\n}",
    "parameters": "[String id]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates an activation code and sends an email.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details to save'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the user details without ID'}]}', name=Optional.empty}]}",
    "name": "createActivationCodeAndSendEmail",
    "body": "{\n    return activationService.createNew(userDTO).flatMap(activation -> sendActivationMail(activation, userDTO));\n}",
    "parameters": "[UserDto userDTO]",
    "returnType": "Mono<UserJson>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Sends an activation email.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the activation details'}]}', name=Optional[activationDto]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the user details without ID'}]}', name=Optional.empty}]}",
    "name": "sendActivationMail",
    "body": "{\n    return Mono.fromCallable(() -> buildMimeMessage(activationDto, userDTO)).flatMap(this::sendEmail).retry(2).thenReturn(userDTO.toJsonWithoutId()).doOnError(UserServiceException::doOnErrorMap);\n}",
    "parameters": "[ActivationDto activationDto, UserDto userDTO]",
    "returnType": "Mono<UserJson>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Builds a MimeMessage for activation.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the activation details'}]}', name=Optional[activationDto]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the built MimeMessage'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if an error occurs while building the message'}]}', name=Optional[MessagingException]}]}",
    "name": "buildMimeMessage",
    "body": "{\n    MimeMessage message = emailSender.createMimeMessage();\n    MimeMessageHelper helper = new MimeMessageHelper(message, true, \"UTF-8\");\n    helper.setFrom(springMailConfig.getSpringMailUser());\n    helper.setTo(userDTO.getEmail());\n    helper.setSubject(\"WhataCook : Activación de cuenta\");\n    String content = buildHtmlContentToActivateAccount(activationDto, userDTO);\n    helper.setText(content, true);\n    return message;\n}",
    "parameters": "[ActivationDto activationDto, UserDto userDTO]",
    "returnType": "MimeMessage"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Builds HTML content for the activation email.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the activation details'}]}', name=Optional[activationDto]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the HTML content'}]}', name=Optional.empty}]}",
    "name": "buildHtmlContentToActivateAccount",
    "body": "{\n    String activationLink = globalValues.getUrlActivationAccount() + activationDto.getCode();\n    return Htmls.ActivationEmail.get().replace(\"LOGO_WAC\", globalValues.getUrlWacLogoPngSmall()).replace(\"USER_NAME\", userDTO.getFirstName()).replace(\"ACTIVATION_LINK\", activationLink);\n}",
    "parameters": "[ActivationDto activationDto, UserDto userDTO]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Sends an email.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the MimeMessage to send'}]}', name=Optional[message]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono signaling completion'}]}', name=Optional.empty}]}",
    "name": "sendEmail",
    "body": "{\n    return Mono.fromRunnable(() -> emailSender.send(message));\n}",
    "parameters": "[MimeMessage message]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a reset code and sends an email.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details to save'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the user details without ID'}]}', name=Optional.empty}]}",
    "name": "createResetCodeAndSendEmail",
    "body": "{\n    return resetService.createNew(userDTO).flatMap(resetCode -> sendResetMail(resetCode, userDTO));\n}",
    "parameters": "[UserDto userDTO]",
    "returnType": "Mono<UserJson>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Sends a reset email.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the reset details'}]}', name=Optional[resetCode]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the user details without ID'}]}', name=Optional.empty}]}",
    "name": "sendResetMail",
    "body": "{\n    return Mono.fromCallable(() -> buildMimeMessage(resetCode, userDTO)).flatMap(this::sendEmail).retry(2).thenReturn(userDTO.toJsonWithoutId()).doOnError(UserServiceException::doOnErrorMap);\n}",
    "parameters": "[ResetDto resetCode, UserDto userDTO]",
    "returnType": "Mono<UserJson>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Builds a MimeMessage for password reset.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the reset details'}]}', name=Optional[resetCode]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the built MimeMessage'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if an error occurs while building the message'}]}', name=Optional[MessagingException]}]}",
    "name": "buildMimeMessage",
    "body": "{\n    MimeMessage message = emailSender.createMimeMessage();\n    MimeMessageHelper helper = new MimeMessageHelper(message, true, \"UTF-8\");\n    helper.setFrom(springMailConfig.getSpringMailUser());\n    helper.setTo(userDTO.getEmail());\n    helper.setSubject(\"WhataCook : reset contraseña\");\n    String content = buildHtmlContentToResetAccount(resetCode, userDTO);\n    helper.setText(content, true);\n    return message;\n}",
    "parameters": "[ResetDto resetCode, UserDto userDTO]",
    "returnType": "MimeMessage"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Builds HTML content for the reset email.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the reset details'}]}', name=Optional[resetCode]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the HTML content'}]}', name=Optional.empty}]}",
    "name": "buildHtmlContentToResetAccount",
    "body": "{\n    String activationLink = globalValues.getUrlResetPassword() + resetCode.getCode();\n    return Htmls.ResetPasswordMail.get().replace(\"LOGO_WAC\", globalValues.getUrlWacLogoPngSmall()).replace(\"USER_NAME\", userDTO.getFirstName()).replace(\"ACTIVATION_LINK\", activationLink);\n}",
    "parameters": "[ResetDto resetCode, UserDto userDTO]",
    "returnType": "String"
  }
]