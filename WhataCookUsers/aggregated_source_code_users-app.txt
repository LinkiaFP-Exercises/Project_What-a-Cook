package com.whatacook.cookers.config.jwt;

import com.whatacook.cookers.model.auth.AuthRequestDto;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.JwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.Setter;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.util.StringUtils;

import javax.crypto.SecretKey;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

/**
 * Utility class for handling JWT operations such as token creation, parsing, and validation.
 * <p>
 * Annotations:
 * - @Getter: Generates getter methods for all fields.
 * - @Setter: Generates setter methods for all fields.
 * - @ConfigurationProperties: Binds the properties prefixed with "security.jwt" to this class.
 * <p>
 * Fields:
 * - Various configuration properties for JWT handling.
 * <p>
 * Methods:
 * - getSecretKey(): Returns the secret key for signing the JWT.
 * - getUsernameFromToken(String token): Extracts the username from the JWT.
 * - getExpirationDateFromToken(String token): Extracts the expiration date from the JWT.
 * - getClaimFromToken(String token, Function<Claims, T> claimsResolver): Extracts a claim from the JWT.
 * - getAllClaimsFromToken(String token): Extracts all claims from the JWT.
 * - isExpired(String token): Checks if the JWT is expired.
 * - generateToken(AuthRequestDto authRequestDto): Generates a JWT for the given user.
 * - doGenerateToken(Map<String, Object> claims, String subject): Generates a JWT with the specified claims and subject.
 * - generateExpiredTokenForTest(Map<String, Object> claims, String subject): Generates an expired JWT for testing purposes.
 * - hasToken(String token): Checks if the token is not empty or null.
 * - extractPrefix(String token): Extracts the prefix from the token.
 * - isValidToken(String token): Validates the JWT.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
@Getter
@Setter
@ConfigurationProperties(prefix = "security.jwt")
public final class JwtUtil {

    private String authRoot;
    private String loginUrl;
    private String signInUrl;
    private String forgotPass;
    private String header;
    private String activation;
    private String resend;
    private String resetCode;
    private String codeToSet;
    private String prefix;
    private String issuer;
    private String audience;
    @Getter(AccessLevel.NONE)
    private String secret;
    private long expiration;

    public SecretKey getSecretKey() {
        return Keys.hmacShaKeyFor(this.secret.getBytes());
    }

    public String getUsernameFromToken(String token) {
        return getClaimFromToken(token, Claims::getSubject);
    }

    public Date getExpirationDateFromToken(String token) {
        return getClaimFromToken(token, Claims::getExpiration);
    }

    private <T> T getClaimFromToken(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = getAllClaimsFromToken(token);
        return claimsResolver.apply(claims);
    }

    private Claims getAllClaimsFromToken(String token) {
        return Jwts.parser().verifyWith(getSecretKey()).build()
                .parseSignedClaims(token.replace(prefix, "")).getPayload();
    }

    private Boolean isExpired(String token) {
        final Date expiration = getExpirationDateFromToken(token);
        return expiration.before(new Date());
    }

    public String generateToken(AuthRequestDto authRequestDto) {
        Map<String, Object> claims = new HashMap<>();
        return doGenerateToken(claims, authRequestDto.getUsername());
    }

    public String doGenerateToken(Map<String, Object> claims, String subject) {
        return Jwts.builder()
                .claims(claims)
                .subject(subject)
                .audience().add(audience).and()
                .issuer(issuer)
                .issuedAt(new Date(System.currentTimeMillis()))
                .expiration(new Date(System.currentTimeMillis() + expiration))
                .signWith(getSecretKey()).compact();
    }

    public String generateExpiredTokenForTest(Map<String, Object> claims, String subject) {
        long nowMillis = System.currentTimeMillis();
        Date now = new Date(nowMillis - expiration * 2);
        Date expiredDate = new Date(nowMillis - expiration);
        return Jwts.builder()
                .claims(claims)
                .subject(subject)
                .audience().add(audience).and()
                .issuer(issuer)
                .issuedAt(now)
                .expiration(expiredDate)
                .signWith(getSecretKey()).compact();
    }

    public boolean hasToken(String token) {
        return StringUtils.hasText(token);
    }

    public String extractPrefix(String token) {
        return token.substring(7);
    }

    public Boolean isValidToken(String token) {
        if (!token.startsWith(prefix)) throw new JwtException("This Token is not Bearer");
        else if (token.split("\\.").length != 3) throw new JwtException("This Token is not ours");
        else if (isExpired(token)) throw new JwtException("This Token has Expired");
        else return true;
    }
}

package com.whatacook.cookers.config.jwt;

import com.whatacook.cookers.model.exceptions.UserServiceException;
import com.whatacook.cookers.model.responses.Response;
import com.whatacook.cookers.model.users.UserJson;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.ReactiveSecurityContextHolder;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.userdetails.UserDetails;
import reactor.core.publisher.Mono;

import java.util.function.BiFunction;

/**
 * Utility class for handling authorization checks.
 * Provides methods to execute actions if the user is authorized.
 *
 * Methods:
 * - executeIfAuthorized(UserJson userJson, BiFunction<UserJson, UserDetails, Mono<Response>> action):
 *     Executes the given action if the user is authorized.
 * - getAuthentication(): Retrieves the current authentication object.
 * - isAuthorized(UserJson userJson, Authentication authentication): Checks if the user is authorized.
 * - isAdmin(Authentication authentication): Checks if the authenticated user has admin privileges.
 * - isOwnUser(UserJson userJson, UserDetails userDetails): Checks if the authenticated user is the owner.
 * - getUserDetails(Authentication authentication): Retrieves the UserDetails from the authentication object.
 *
 * @author
 * <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
public class AuthorizationUtil {

    public static Mono<Response> executeIfAuthorized(UserJson userJson,
                                                     BiFunction<UserJson, UserDetails, Mono<Response>> action) {
        return getAuthentication()
                .flatMap(authentication -> isAuthorized(userJson, authentication)
                        .flatMap(isAuthorized -> isAuthorized
                                ? action.apply(userJson, (UserDetails) authentication.getPrincipal())
                                : UserServiceException.mono("No tienes permiso para acceder a esta informaci√≥n.")));
    }

    private static Mono<Authentication> getAuthentication() {
        return ReactiveSecurityContextHolder.getContext()
                .map(SecurityContext::getAuthentication);
    }

    private static Mono<Boolean> isAuthorized(UserJson userJson, Authentication authentication) {
        return Mono.just(isAdmin(authentication) || isOwnUser(userJson, getUserDetails(authentication)));
    }

    private static boolean isAdmin(Authentication authentication) {
        return authentication.getAuthorities().stream()
                .anyMatch(grantedAuthority -> grantedAuthority.getAuthority().equals("ROLE_ADMIN"));
    }

    private static boolean isOwnUser(UserJson userJson, UserDetails userDetails) {
        String username = userDetails.getUsername();
        return (userJson.get_id() == null)
                ? username.contains(userJson.getEmail())
                : username.contains(userJson.get_id());
    }

    private static UserDetails getUserDetails(Authentication authentication) {
        return (UserDetails) authentication.getPrincipal();
    }
}

package com.whatacook.cookers.config.jwt;

import lombok.Getter;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.User;

import java.util.Collection;

/**
 * Custom user details class that extends Spring Security's User class.
 * Adds additional fields for email and ID.
 * <p>
 * Annotations:
 * - @Getter: Generates getter methods for all fields.
 * <p>
 * Fields:
 * - email: The email address of the user.
 * - id: The unique identifier of the user.
 * <p>
 * Methods:
 * - CustomUserDetails(String username, String password, Collection<? extends GrantedAuthority> authorities, String email, String id):
 * Constructor to initialize the custom user details.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
@Getter
public class CustomUserDetails extends User {

    private final String email;
    private final String id;

    public CustomUserDetails(String username, String password, Collection<? extends GrantedAuthority> authorities, String email, String id) {
        super(username, password, authorities);
        this.email = email;
        this.id = id;
    }
}

package com.whatacook.cookers.config.jwt;

import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;

/**
 * Custom security component for checking user permissions.
 * Provides a method to check if the authenticated user is either the owner or an admin.
 * <p>
 * Annotations:
 * - @Component: Indicates that this class is a Spring component.
 * <p>
 * Methods:
 * - isSelfOrAdmin(Authentication authentication, String userId, String email): Checks if the authenticated user is the owner or an admin.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
@Component("customSecurity")
public class CustomSecurity {

    public boolean isSelfOrAdmin(Authentication authentication, String userId, String email) {
        CustomUserDetails userDetails = (CustomUserDetails) authentication.getPrincipal();
        return (userDetails.getId().equals(userId)) || (userDetails.getEmail().equals(email))
                || authentication.getAuthorities().stream()
                .anyMatch(grantedAuthority -> grantedAuthority.getAuthority().equals("ROLE_ADMIN"));
    }
}

package com.whatacook.cookers.config;

import com.whatacook.cookers.config.filter.AnyRequestFilter;
import com.whatacook.cookers.config.jwt.JwtUtil;
import com.whatacook.cookers.utilities.GlobalValues;
import lombok.AllArgsConstructor;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.ReactiveAuthenticationManager;
import org.springframework.security.authentication.UserDetailsRepositoryReactiveAuthenticationManager;
import org.springframework.security.config.annotation.web.reactive.EnableWebFluxSecurity;
import org.springframework.security.config.web.server.SecurityWebFiltersOrder;
import org.springframework.security.config.web.server.ServerHttpSecurity;
import org.springframework.security.core.userdetails.ReactiveUserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.server.SecurityWebFilterChain;
import org.springframework.security.web.server.context.NoOpServerSecurityContextRepository;
import org.springframework.web.reactive.config.ResourceHandlerRegistry;
import org.springframework.web.reactive.config.WebFluxConfigurer;

/**
 * Security configuration class for setting up Spring Security with WebFlux.
 * Configures security filters, authentication manager, and password encoding.
 * <p>
 * This class implements {@code WebFluxConfigurer} to configure the resource handlers
 * for serving static resources.
 * <p>
 * Annotations:
 * - {@code @AllArgsConstructor}: Generates an all-arguments constructor.
 * - {@code @Configuration}: Indicates that this class contains Spring configuration.
 * - {@code @EnableWebFluxSecurity}: Enables WebFlux security for the application.
 * - {@code @EnableConfigurationProperties}: Enables configuration properties for specified classes.
 * <p>
 * Fields:
 * - {@code jwtUtil}: Utility class for handling JWT operations.
 * - {@code globalValues}: Class containing global values and configurations.
 * <p>
 * Methods:
 * - {@code filterChain(ServerHttpSecurity httpSecurity, AnyRequestFilter anyRequestFilter, ReactiveAuthenticationManager reactiveAuthenticationManager)}:
 * Configures the security filter chain.
 * - {@code passwordEncoder()}: Provides a PasswordEncoder bean for encoding passwords.
 * - {@code reactiveAuthenticationManager(ReactiveUserDetailsService userDetailsService, PasswordEncoder passwordEncoder)}:
 * Configures the ReactiveAuthenticationManager.
 * - {@code addResourceHandlers(ResourceHandlerRegistry registry)}: Configures the resource handlers for serving static resources.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
@AllArgsConstructor
@Configuration
@EnableWebFluxSecurity
@EnableConfigurationProperties({JwtUtil.class, GlobalValues.class})
public class SecurityConfig implements WebFluxConfigurer {

    private final JwtUtil jwtUtil;
    private final GlobalValues globalValues;

    /**
     * Configures the security filter chain.
     *
     * @param httpSecurity                  The ServerHttpSecurity instance.
     * @param anyRequestFilter              The custom request filter.
     * @param reactiveAuthenticationManager The reactive authentication manager.
     * @return The configured SecurityWebFilterChain.
     */
    @Bean
    public SecurityWebFilterChain filterChain(ServerHttpSecurity httpSecurity, AnyRequestFilter anyRequestFilter,
                                              ReactiveAuthenticationManager reactiveAuthenticationManager) {

        return httpSecurity.csrf(ServerHttpSecurity.CsrfSpec::disable)
                .httpBasic(ServerHttpSecurity.HttpBasicSpec::disable)
                .formLogin(ServerHttpSecurity.FormLoginSpec::disable)
                .authenticationManager(reactiveAuthenticationManager)
                .securityContextRepository(NoOpServerSecurityContextRepository.getInstance())
                .authorizeExchange(authorizeExchangeSpec ->
                        authorizeExchangeSpec
                                .pathMatchers(globalValues.getPathToCheckIfEmailAlreadyExists()).permitAll()
                                .pathMatchers(globalValues.getPathToJavaDoc()).permitAll()
                                .pathMatchers(globalValues.getPathToDirectoryJavadoc()).permitAll()
                                .pathMatchers(jwtUtil.getLoginUrl()).permitAll()
                                .pathMatchers(jwtUtil.getSignInUrl()).permitAll()
                                .pathMatchers(jwtUtil.getForgotPass()).permitAll()
                                .anyExchange().authenticated()
                ).addFilterAt(anyRequestFilter, SecurityWebFiltersOrder.AUTHENTICATION)
                .build();
    }

    /**
     * Provides a PasswordEncoder bean for encoding passwords.
     *
     * @return The BCryptPasswordEncoder instance.
     */
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    /**
     * Configures the ReactiveAuthenticationManager.
     *
     * @param userDetailsService The ReactiveUserDetailsService instance.
     * @param passwordEncoder    The PasswordEncoder instance.
     * @return The configured ReactiveAuthenticationManager.
     */
    @Bean
    public ReactiveAuthenticationManager reactiveAuthenticationManager(ReactiveUserDetailsService userDetailsService,
                                                                       PasswordEncoder passwordEncoder) {
        var authenticationManager = new UserDetailsRepositoryReactiveAuthenticationManager(userDetailsService);
        authenticationManager.setPasswordEncoder(passwordEncoder);
        return authenticationManager;
    }

    /**
     * Configures the resource handlers for the application.
     * <p>
     * This method overrides the {@code addResourceHandlers} method from the
     * {@code WebFluxConfigurer} interface to add a specific resource handler.
     * The resource handler configures the path to serve static files
     * from the file system directory {@code /app/javadoc} via the path
     * {@code /api/javadoc/**}.
     * </p>
     *
     * @param registry the resource handler registry to be used to add the handlers.
     */
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/api/javadoc/**")
                .addResourceLocations("file:/app/javadoc/");
    }
}

package com.whatacook.cookers.config;

import jakarta.annotation.PostConstruct;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Configuration;
import org.springframework.util.StringUtils;

import java.io.IOException;

/**
 * Configuration class for setting up MongoDB connection.
 * Reads the MongoDB URI from Docker secrets and sets the system property.
 * <p>
 * Annotations:
 * - @Slf4j: Lombok annotation to generate a logger field.
 * - @Configuration: Indicates that this class contains Spring configuration.
 * <p>
 * Methods:
 * - init(): Initializes the MongoDB URI by reading Docker secrets.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
@Slf4j
@Configuration
public class MongoConfig {

    /**
     * Initializes the MongoDB URI by reading Docker secrets.
     * Sets the system property for the MongoDB URI.
     */
    @PostConstruct
    public void init() {
        try {
            String URI = "MONGO_URI_WHATACOOK_USERS";

            String mongoUri = DockerConfig.readSecret(URI);

            if (StringUtils.hasText(mongoUri))
                System.setProperty(URI, mongoUri.trim());

            log.warn("Mongo URI : {}", StringUtils.hasText(mongoUri));

        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}

package com.whatacook.cookers.config.parser;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.github.javaparser.JavaParser;
import com.github.javaparser.ParserConfiguration;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.visitor.VoidVisitorAdapter;
import jakarta.annotation.PostConstruct;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.log4j.Log4j2;
import org.springframework.context.annotation.Conditional;
import org.springframework.stereotype.Component;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.stream.Stream;

/**
 * Component that analyzes Java source files in a specific directory and extracts method information.
 * The extracted information is saved to a JSON file.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
@Log4j2
@Component
@Conditional(LocalEnvironmentCondition.class)
public class JavaParserAnalyzer {

    private static final String OUTPUT_DIR = "src/main/java/com/whatacook/cookers";
    private static final String OUTPUT_FILE = OUTPUT_DIR + "/extracted_code_data_from_cookers-app.json";

    /**
     * PostConstruct method that initiates the analysis process.
     * It creates the output directory and file, then extracts method data from the Java source files.
     */
    @PostConstruct
    public void analyze() {
        File projectDir = new File(OUTPUT_DIR);

        if (!projectDir.exists() || !projectDir.isDirectory()) {
            log.error("El directorio especificado no existe: {}", OUTPUT_DIR);
            return;
        }

        Map<String, PackageInfo> packageMap = new HashMap<>();
        try {
            // Crear el directorio de salida si no existe
            Files.createDirectories(Paths.get(OUTPUT_DIR));

            // Borrar el contenido existente del archivo
            final Path pathTo_OUTPUT_FILE = Paths.get(OUTPUT_FILE);
            Files.deleteIfExists(pathTo_OUTPUT_FILE);

            extractData(projectDir, packageMap);

            // Guardar los datos extra√≠dos en un archivo JSON
            String jsonString = toJsonString(packageMap);
            Files.write(pathTo_OUTPUT_FILE, jsonString.getBytes());
        } catch (IOException e) {
            log.error("Error while analyzing Java parser: {}", e.getMessage(), e);
        }
    }

    /**
     * Escapes special characters in a JSON string.
     *
     * @param input the input string
     * @return the escaped string
     */
    private static String escapeJson(String input) {
        if (input == null) {
            return "";
        }
        return input.replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\n", "\\n")
                .replace("\r", "\\r")
                .replace("\t", "\\t");
    }

    /**
     * Converts a map of packages to a JSON string.
     *
     * @param packageMap the map of packages
     * @return the JSON string
     */
    private String toJsonString(Map<String, PackageInfo> packageMap) {
        ObjectMapper mapper = new ObjectMapper();
        try {
            return mapper.writeValueAsString(packageMap);
        } catch (IOException e) {
            log.error("Error converting to JSON string: {}", e.getMessage(), e);
            return "{}";
        }
    }

    /**
     * Extracts method information from Java source files in the specified directory.
     *
     * @param projectDir the project directory
     * @param packageMap the map to store extracted method information organized by package
     * @throws IOException if an I/O error occurs
     */
    private void extractData(File projectDir, Map<String, PackageInfo> packageMap) throws IOException {
        ParserConfiguration parserConfiguration = new ParserConfiguration()
                .setAttributeComments(false);
        JavaParser javaParser = new JavaParser(parserConfiguration);
        try (Stream<java.nio.file.Path> paths = Files.walk(projectDir.toPath())) {
            paths.filter(Files::isRegularFile)
                    .filter(path -> path.toString().endsWith(".java"))
                    .forEach(path -> {
                        try {
                            CompilationUnit cu = javaParser.parse(path).getResult().orElseThrow(IOException::new);
                            cu.accept(new PackageVisitor(), packageMap);
                        } catch (IOException e) {
                            log.error("Error while extractData() in JavaParserAnalyzer: {}", e.getMessage(), e);
                        }
                    });
        }
    }

    /**
     * Visitor class to extract package and class information.
     */
    private static class PackageVisitor extends VoidVisitorAdapter<Map<String, PackageInfo>> {
        @Override
        public void visit(CompilationUnit cu, Map<String, PackageInfo> collector) {
            super.visit(cu, collector);
            String packageName = cu.getPackageDeclaration()
                    .map(pd -> pd.getName().toString())
                    .orElse("default");

            PackageInfo packageInfo = collector.computeIfAbsent(packageName, PackageInfo::new);

            cu.findAll(ClassOrInterfaceDeclaration.class).forEach(c -> {
                ClassInfo classInfo = new ClassInfo();
                classInfo.setName(c.getNameAsString());
                c.getMethods().forEach(m -> {
                    MethodInfo methodInfo = new MethodInfo();
                    methodInfo.setName(m.getNameAsString());
                    methodInfo.setReturnType(m.getTypeAsString());
                    methodInfo.setParameters(m.getParameters().toString());
                    methodInfo.setJavadoc(m.getJavadoc().map(javadoc -> escapeJson(javadoc.toString())).orElse(""));
                    methodInfo.setBody(m.getBody().map(body -> escapeJson(body.toString())).orElse(""));
                    classInfo.getMethods().add(methodInfo);
                });
                packageInfo.getClasses().add(classInfo);
            });
        }
    }

    /**
     * Class representing package information.
     */
    @Getter
    @Setter
    private static class PackageInfo implements Serializable {
        @Serial
        private static final long serialVersionUID = 421L;
        private String name;
        private List<ClassInfo> classes = new ArrayList<>();

        public PackageInfo(String name) {
            this.name = name;
        }
    }

    /**
     * Class representing class information.
     */
    @Getter
    @Setter
    private static class ClassInfo implements Serializable {
        @Serial
        private static final long serialVersionUID = 422L;
        private String name;
        private List<MethodInfo> methods = new ArrayList<>();
    }

    /**
     * Class representing method information.
     */
    @Getter
    @Setter
    private static class MethodInfo implements Serializable {
        @Serial
        private static final long serialVersionUID = 423L;
        private String name;
        private String returnType;
        private String parameters;
        private String javadoc;
        private String body;
    }
}

package com.whatacook.cookers.config.parser;

import lombok.extern.log4j.Log4j2;
import org.springframework.context.annotation.Conditional;
import org.springframework.stereotype.Component;

import jakarta.annotation.PostConstruct;
import java.io.*;
import java.nio.file.*;
import java.util.stream.Stream;

/**
 * A component that aggregates all Java source files from a specified directory into a single text file.
 * This component is only active if the environment variable WHATA_COOK_ENV is set to "local".
 * The aggregated source code is written to "aggregated_source_code.txt".
 */
@Log4j2
@Component
@Conditional(LocalEnvironmentCondition.class)
public class JavaSourceAggregator {

    private static final String SOURCE_DIR = "src/main/java/com/whatacook/cookers";
    private static final String OUTPUT_FILE = "aggregated_source_code_users-app.txt";

    /**
     * Aggregates all Java source files in the specified directory into a single text file.
     * This method is called automatically after the bean has been constructed.
     */
    @PostConstruct
    public void aggregateSourceCode() {
        File sourceDir = new File(SOURCE_DIR);

        if (!sourceDir.exists() || !sourceDir.isDirectory()) {
            log.error("El directorio especificado no existe: {}", SOURCE_DIR);
            return;
        }

        try {
            // Borrar el contenido existente del archivo
            final Path pathToOutputFile = Paths.get(OUTPUT_FILE);
            Files.deleteIfExists(pathToOutputFile);

            // Crear el archivo de salida
            try (BufferedWriter writer = Files.newBufferedWriter(pathToOutputFile, StandardOpenOption.CREATE)) {
                aggregateSourceFiles(sourceDir, writer);
            }
        } catch (IOException e) {
            log.error("Error while aggregating source code: {}", e.getMessage(), e);
        }
    }

    /**
     * Recursively aggregates all Java source files in the specified directory.
     *
     * @param directory the directory containing Java source files to aggregate
     * @param writer    the writer to which the aggregated source code is written
     * @throws IOException if an I/O error occurs
     */
    private void aggregateSourceFiles(File directory, BufferedWriter writer) throws IOException {
        try (Stream<Path> paths = Files.walk(directory.toPath())) {
            paths.filter(Files::isRegularFile)
                    .filter(path -> path.toString().endsWith(".java"))
                    .forEach(path -> {
                        try (Stream<String> lines = Files.lines(path)) {
                            lines.forEach(line -> {
                                try {
                                    writer.write(line);
                                    writer.newLine();
                                } catch (IOException e) {
                                    log.error("Error writing line to output file: {}", e.getMessage(), e);
                                }
                            });
                            writer.write(System.lineSeparator());
                        } catch (IOException e) {
                            log.error("Error reading file {}: {}", path, e.getMessage(), e);
                        }
                    });
        }
    }
}

package com.whatacook.cookers.config.parser;

import org.springframework.context.annotation.Condition;
import org.springframework.context.annotation.ConditionContext;
import org.springframework.core.type.AnnotatedTypeMetadata;

/**
 * Condition class to check if the environment is local.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
public class LocalEnvironmentCondition implements Condition {
    /**
     * Condition function to check if the environment is local.
     */
    @SuppressWarnings("NullableProblems")
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        String environment = System.getenv("WHATA_COOK_ENV");
        return "local".equals(environment);
    }
}

package com.whatacook.cookers.config;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

/**
 * Utility class for reading Docker secrets from a specified path.
 * <p>
 * Methods:
 * - readSecret(String secret): Reads the secret value from the specified path or environment variable.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
public class DockerConfig {

    private static final String rootPath = "/run/secrets/";

    /**
     * Reads the secret value from the specified path or environment variable.
     *
     * @param secret The name of the secret.
     * @return The secret value as a string.
     * @throws IOException If an I/O error occurs.
     */
    public static String readSecret(String secret) throws IOException {
        try {
            return new String(Files.readAllBytes(Paths.get(rootPath + secret))).trim();
        } catch (IOException e) {
            return System.getenv(secret);
        }
    }
}

package com.whatacook.cookers.config.filter;

import org.springframework.web.server.ServerWebExchange;
import org.springframework.web.server.WebFilterChain;
import reactor.core.publisher.Mono;

/**
 * Interface for handling token authentication flow.
 * Defines a method to handle the authentication process based on a request token.
 * <p>
 * Methods:
 * - handle(String requestToken, ServerWebExchange exchange, WebFilterChain chain):
 * Handles the authentication process using the provided request token, exchange, and filter chain.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
public interface TokenAuthenticationFlowHandler {
    Mono<Void> handle(String requestToken, ServerWebExchange exchange, WebFilterChain chain);
}

package com.whatacook.cookers.config.filter;

import org.springframework.web.server.ServerWebExchange;
import org.springframework.web.server.WebFilterChain;
import reactor.core.publisher.Mono;

/**
 * Interface for managing authentication.
 * Defines a method to set the authentication status based on user email or ID and token.
 * <p>
 * Methods:
 * - setAuthenticated(String userEmailOrId, String token, ServerWebExchange exchange, WebFilterChain chain):
 * Sets the authentication status using the provided user email or ID, token, exchange, and filter chain.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
public interface AuthenticationManager {
    Mono<Void> setAuthenticated(String userEmailOrId, String token, ServerWebExchange exchange, WebFilterChain chain);
}

package com.whatacook.cookers.config.filter;

import org.springframework.web.server.ServerWebExchange;
import org.springframework.web.server.WebFilterChain;
import reactor.core.publisher.Mono;

/**
 * Interface for handling the flow of resending an email.
 * Defines a method to handle the process based on a provided email to resend.
 * <p>
 * Methods:
 * - handle(String emailToResend, ServerWebExchange exchange, WebFilterChain chain):
 * Handles the process of resending an email using the provided email to resend, exchange, and filter chain.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
public interface EmailResendFlowHandler {
    Mono<Void> handle(String emailToResend, ServerWebExchange exchange, WebFilterChain chain);
}

package com.whatacook.cookers.config.filter;

import org.springframework.web.server.ServerWebExchange;
import org.springframework.web.server.WebFilterChain;
import reactor.core.publisher.Mono;

/**
 * Interface for handling the flow of resetting an email password.
 * Defines a method to handle the process based on a provided reset code.
 * <p>
 * Methods:
 * - handle(String resetCode, ServerWebExchange exchange, WebFilterChain chain):
 * Handles the process of resetting an email password using the provided reset code, exchange, and filter chain.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
public interface EmailResetPasswordFlowHandler {
    Mono<Void> handle(String resetCode, ServerWebExchange exchange, WebFilterChain chain);
}

package com.whatacook.cookers.config.filter;

import org.springframework.web.server.ServerWebExchange;
import org.springframework.web.server.WebFilterChain;
import reactor.core.publisher.Mono;

/**
 * Interface for handling the flow of setting a new password.
 * Defines a method to handle the process based on a provided code.
 * <p>
 * Methods:
 * - handle(String codeToSet, ServerWebExchange exchange, WebFilterChain chain):
 * Handles the process of setting a new password using the provided code, exchange, and filter chain.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
public interface SetNewPasswordFlowHandler {
    Mono<Void> handle(String codeToSet, ServerWebExchange exchange, WebFilterChain chain);
}

package com.whatacook.cookers.config.filter;

import org.springframework.web.server.ServerWebExchange;
import org.springframework.web.server.WebFilterChain;
import reactor.core.publisher.Mono;

/**
 * Interface for handling the flow of activating an account using an activation code.
 * Defines a method to handle the process based on a provided activation code.
 * <p>
 * Methods:
 * - handle(String activationCode, ServerWebExchange exchange, WebFilterChain chain):
 * Handles the activation process using the provided activation code, exchange, and filter chain.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
public interface ActivationCodeFlowHandler {
    Mono<Void> handle(String activationCode, ServerWebExchange exchange, WebFilterChain chain);
}

package com.whatacook.cookers.config.filter.implement;

import com.whatacook.cookers.config.filter.AuthenticationManager;
import com.whatacook.cookers.config.filter.EmailResendFlowHandler;
import com.whatacook.cookers.service.ActivationService;
import com.whatacook.cookers.service.contracts.UserDao;
import com.whatacook.cookers.utilities.Util;
import lombok.AllArgsConstructor;
import org.springframework.core.io.buffer.DataBuffer;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import org.springframework.web.server.WebFilterChain;
import reactor.core.publisher.Mono;

import java.util.Objects;

import static com.whatacook.cookers.model.responses.Response.error;
import static com.whatacook.cookers.utilities.Util.convertToJsonAsBytes;

/**
 * Implementation of EmailResendFlowHandler.
 * Handles the email resend flow by verifying the email and authenticating the user.
 * <p>
 * Annotations:
 * - @Component: Indicates that this class is a Spring component.
 * - @AllArgsConstructor: Generates a constructor with one parameter for each field.
 * <p>
 * Fields:
 * - DAO: Data access object for user-related operations.
 * - activationService: Service for handling activation logic.
 * - authenticationManager: Manager for handling authentication.
 * <p>
 * Methods:
 * - handle(String emailToResend, ServerWebExchange exchange, WebFilterChain chain): Handles the email resend flow.
 * - respondWithJson(ServerWebExchange exchange, Object response): Sends a JSON response.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
@AllArgsConstructor
@Component
public class EmailResendFlowHandlerImpl implements EmailResendFlowHandler {

    private final UserDao DAO;
    private final ActivationService activationService;
    private final AuthenticationManager authenticationManager;

    @SuppressWarnings("ReactorTransformationOnMonoVoid")
    @Override
    public Mono<Void> handle(String emailToResend, ServerWebExchange exchange, WebFilterChain chain) {
        return Mono.just(Objects.requireNonNull(emailToResend)).filter(Util::isValidEmail).flatMap(DAO::findByEmail)
                .flatMap(userDTO -> activationService.findById(userDTO.get_id()))
                .flatMap(activationDto -> authenticationManager.setAuthenticated(activationDto.getId(), null, exchange, chain))
                .switchIfEmpty(Mono.defer(() -> respondWithJson(exchange, error("Email not found."))));
    }

    private Mono<Void> respondWithJson(ServerWebExchange exchange, Object response) {
        if (!exchange.getResponse().isCommitted()) {
            exchange.getResponse().setStatusCode(HttpStatus.OK);
            exchange.getResponse().getHeaders().setContentType(MediaType.APPLICATION_JSON);
            byte[] jsonBytes = convertToJsonAsBytes(response);
            DataBuffer dataBuffer = exchange.getResponse().bufferFactory().wrap(jsonBytes);
            return exchange.getResponse().writeWith(Mono.just(dataBuffer));
        } else {
            return Mono.empty();
        }
    }
}

package com.whatacook.cookers.config.filter.implement;

import com.whatacook.cookers.config.filter.ResponseErrorHtml;
import org.springframework.core.io.buffer.DataBuffer;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

import java.nio.charset.StandardCharsets;

/**
 * Implementation of ResponseErrorHtml.
 * Sends error responses in HTML format.
 * <p>
 * Annotations:
 * - @Component: Indicates that this class is a Spring component.
 * <p>
 * Methods:
 * - send(ServerWebExchange exchange, String htmlContent): Sends an HTML error response.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
@Component
public class ResponseErrorHtmlImpl implements ResponseErrorHtml {
    @Override
    public Mono<Void> send(ServerWebExchange exchange, String htmlContent) {
        if (!exchange.getResponse().isCommitted()) {
            exchange.getResponse().setStatusCode(HttpStatus.BAD_REQUEST);
            exchange.getResponse().getHeaders().setContentType(MediaType.TEXT_HTML);
            DataBuffer dataBuffer = exchange.getResponse().bufferFactory().wrap(htmlContent.getBytes(StandardCharsets.UTF_8));
            return exchange.getResponse().writeWith(Mono.just(dataBuffer));
        } else {
            return Mono.empty();
        }
    }
}

package com.whatacook.cookers.config.filter.implement;

import com.whatacook.cookers.config.filter.AuthenticationManager;
import com.whatacook.cookers.service.UserService;
import lombok.AllArgsConstructor;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.ReactiveSecurityContextHolder;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import org.springframework.web.server.WebFilterChain;
import reactor.core.publisher.Mono;

/**
 * Implementation of AuthenticationManager.
 * Handles user authentication by setting the authentication context.
 * <p>
 * Annotations:
 * - @Component: Indicates that this class is a Spring component.
 * - @AllArgsConstructor: Generates a constructor with one parameter for each field.
 * <p>
 * Fields:
 * - userService: Service for handling user-related logic.
 * <p>
 * Methods:
 * - setAuthenticated(String userEmailOrId, String token, ServerWebExchange exchange, WebFilterChain chain): Sets the authentication context for the user.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
@AllArgsConstructor
@Component
public class AuthenticationManagerImpl implements AuthenticationManager {

    private final UserService userService;

    @Override
    public Mono<Void> setAuthenticated(String userEmailOrId, String token, ServerWebExchange exchange, WebFilterChain chain) {
        return userService.findByUsername(userEmailOrId)
                .map(user -> new UsernamePasswordAuthenticationToken(user, token, user.getAuthorities()))
                .cast(Authentication.class)
                .flatMap(authentication -> chain.filter(exchange)
                        .contextWrite(ReactiveSecurityContextHolder.withAuthentication(authentication)))
                .then();
    }
}

package com.whatacook.cookers.config.filter.implement;

import com.whatacook.cookers.config.filter.ActivationCodeFlowHandler;
import com.whatacook.cookers.config.filter.AuthenticationManager;
import com.whatacook.cookers.config.filter.ResponseErrorHtml;
import com.whatacook.cookers.model.constants.Htmls;
import com.whatacook.cookers.service.ActivationService;
import com.whatacook.cookers.utilities.GlobalValues;
import lombok.AllArgsConstructor;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import org.springframework.web.server.WebFilterChain;
import reactor.core.publisher.Mono;

/**
 * Implementation of ActivationCodeFlowHandler.
 * Handles the activation code flow by verifying the activation code and authenticating the user.
 * <p>
 * Annotations:
 * - @Component: Indicates that this class is a Spring component.
 * - @AllArgsConstructor: Generates a constructor with one parameter for each field.
 * <p>
 * Fields:
 * - activationService: Service for handling activation logic.
 * - globalValues: Utility class for accessing global values.
 * - authenticationManager: Manager for handling authentication.
 * - responseErrorHtml: Service for sending error responses in HTML format.
 * <p>
 * Methods:
 * - handle(String activationCode, ServerWebExchange exchange, WebFilterChain chain): Handles the activation code flow.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
@AllArgsConstructor
@Component
public class ActivationCodeFlowHandlerImpl implements ActivationCodeFlowHandler {

    private final ActivationService activationService;
    private final GlobalValues globalValues;
    private final AuthenticationManager authenticationManager;
    private final ResponseErrorHtml responseErrorHtml;

    @SuppressWarnings("ReactorTransformationOnMonoVoid")
    @Override
    public Mono<Void> handle(String activationCode, ServerWebExchange exchange, WebFilterChain chain) {
        String FAIL_HTML_FOR_ACTIVATION = Htmls.FailActivation.get()
                .replace("LOGO_WAC", globalValues.getUrlWacLogoPngSmall())
                .replace("PATH_TO_RESEND", globalValues.getPathToResendActvationMail())
                .replace("EMAIL_WAC", globalValues.getMailToWac());
        return activationService.findByCode(activationCode)
                .flatMap(activationDto -> authenticationManager.setAuthenticated(activationDto.getId(), null, exchange, chain))
                .switchIfEmpty(Mono.defer(() -> responseErrorHtml.send(exchange, FAIL_HTML_FOR_ACTIVATION)));
    }
}

package com.whatacook.cookers.config.filter.implement;

import com.whatacook.cookers.config.filter.AuthenticationManager;
import com.whatacook.cookers.config.filter.EmailResetPasswordFlowHandler;
import com.whatacook.cookers.config.filter.ResponseErrorHtml;
import com.whatacook.cookers.model.constants.Htmls;
import com.whatacook.cookers.service.ResetService;
import com.whatacook.cookers.utilities.GlobalValues;
import lombok.AllArgsConstructor;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import org.springframework.web.server.WebFilterChain;
import reactor.core.publisher.Mono;

/**
 * Implementation of EmailResetPasswordFlowHandler.
 * Handles the email reset password flow by verifying the reset code and authenticating the user.
 * <p>
 * Annotations:
 * - @Component: Indicates that this class is a Spring component.
 * - @AllArgsConstructor: Generates a constructor with one parameter for each field.
 * <p>
 * Fields:
 * - resetService: Service for handling reset logic.
 * - globalValues: Utility class for accessing global values.
 * - authenticationManager: Manager for handling authentication.
 * - responseErrorHtml: Service for sending error responses in HTML format.
 * <p>
 * Methods:
 * - handle(String resetCode, ServerWebExchange exchange, WebFilterChain chain): Handles the email reset password flow.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
@AllArgsConstructor
@Component
public class EmailResetPasswordFlowHandlerImpl implements EmailResetPasswordFlowHandler {

    private final ResetService resetService;
    private final GlobalValues globalValues;
    private final AuthenticationManager authenticationManager;
    private final ResponseErrorHtml responseErrorHtml;

    @SuppressWarnings("ReactorTransformationOnMonoVoid")
    @Override
    public Mono<Void> handle(String resetCode, ServerWebExchange exchange, WebFilterChain chain) {
        String FAIL_HTML_FOR_RESET = Htmls.FailReset.get()
                .replace("LOGO_WAC", globalValues.getUrlWacLogoPngSmall())
                .replace("EMAIL_WAC", globalValues.getMailToWac());
        return resetService.findByCode(resetCode)
                .flatMap(resetDto -> authenticationManager.setAuthenticated(resetDto.getId(), null, exchange, chain))
                .switchIfEmpty(Mono.defer(() -> responseErrorHtml.send(exchange,
                        FAIL_HTML_FOR_RESET.replace("errorDescriptionValue", "Code Not Found"))))
                .onErrorResume(throwable -> Mono.defer(() -> responseErrorHtml.send(exchange,
                        FAIL_HTML_FOR_RESET.replace("errorDescriptionValue", throwable.getMessage()))));
    }
}

package com.whatacook.cookers.config.filter.implement;

import com.whatacook.cookers.config.filter.AuthenticationManager;
import com.whatacook.cookers.config.filter.ResponseErrorHtml;
import com.whatacook.cookers.config.filter.SetNewPasswordFlowHandler;
import com.whatacook.cookers.model.constants.Htmls;
import com.whatacook.cookers.service.ResetService;
import com.whatacook.cookers.utilities.GlobalValues;
import lombok.AllArgsConstructor;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import org.springframework.web.server.WebFilterChain;
import reactor.core.publisher.Mono;

/**
 * Implementation of SetNewPasswordFlowHandler.
 * Handles the set new password flow by verifying the reset code and authenticating the user.
 * <p>
 * Annotations:
 * - @Component: Indicates that this class is a Spring component.
 * - @AllArgsConstructor: Generates a constructor with one parameter for each field.
 * <p>
 * Fields:
 * - resetService: Service for handling reset logic.
 * - globalValues: Utility class for accessing global values.
 * - authenticationManager: Manager for handling authentication.
 * - responseErrorHtml: Service for sending error responses in HTML format.
 * <p>
 * Methods:
 * - handle(String codeToSet, ServerWebExchange exchange, WebFilterChain chain): Handles the set new password flow.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
@AllArgsConstructor
@Component
public class SetNewPasswordFlowHandlerImpl implements SetNewPasswordFlowHandler {

    private final ResetService resetService;
    private final GlobalValues globalValues;
    private final AuthenticationManager authenticationManager;
    private final ResponseErrorHtml responseErrorHtml;

    @SuppressWarnings("ReactorTransformationOnMonoVoid")
    @Override
    public Mono<Void> handle(String codeToSet, ServerWebExchange exchange, WebFilterChain chain) {
        String FAIL_HTML_FOR_RESET = Htmls.FailSetNewPassword.get()
                .replace("LOGO_WAC", globalValues.getUrlWacLogoPngSmall())
                .replace("URL_FORGOT_PASS", globalValues.getUrlForgotPassword())
                .replace("EMAIL_WAC", globalValues.getMailToWac());
        return resetService.findByCode(codeToSet)
                .flatMap(resetDto -> authenticationManager.setAuthenticated(resetDto.getId(), null, exchange, chain))
                .switchIfEmpty(Mono.defer(() -> responseErrorHtml.send(exchange,
                        FAIL_HTML_FOR_RESET.replace("errorDescriptionValue", "Code Not Found"))))
                .onErrorResume(throwable -> Mono.defer(() -> responseErrorHtml.send(exchange,
                        FAIL_HTML_FOR_RESET.replace("errorDescriptionValue", throwable.getMessage()))));
    }
}

package com.whatacook.cookers.config.filter.implement;

import com.whatacook.cookers.config.filter.AuthenticationManager;
import com.whatacook.cookers.config.filter.TokenAuthenticationFlowHandler;
import com.whatacook.cookers.config.jwt.JwtUtil;
import com.whatacook.cookers.model.responses.Response;
import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.JwtException;
import lombok.AllArgsConstructor;
import org.springframework.core.io.buffer.DataBuffer;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.server.reactive.ServerHttpResponse;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import org.springframework.web.server.WebFilterChain;
import reactor.core.publisher.Mono;

import static com.whatacook.cookers.model.responses.Response.error;
import static com.whatacook.cookers.utilities.Util.convertToJsonAsBytes;

/**
 * Implementation of TokenAuthenticationFlowHandler.
 * Handles the token authentication flow by verifying the JWT token and authenticating the user.
 * <p>
 * Annotations:
 * - @Component: Indicates that this class is a Spring component.
 * - @AllArgsConstructor: Generates a constructor with one parameter for each field.
 * <p>
 * Fields:
 * - jwtUtil: Utility class for JWT operations.
 * - authenticationManager: Manager for handling authentication.
 * <p>
 * Methods:
 * - handle(String requestToken, ServerWebExchange exchange, WebFilterChain chain): Handles the token authentication flow.
 * - handleError(Throwable e, ServerWebExchange exchange): Handles errors during the token authentication process.
 * - sendUnauthorizedResponse(ServerWebExchange exchange, String errorMessage): Sends an unauthorized response.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
@AllArgsConstructor
@Component
public class TokenAuthenticationFlowHandlerImpl implements TokenAuthenticationFlowHandler {

    private final JwtUtil jwtUtil;
    private final AuthenticationManager authenticationManager;

    @Override
    public Mono<Void> handle(String requestToken, ServerWebExchange exchange, WebFilterChain chain) {
        return Mono.justOrEmpty(requestToken)
                .filter(token -> jwtUtil.hasToken(token) && jwtUtil.isValidToken(token))
                .flatMap(token -> {
                    String tokenWithoutPrefix = jwtUtil.extractPrefix(token);
                    String username = jwtUtil.getUsernameFromToken(tokenWithoutPrefix);
                    return authenticationManager.setAuthenticated(username, tokenWithoutPrefix, exchange, chain);
                })
                .onErrorResume(e -> handleError(e, exchange)); // Handle error globally
    }

    private Mono<Void> handleError(Throwable e, ServerWebExchange exchange) {
        if (!exchange.getResponse().isCommitted()) {
            String errorMessage;
            if (e instanceof ExpiredJwtException)
                errorMessage = "Token expired. Please login again.";
            else if (e instanceof JwtException)
                errorMessage = "Invalid token.";
            else
                errorMessage = e.getMessage();

            return sendUnauthorizedResponse(exchange, errorMessage);
        } else {
            return Mono.empty();
        }
    }

    private Mono<Void> sendUnauthorizedResponse(ServerWebExchange exchange, String errorMessage) {
        HttpStatus status = HttpStatus.UNAUTHORIZED;
        ServerHttpResponse response = exchange.getResponse();
        response.setStatusCode(status);
        response.getHeaders().setContentType(MediaType.APPLICATION_JSON);
        Response errorResponse = error(errorMessage);
        byte[] bytes = convertToJsonAsBytes(errorResponse);
        DataBuffer buffer = response.bufferFactory().wrap(bytes);
        return response.writeWith(Mono.just(buffer));
    }
}

package com.whatacook.cookers.config.filter;

import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

/**
 * Interface for sending error responses in HTML format.
 * Defines a method to send an error response with HTML content.
 * <p>
 * Methods:
 * - send(ServerWebExchange exchange, String htmlContent):
 * Sends an error response with the provided HTML content using the given exchange.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
public interface ResponseErrorHtml {
    Mono<Void> send(ServerWebExchange exchange, String htmlContent);
}

package com.whatacook.cookers.config.filter;

import com.whatacook.cookers.config.jwt.JwtUtil;
import jakarta.validation.constraints.NotNull;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import org.springframework.web.server.WebFilter;
import org.springframework.web.server.WebFilterChain;
import reactor.core.publisher.Mono;

import java.util.Map;
import java.util.Optional;

/**
 * Web filter that handles various request flows based on the presence of specific headers or query parameters.
 * Utilizes different handlers for JWT authentication, activation codes, email resending, password resetting, and setting new passwords.
 * <p>
 * Annotations:
 * - @Component: Indicates that this class is a Spring component.
 * <p>
 * Fields:
 * - handlers: A map of request handlers associated with specific JWT keys.
 * <p>
 * Methods:
 * - AnyRequestFilter(JwtUtil jwtUtil, TokenAuthenticationFlowHandler tokenAuthenticationFlowHandler, ActivationCodeFlowHandler activationCodeFlowHandler,
 * EmailResendFlowHandler emailResendFlowHandler, EmailResetPasswordFlowHandler emailResetPasswordFlowHandler, SetNewPasswordFlowHandler setNewPasswordFlowHandler):
 * Constructor that initializes the handlers map with appropriate request handlers.
 * - createHandler(TriFunction<String, ServerWebExchange, WebFilterChain, Mono<Void>> handlerFunction, String jwtKey): Creates a request handler.
 * - filter(ServerWebExchange exchange, WebFilterChain chain): Filters the web exchange and delegates to the appropriate handler.
 * - requestContainsKey(ServerWebExchange exchange, String key): Checks if the request contains the specified key.
 * - getHeaderOrParamValue(ServerWebExchange exchange, String key): Retrieves the value of the specified key from the request headers or query parameters.
 * <p>
 * Functional Interfaces:
 * - RequestHandler: Functional interface for handling requests.
 * - TriFunction: Functional interface that takes three arguments and produces a result.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
@Component
public class AnyRequestFilter implements WebFilter {

    private final Map<String, RequestHandler> handlers;

    /**
     * Constructor that initializes the handlers map with appropriate request handlers.
     *
     * @param jwtUtil                        The utility class for JWT operations.
     * @param tokenAuthenticationFlowHandler The handler for token authentication flow.
     * @param activationCodeFlowHandler      The handler for activation code flow.
     * @param emailResendFlowHandler         The handler for email resend flow.
     * @param emailResetPasswordFlowHandler  The handler for email reset password flow.
     * @param setNewPasswordFlowHandler      The handler for setting new password flow.
     */
    public AnyRequestFilter(JwtUtil jwtUtil, TokenAuthenticationFlowHandler tokenAuthenticationFlowHandler,
                            ActivationCodeFlowHandler activationCodeFlowHandler,
                            EmailResendFlowHandler emailResendFlowHandler,
                            EmailResetPasswordFlowHandler emailResetPasswordFlowHandler,
                            SetNewPasswordFlowHandler setNewPasswordFlowHandler) {
        handlers = Map.of(
                jwtUtil.getHeader(), createHandler(tokenAuthenticationFlowHandler::handle, jwtUtil.getHeader()),
                jwtUtil.getActivation(), createHandler(activationCodeFlowHandler::handle, jwtUtil.getActivation()),
                jwtUtil.getResend(), createHandler(emailResendFlowHandler::handle, jwtUtil.getResend()),
                jwtUtil.getResetCode(), createHandler(emailResetPasswordFlowHandler::handle, jwtUtil.getResetCode()),
                jwtUtil.getCodeToSet(), createHandler(setNewPasswordFlowHandler::handle, jwtUtil.getCodeToSet())
        );
    }

    /**
     * Creates a request handler that processes requests based on the specified handler function and JWT key.
     *
     * @param handlerFunction The function to handle the request.
     * @param jwtKey          The JWT key used to identify the request.
     * @return A RequestHandler that processes the request.
     */
    private RequestHandler createHandler(TriFunction<String, ServerWebExchange, WebFilterChain, Mono<Void>> handlerFunction, String jwtKey) {
        return (exchange, chain) -> {
            String paramValue = getHeaderOrParamValue(exchange, jwtKey);
            return handlerFunction.apply(paramValue, exchange, chain);
        };
    }

    /**
     * Filters the web exchange and delegates to the appropriate handler based on the presence of specific headers or query parameters.
     *
     * @param exchange The current server web exchange.
     * @param chain    The web filter chain.
     * @return A Mono<Void> that indicates when request processing is complete.
     */
    @SuppressWarnings("NullableProblems")
    @Override
    public Mono<Void> filter(@NotNull ServerWebExchange exchange, @NotNull WebFilterChain chain) {
        return handlers.entrySet().stream()
                .filter(entry -> requestContainsKey(exchange, entry.getKey()))
                .findFirst()
                .map(entry -> entry.getValue().handle(exchange, chain))
                .orElseGet(() -> chain.filter(exchange));
    }

    /**
     * Checks if the request contains the specified key in headers or query parameters.
     *
     * @param exchange The current server web exchange.
     * @param key      The key to check in the request.
     * @return True if the request contains the specified key, false otherwise.
     */
    private boolean requestContainsKey(ServerWebExchange exchange, String key) {
        return exchange.getRequest().getHeaders().containsKey(key) ||
                exchange.getRequest().getQueryParams().containsKey(key);
    }

    /**
     * Retrieves the value of the specified key from the request headers or query parameters.
     *
     * @param exchange The current server web exchange.
     * @param key      The key to retrieve the value for.
     * @return The value of the specified key, or null if not found.
     */
    private String getHeaderOrParamValue(ServerWebExchange exchange, String key) {
        return Optional.ofNullable(exchange.getRequest().getHeaders().getFirst(key))
                .orElse(exchange.getRequest().getQueryParams().getFirst(key));
    }

    /**
     * Functional interface for handling requests.
     */
    @FunctionalInterface
    public interface RequestHandler {
        Mono<Void> handle(ServerWebExchange exchange, WebFilterChain chain);
    }

    /**
     * Functional interface that takes three arguments and produces a result.
     *
     * @param <T> The type of the first argument to the function.
     * @param <U> The type of the second argument to the function.
     * @param <V> The type of the third argument to the function.
     * @param <R> The type of the result of the function.
     */
    @FunctionalInterface
    public interface TriFunction<T, U, V, R> {
        R apply(T t, U u, V v);
    }

}

package com.whatacook.cookers.config;

import jakarta.annotation.PostConstruct;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.JavaMailSenderImpl;
import org.springframework.util.StringUtils;

import java.io.IOException;
import java.util.Properties;

/**
 * Configuration class for setting up the Spring Mail with Gmail.
 * Reads the email credentials from Docker secrets and initializes the JavaMailSender.
 * <p>
 * Annotations:
 * - @Slf4j: Lombok annotation to generate a logger field.
 * - @NoArgsConstructor: Generates a no-arguments constructor.
 * - @Setter: Generates setter methods for all fields.
 * - @Getter: Generates getter methods for all fields.
 * - @Configuration: Indicates that this class contains Spring configuration.
 * <p>
 * Fields:
 * - springMailUser: The email user for sending mails.
 * - gMailAppPass: The application password for the Gmail account.
 * <p>
 * Methods:
 * - init(): Initializes the email credentials by reading Docker secrets.
 * - getJavaMailSender(): Configures and returns a JavaMailSender instance.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
@Slf4j
@NoArgsConstructor
@Setter
@Getter
@Configuration
public class SpringMailConfig {

    private String springMailUser;
    @Getter(AccessLevel.NONE)
    private String gMailAppPass;

    /**
     * Initializes the email credentials by reading Docker secrets.
     * Sets the system properties for email user and password.
     */
    @PostConstruct
    public void init() {
        try {
            String USER = "SPRING_MAIL_VALIDATION";
            String APP_PASS = "GMAIL_APP_PASSWORD";

            springMailUser = DockerConfig.readSecret(USER);
            gMailAppPass = DockerConfig.readSecret(APP_PASS);

            if (StringUtils.hasText(springMailUser))
                System.setProperty(USER, springMailUser.trim());
            log.warn("springMailUser : {}", StringUtils.hasText(springMailUser));

            if (StringUtils.hasText(gMailAppPass))
                System.setProperty(APP_PASS, gMailAppPass.trim());
            log.warn("springMailPass : {}", StringUtils.hasText(gMailAppPass));

        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Configures and returns a JavaMailSender instance.
     *
     * @return The configured JavaMailSender instance.
     */
    @Bean
    public JavaMailSender getJavaMailSender() {
        JavaMailSenderImpl mailSender = new JavaMailSenderImpl();
        mailSender.setHost("smtp.gmail.com");
        mailSender.setPort(587);

        mailSender.setUsername(springMailUser);
        mailSender.setPassword(gMailAppPass);

        Properties props = mailSender.getJavaMailProperties();
        props.put("mail.transport.protocol", "smtp");
        props.put("mail.smtp.auth", "true");
        props.put("mail.smtp.starttls.enable", "true");
//        props.put("mail.debug", "true");

        return mailSender;
    }
}

package com.whatacook.cookers.controller;

import lombok.extern.log4j.Log4j2;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.io.IOException;
import java.nio.file.Files;

@RestController
@RequestMapping("${app.endpoint.javadoc}")
@Log4j2
public class JavaDocController {

    @GetMapping("/")
    public ResponseEntity<byte[]> getJavadoc() {
        try {
            Resource resource = new FileSystemResource("/app/javadoc/index.html");
            if (!resource.exists()) {
                log.error("Javadoc file not found at /app/javadoc/index.html");
                return new ResponseEntity<>(HttpStatus.NOT_FOUND);
            }
            byte[] content = Files.readAllBytes(resource.getFile().toPath());
            HttpHeaders headers = new HttpHeaders();
            headers.add("Content-Type", "text/html");
            return new ResponseEntity<>(content, headers, HttpStatus.OK);
        } catch (IOException e) {
            log.error("Error reading Javadoc file: ", e);
            return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
}

package com.whatacook.cookers.controller;

import com.whatacook.cookers.model.auth.AuthRequestDto;
import com.whatacook.cookers.model.responses.Response;
import com.whatacook.cookers.model.users.UserJson;
import com.whatacook.cookers.model.users.UserJustToSave;
import com.whatacook.cookers.service.AuthService;
import jakarta.validation.Valid;
import lombok.AllArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

@AllArgsConstructor
@RestController
@RequestMapping("${app.endpoint.auth-root}")
@CrossOrigin
public class JwtAuthenticationController {

    private final AuthService auth;

    @PostMapping("${app.endpoint.sign-in-url}")
    @ResponseStatus(HttpStatus.CREATED)
    public Mono<Response> register(@Valid @RequestBody UserJustToSave userJson) { return auth.registerNewUser(userJson); }

    @PostMapping(value = "${app.endpoint.login-url}")
    public Mono<ResponseEntity<Response>> createAuthenticationTokenByLogin(@RequestBody AuthRequestDto AuthRequestDto) {
        return auth.authenticationByLogin(AuthRequestDto);
    }

    @PostMapping("${app.endpoint.forgot-pass}")
    public Mono<ResponseEntity<Response>> forgotPassword(@RequestBody UserJson userJson) {
        return auth.sendEmailCodeToResetPassword(userJson);
    }

}

package com.whatacook.cookers.controller;

import com.whatacook.cookers.config.jwt.AuthorizationUtil;
import com.whatacook.cookers.model.favorites.FavoriteRequest;
import com.whatacook.cookers.model.responses.Response;
import com.whatacook.cookers.service.FavoriteService;
import jakarta.annotation.Nonnull;
import lombok.AllArgsConstructor;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

@AllArgsConstructor
@RestController
@RequestMapping("${app.endpoint.favorites}")
public class FavoriteController {

    private final FavoriteService favoriteService;

    @PostMapping()
    @PreAuthorize("hasRole('USER') or hasRole('ADMIN') or hasRole('SELF')")
    public Mono<Response> getFavorites(@RequestBody @Nonnull FavoriteRequest favoriteRequest) {
        return AuthorizationUtil.executeIfAuthorized(favoriteRequest,
                (json, userDetails) -> favoriteService.getFavorites(favoriteRequest));
    }

    @PostMapping("${app.endpoint.add-recipe}")
    @PreAuthorize("hasRole('USER') or hasRole('ADMIN') or hasRole('SELF')")
    public Mono<Response> addFavoriteRecipe(@RequestBody @Nonnull FavoriteRequest favoriteRequest) {
        return AuthorizationUtil.executeIfAuthorized(favoriteRequest,
                (json, userDetails) -> favoriteService.addFavoriteRecipe(favoriteRequest));
    }

    @PostMapping("${app.endpoint.add-ingredient}")
    @PreAuthorize("hasRole('USER') or hasRole('ADMIN') or hasRole('SELF')")
    public Mono<Response> addFavoriteIngredient(@RequestBody @Nonnull FavoriteRequest favoriteRequest) {
        return AuthorizationUtil.executeIfAuthorized(favoriteRequest,
                (json, userDetails) -> favoriteService.addFavoriteIngredient(favoriteRequest));
    }

    @PostMapping("${app.endpoint.remove-recipe}")
    @PreAuthorize("hasRole('USER') or hasRole('ADMIN') or hasRole('SELF')")
    public Mono<Response> removeFavoriteRecipe(@RequestBody @Nonnull FavoriteRequest favoriteRequest) {
        return AuthorizationUtil.executeIfAuthorized(favoriteRequest,
                (json, userDetails) -> favoriteService.removeFavoriteRecipe(favoriteRequest));
    }

    @PostMapping("${app.endpoint.remove-ingredient}")
    @PreAuthorize("hasRole('USER') or hasRole('ADMIN') or hasRole('SELF')")
    public Mono<Response> removeFavoriteIngredient(@RequestBody @Nonnull FavoriteRequest favoriteRequest) {
        return AuthorizationUtil.executeIfAuthorized(favoriteRequest,
                (json, userDetails) -> favoriteService.removeFavoriteIngredient(favoriteRequest));
    }

}

package com.whatacook.cookers.controller;

import com.whatacook.cookers.model.responses.Response;
import io.jsonwebtoken.ClaimJwtException;
import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.JwtException;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.ConstraintViolationException;
import org.springframework.core.codec.DecodingException;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.http.HttpStatus;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.support.WebExchangeBindException;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;
import org.springframework.web.reactive.resource.NoResourceFoundException;
import org.springframework.web.server.MethodNotAllowedException;

import java.util.Map;
import java.util.NoSuchElementException;
import java.util.stream.Collectors;

@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler({MethodArgumentNotValidException.class})
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    @ResponseBody
    public Response handleValidationExceptions(MethodArgumentNotValidException ex) {
        Map<String, String> errorMsg = ex.getBindingResult().getFieldErrors().stream()
                .collect(Collectors.groupingBy(FieldError::getField,
                        Collectors.mapping(FieldError::getDefaultMessage, Collectors.joining("; "))));

        return createErrorResponse(HttpStatus.BAD_REQUEST, "Invalid or incorrect format!!!", errorMsg);
    }

    @ExceptionHandler({WebExchangeBindException.class})
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    @ResponseBody
    public Response handleValidationExceptions(WebExchangeBindException ex) {
        @SuppressWarnings("DataFlowIssue")
        Map<String, String> errors = ex.getFieldErrors().stream()
                .collect(Collectors.toMap(
                        FieldError::getField,
                        FieldError::getDefaultMessage,
                        (existing, replacement) -> existing));

        return createErrorResponse(HttpStatus.BAD_REQUEST, "Invalid or incorrect format!!!", errors);
    }

    @ExceptionHandler(ConstraintViolationException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    @ResponseBody
    public Response handleConstraintViolationException(ConstraintViolationException ex) {
        var errors = ex.getConstraintViolations().stream()
                .collect(Collectors.toMap(
                        violation -> {
                            String path = violation.getPropertyPath().toString();
                            return path.substring(path.lastIndexOf('.') + 1); // Retorna solo el nombre del campo
                        },
                        ConstraintViolation::getMessage, // El mensaje de error para esa violaci√≥n
                        (existingValue, newValue) -> existingValue // En caso de campos duplicados, mantiene el primer mensaje de error encontrado
                ));


        return createErrorResponse(HttpStatus.BAD_REQUEST, "Validation error", errors);
    }


    @ExceptionHandler({DecodingException.class})
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    @ResponseBody
    public Response handleValidationExceptions(DecodingException ex) {
        String errorMessage = "Invalid request body or not present: A valid request body is required.";
        return createErrorResponse(HttpStatus.BAD_REQUEST, errorMessage, ex);
    }

    @ExceptionHandler({ HttpMessageNotReadableException.class, MethodArgumentTypeMismatchException.class,
            MethodNotAllowedException.class })
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    @ResponseBody
    public Response handleInvalidRequest(Exception ex) {
        return createErrorResponse(HttpStatus.BAD_REQUEST, "Invalid or incorrect requisition!!!", ex);
    }

    @ExceptionHandler({ EmptyResultDataAccessException.class, NoSuchElementException.class })
    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)
    @ResponseBody
    public Response handleCantFoundWhatYouWant(Exception ex) {
        return createErrorResponse(HttpStatus.INTERNAL_SERVER_ERROR, "Couldn't find what you want", ex);
    }

    @ExceptionHandler({NoResourceFoundException.class})
    @ResponseStatus(value = HttpStatus.NOT_FOUND)
    @ResponseBody
    public Response handleRequestNotFound(Exception ex) {
        return createErrorResponse(HttpStatus.NOT_FOUND, "SORRY BABY, the fault is ours!!!", ex);
    }

    @ExceptionHandler({JwtException.class, ExpiredJwtException.class, ClaimJwtException.class})
    @ResponseStatus(value = HttpStatus.UNAUTHORIZED)
    @ResponseBody
    public Response handleJwtException(Exception ex) {
        return createErrorResponse(HttpStatus.UNAUTHORIZED, "Please, Log in again!!!", ex);
    }

    private Response createErrorResponse(HttpStatus status, String customMessage, Exception ex) {
        return Response.error(httpMessageError(status, customMessage), Map.of("ERROR", ex.getMessage().split(":")[0]));
    }

    @SuppressWarnings({"rawtypes", "SameParameterValue"})
    private Response createErrorResponse(HttpStatus status, String customMessage, Map map) {
        return Response.error(httpMessageError(status, customMessage), map);
    }

    private static String httpMessageError(HttpStatus status, String msg) {
        return String.format("[%s - %d] 8==> %s", status.getReasonPhrase().toUpperCase(), status.value(), msg);
    }

}

package com.whatacook.cookers.controller;

import com.whatacook.cookers.config.jwt.AuthorizationUtil;
import com.whatacook.cookers.model.responses.Response;
import com.whatacook.cookers.model.users.UserJson;
import com.whatacook.cookers.service.UserService;
import com.whatacook.cookers.utilities.ValidEmail;
import jakarta.validation.Valid;
import lombok.AllArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

@AllArgsConstructor
@RestController
@RequestMapping("${app.endpoint.users}")
@Validated
public class UserController {

    private final UserService service;

    @PostMapping("${app.endpoint.users-check-email}")
    public Mono<Response> existsByEmail(@Valid @RequestBody UserJson userJson) {
        return service.existsByEmail(userJson);
    }

    @PostMapping("${app.endpoint.find-by-email}")
    @PreAuthorize("hasRole('SELF') or hasRole('ADMIN')")
    public Mono<Response> readOne(@Valid @RequestBody UserJson userJson) {
        return AuthorizationUtil.executeIfAuthorized(userJson, (json, userDetails) -> service.readOne(json));
    }

    @PutMapping()
    @PreAuthorize("hasRole('SELF') or hasRole('ADMIN')")
    public Mono<Response> update(@RequestBody UserJson userJson) {
        return AuthorizationUtil.executeIfAuthorized(userJson, (json, userDetails) -> service.updateOne(json));
    }

    @DeleteMapping()
    @PreAuthorize("hasRole('USER') or hasRole('ADMIN')")
    public Mono<Response> deleteOne(@RequestParam("id") String id) {
        return AuthorizationUtil.executeIfAuthorized(new UserJson(id), (json, userDetails) -> service.deleteOne(json));
    }

    @GetMapping("${app.endpoint.users-activate}")
    @ResponseStatus(HttpStatus.OK)
    public Mono<ResponseEntity<String>> activate(@RequestParam("activationCode") String activationCode) {
        return service.activateAccount(activationCode);
    }

    @GetMapping("${app.endpoint.users-resend}")
    @ResponseStatus(HttpStatus.OK)
    public Mono<Response> resendActivation(@ValidEmail @RequestParam("emailToResend") String emailToResend) {
        return service.resendActivateCode(emailToResend);
    }

    @GetMapping("${app.endpoint.reset-pass}")
    @ResponseStatus(HttpStatus.OK)
    public Mono<ResponseEntity<String>> resetPassword(@RequestParam("resetCode") String resetCode) {
        return service.resetPasswordByCode(resetCode);
    }

    @PostMapping("${app.endpoint.set-new-pass}")
    @ResponseStatus(HttpStatus.OK)
    public Mono<ResponseEntity<String>> setNewPassword(@RequestBody UserJson userJson) {
        return service.setNewPasswordByCode(userJson);
    }

}


package com.whatacook.cookers.utilities;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.util.StringUtils;

import java.time.LocalDate;

/**
 * Utility class containing various helper methods for validation and data conversion.
 * <p>
 * Methods:
 * - isValidBirthdate(LocalDate birthdate): Checks if the given birthdate is valid (at least 7 years old).
 * - notValidBirthdate(LocalDate birthdate): Checks if the given birthdate is not valid.
 * - isNullOrEmpty(String something): Checks if the given string is null or empty.
 * - isNullOrEmptyOrLiteralNull(String something): Checks if the given string is null, empty, or the literal string "null".
 * - notNullOrEmpty(String something): Checks if the given string is not null, empty, or the literal string "null".
 * - TitleCase(String toConvert): Converts a string to title case.
 * - encryptPassword(String toEncrypt): Encrypts a password using BCrypt.
 * - encryptMatches(String rawPassword, String encodedPassword): Checks if the raw password matches the encoded password.
 * - encryptNotMatches(String rawPassword, String encodedPassword): Checks if the raw password does not match the encoded password.
 * - isValidEmail(String email): Checks if the given email is valid.
 * - notValidEmail(String email): Checks if the given email is not valid.
 * - buildEmailRegex(): Builds the regex pattern for email validation.
 * - isValidPassword(String password): Checks if the given password is valid.
 * - notValidPassword(String password): Checks if the given password is not valid.
 * - buildPassRegex(): Builds the regex pattern for password validation.
 * - convertToJsonAsString(Object obj): Converts an object to a JSON string.
 * - convertToJsonAsBytes(Object obj): Converts an object to a byte array in JSON format.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
public class Util {

    public static boolean isValidBirthdate(LocalDate birthdate) {
        return birthdate != null && !birthdate.isAfter(LocalDate.now().minusYears(7));
    }

    public static boolean notValidBirthdate(LocalDate birthdate) {
        return birthdate == null || birthdate.isAfter(LocalDate.now().minusYears(7));
    }

    public static boolean isNullOrEmpty(String something) {
        return !StringUtils.hasText(something);
    }

    public static boolean isNullOrEmptyOrLiteralNull(String something) {
        return isNullOrEmpty(something) || "null".equalsIgnoreCase(something.trim());
    }

    public static boolean notNullOrEmpty(String something) {
        return StringUtils.hasText(something) && !"null".equalsIgnoreCase(something.trim());
    }

    public static String TitleCase(String toConvert) {
        return isNullOrEmptyOrLiteralNull(toConvert) ? null : TitleCase.all(toConvert);
    }

    public static String encryptPassword(String toEncrypt) {
        return BCrypt.encode(toEncrypt);
    }

    public static boolean encryptMatches(String rawPassword, String encodedPassword) {
        return notNullOrEmpty(rawPassword) && BCrypt.matches(rawPassword, encodedPassword);
    }

    public static boolean encryptNotMatches(String rawPassword, String encodedPassword) {
        return !encryptMatches(rawPassword, encodedPassword);
    }

    public static boolean isValidEmail(String email) {
        return notNullOrEmpty(email) && email.matches(buildEmailRegex());
    }

    public static boolean notValidEmail(String email) {
        return isNullOrEmpty(email) || !email.matches(buildEmailRegex());
    }

    public static String buildEmailRegex() {
        String front = "[\\p{L}\\p{N}!#$%&'*+/=?^_`{|}~-]+";
        String back = "[\\p{L}\\p{N}](?:[a-z0-9-]*[\\p{L}\\p{N}]";
        String domain = String.format("(?:%s)?.)+%s)?", back, back);
        return String.format("%s(?:.%s)*@%s", front, front, domain);
    }

    public static boolean isValidPassword(String password) {
        return notNullOrEmpty(password) && password.matches(buildPassRegex());
    }

    public static boolean notValidPassword(String password) {
        return isNullOrEmpty(password) || !password.matches(buildPassRegex());
    }

    public static String buildPassRegex() {
//        String characters = "!¬°|'¬¥`¬®\\^*+@¬∑#$%&/{}()=\\-_:.;,<>?¬ø";
        String charactersUnicode = "\\u0021\\u00A1\\u007C\\u0027\\u00B4\\u0060\\u00A8\\u005E\\u002A\\u002B\\u0040\\u00B7\\u0023\\u0024\\u0025\\u0026\\u002F\\u007B\\u007D\\u0028\\u0029\\u003D\\u005C\\u002D\\u005F\\u003A\\u002E\\u003B\\u002C\\u003C\\u003E\\u003F\\u00BF";
        String regex = "^(?=.*[\\p{Ll}])(?=.*[\\p{Lu}])(?=.*\\p{N})(?=.*[%s])[\\p{L}\\p{N}%s]{8,}$";
        return String.format(regex, charactersUnicode, charactersUnicode);
    }

    public static String convertToJsonAsString(Object obj) {
        try {
            return new ObjectMapper().writeValueAsString(obj);
        } catch (JsonProcessingException e) {
            return "{\"error\": \"Error converting to JSON.\"}";
        }
    }

    public static byte[] convertToJsonAsBytes(Object obj) {
        try {
            return new ObjectMapper().writeValueAsBytes(obj);
        } catch (JsonProcessingException e) {
            return "{\"error\": \"Error converting to JSON.\"}".getBytes();
        }
    }

    private static final BCryptPasswordEncoder BCrypt = new BCryptPasswordEncoder();

}

package com.whatacook.cookers.utilities;

import lombok.Getter;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.properties.ConfigurationProperties;

/**
 * Configuration properties for global values used in the application.
 * <p>
 * Annotations:
 * - @Getter: Generates getters for all fields.
 * - @ConfigurationProperties: Binds the class fields to properties prefixed with "global.values".
 * <p>
 * Fields:
 * - urlWacLogoPngSmall: URL for the small WAC logo.
 * - baseIp: Base IP address for the application.
 * - urlActivationAccount: URL for account activation.
 * - urlForgotPassword: URL for forgotten password.
 * - urlResetPassword: URL for resetting password.
 * - urlSetNewPassword: URL for setting a new password.
 * - mailToWac: Email address for WAC.
 * - pathToResendActvationMail: Path to resend activation email.
 * - pathToCheckIfEmailAlreadyExists: Path to check if email already exists.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
@Getter
@ConfigurationProperties(prefix = "global.values")
public class GlobalValues {

    @Value("${global.values.links.wac.logo.small.png}")
    private String urlWacLogoPngSmall;

    @Value("${global.values.links.base-ip}")
    private String baseIp;

    @Value("${global.values.links.activation-account}")
    private String urlActivationAccount;

    @Value("${global.values.links.forgot-password}")
    private String urlForgotPassword;

    @Value("${global.values.links.reset-password}")
    private String urlResetPassword;

    @Value("${global.values.links.set-new-password}")
    private String urlSetNewPassword;

    @Value("${global.values.email.wac}")
    private String mailToWac;

    @Value("${global.values.url.resend.confirmation.mail}")
    private String pathToResendActvationMail;

    @Value("${global.values.url.check.email.is.used}")
    private String pathToCheckIfEmailAlreadyExists;

    @Value("${app.endpoint.javadoc}")
    private String pathToJavaDoc;

    @Value("${global.values.directory.javadoc}")
    private String pathToDirectoryJavadoc;

}

package com.whatacook.cookers.utilities;

import jakarta.validation.Constraint;
import jakarta.validation.Payload;
import jakarta.validation.constraints.Pattern;

import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

/**
 * Annotation for validating passwords.
 * Ensures passwords contain at least 8 characters, including uppercase, lowercase letters, numbers, and special characters.
 * <p>
 * Annotations:
 * - @Documented: Indicates that elements using this annotation should be documented by javadoc and similar tools.
 * - @Constraint: Specifies the validator class.
 * - @Target: Specifies the kinds of elements an annotation type can be applied to.
 * - @Retention: Specifies how long annotations with the annotated type are to be retained.
 * <p>
 * Fields:
 * - message: Custom error message for invalid passwords.
 * - groups: Allows the specification of validation groups.
 * - payload: Can be used by clients to associate metadata with a given constraint declaration.
 * <p>
 * Constants:
 * - characters: Allowed special characters in the password.
 * - regex: Regular expression for password validation.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
@Documented
@Constraint(validatedBy = {})
@Target({FIELD, METHOD, PARAMETER, ANNOTATION_TYPE})
@Retention(RUNTIME)
@Pattern(regexp = "^(?=.*[\\p{Ll}])(?=.*[\\p{Lu}])(?=.*\\p{N})(?=.*[\\u0021\\u00A1\\u007C\\u0027\\u00B4\\u0060\\u00A8\\u005E\\u002A\\u002B\\u0040\\u00B7\\u0023\\u0024\\u0025\\u0026\\u002F\\u007B\\u007D\\u0028\\u0029\\u003D\\u005C\\u002D\\u005F\\u003A\\u002E\\u003B\\u002C\\u003C\\u003E\\u003F\\u00BF])[\\p{L}\\p{N}\\u0021\\u00A1\\u007C\\u0027\\u00B4\\u0060\\u00A8\\u005E\\u002A\\u002B\\u0040\\u00B7\\u0023\\u0024\\u0025\\u0026\\u002F\\u007B\\u007D\\u0028\\u0029\\u003D\\u005C\\u002D\\u005F\\u003A\\u002E\\u003B\\u002C\\u003C\\u003E\\u003F\\u00BF]{8,}$")
public @interface ValidPassword {
    String characters = "";
    String regex = "";

    String message() default "Password must contain at least 8 characters, including uppercase, lowercase letters, numbers, and special characters (!#$%&'*+/=?^_`{|}~-).";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};
}

package com.whatacook.cookers.utilities;


import java.util.Arrays;
import java.util.stream.Collectors;

/**
 * Class that contains three statics and public methods for converting strings
 * into Title Case; the three methods have the same function, but with different
 * approaches. The first and most basic, simply receives as parameters the
 * string to be converted. The second receives as parameters the string to be
 * converted and an array of exceptions to be ignored in the conversion. And
 * finally, the third method is the same as the second, except that it ignores
 * capitalized words, such as acronyms. Another way to set up global exceptions
 * is to create an instance of the class and thus use its two public methods,
 * which ignore exceptions or capitalized words.
 *
 * @author FaunoGuazina
 **/
public final class TitleCase {

    // PUBLIC STATIC METHODS FOR USE ----------------------- PUBLIC STATIC METHODS FOR USE //

    /**
     * Public static method that processes the string to be converted: eliminates
     * any space characters that may be at the beginning and at the end, then
     * removes any double-spacing, after all, proceed with the conversion into Title
     * Case.
     *
     * @param toConvert the string sentence that will be converted.
     * @return The same string sentence converted to a Title Case.
     */
    public static String all(String toConvert) {

        setExceptions();

        setCapitalWord(false);

        return toTitleSentence(toConvert);
    }

    /**
     * Public static method that processes the string to be converted: eliminates
     * any space characters that may be at the beginning and at the end, then
     * removes any double-spacing, if you have any exceptions set to be ignored, after
     * all, send everything to conversion.
     *
     * @param toConvert  the string sentence that will be converted.
     * @param exceptions array of strings with all words that will be ignored when
     *                   converting OR words strings separated by a comma: "word1",
     *                   "word2", "word3"...
     * @return the same string sentence converted to a Title Case.
     */
    public static String withExceptions(String toConvert, String... exceptions) {

        setExceptions(exceptions);

        setCapitalWord(false);

        return toTitleSentence(toConvert);
    }

    /**
     * Public static method that processes the string to be converted: eliminates
     * any space characters that may be at the beginning and at the end, then
     * removes any double-spacing, if you have any exceptions set to be ignored, after
     * all, send everything to conversion. This method ignores any word that is fully
     * capitalized if the whole sentence is not all in upper case, in this case it
     * is necessary to configure the exceptions that will be ignored.
     *
     * @param toConvert  the string sentence that will be converted.
     * @param exceptions array of all words that will be ignored when converting
     *                   OR words strings separated by a comma: "word1", "word2",
     *                   "word3"...
     * @return the same string sentence converted to a Title Case.
     */
    public static String withCAPITAL(String toConvert, String... exceptions) {

        setExceptions(exceptions);

        setCapitalWord(!toConvert.matches(UPPER_SENTENCE));

        return toTitleSentence(toConvert);
    }

    // PUBLIC INSTANCE METHODS FOR USE ----------------------- PUBLIC INSTANCE METHODS FOR USE //

    /**
     * Constructor that allows you to create an instance of TitleCase class and thus
     * configure the global exceptions that will be used in your methods. This
     * method has Varargs as a parameter, and therefore the way of passing multiple
     * words is in the form of strings separated by a comma or an array of strings.
     *
     * @param exceptions array of all words that will be ignored when converting
     *                   OR strings separated by a comma: "word1", "word2",
     *                   "word3"...
     */
    public TitleCase(String... exceptions) {
        setExceptions(exceptions);
    }

    /**
     * Public instance method that processes the string to be converted: eliminates
     * any space characters that may be at the beginning and at the end, then
     * removes any double-spacing, use instance global exceptions to set the words
     * to be ignored, after all, send everything to conversion.
     *
     * @param toConvert the string sentence that will be converted.
     * @return the same string sentence converted to a Title Case.
     */
    public String titleCase(String toConvert) {

        setCapitalWord(false);

        return toTitleSentence(toConvert);
    }

    /**
     * Public instance method that processes the string to be converted: eliminates
     * any space characters that may be at the beginning and at the end, then
     * removes any double-spacing, use global instance exceptions to set the words
     * to be ignored, after all, send everything to conversion. This method ignores
     * any word that is fully capitalized if the whole sentence is not all in upper
     * case, in this case it is necessary to configure the exceptions that will be
     * ignored.
     *
     * @param toConvert the string sentence that will be converted.
     * @return the same string sentence converted to a Title Case.
     */
    public String titleCAPITAL(String toConvert) {

        setCapitalWord(!toConvert.matches(UPPER_SENTENCE));

        return toTitleSentence(toConvert);
    }

    // PRIVATE METHODS FOR INTERNAL USE ----------------------- PRIVATE METHODS FOR INTERNAL USE //

    /**
     * Private method that processes the string sentence to be converted: first
     * eliminates any space characters that may be at the beginning and at the end,
     * then removes any double-spacing, then split the string from its spaces in an
     * array of words. For each one of them proceeds with the verification of your
     * specific case, then if {@code capitalWord} is true will check if every word
     * matches with a fully capitalized word, if so it does not convert into a Title
     * Case.
     *
     * @param toConvert the string sentence that will be converted.
     * @return the same string sentence converted to a Title Case.
     */
    private static String toTitleSentence(String toConvert) {

        setTheInput(toConvert);

        setArrayOfConvertedWords();

        if (hasExceptions())
            rateFirstWordOfArray();

        return String.join(" ", arrayWords);
    }

    /**
     * Private auxiliary method that prepares the string that will be converted.
     * First eliminate spaces that may exist at the beginning and at the end
     * (TRIM), then replace any multiple space with single spaces.
     *
     * @param input string to be converted
     */
    private static void setTheInput(String input) {
        TitleCase.theInput = input.trim().replaceAll("( )+", " ");
    }

    /**
     * Private auxiliary method that break theInput to be converted into an array by
     * split in spaces, then put that into a stream, then map to convert and collect
     * a new array. If there are exceptions, the first word may be one and thus
     * ensures that it is in title case
     */
    private static void setArrayOfConvertedWords() {
        TitleCase.arrayWords = Arrays.stream(theInput.split(" "))
                .map(TitleCase::rateWords).toArray(String[]::new);
    }

    /**
     * Private auxiliary method that checks whether the word fits the exception rule
     * or whether it should be converted to TitleCase, depending on the case invokes
     * relevant auxiliary methods
     *
     * @param word string each word in an array
     * @return string treated word (converted if is the case)
     */
    private static String rateWords(String word) {
        return isExceptions(word) ? rateExceptions(word) : toTitleCase(word);
    }

    /**
     * Private auxiliary method that checks whether the word is an exception or not.
     * Compare the word with the list of exceptions ignoring the Case, or if
     * capitalWord is true, check if the word is capitalized
     *
     * @param word string each word in an array
     * @return boolean false if it doesn't match any type of exception or true if it
     * matches
     */
    private static boolean isExceptions(String word) {
        boolean isException = Arrays.stream(exceptions.split(" "))
                .parallel().anyMatch(w -> w.equalsIgnoreCase(word));
        boolean isCapitalWord = capitalWord && word.matches(CAPITAL_WORD);
        return isException || isCapitalWord;
    }

    /**
     * Private auxiliary method that checks if the word exists identically among the
     * exceptions, if negative it returns all lower cases.
     *
     * @param word string each word in an array
     * @return returns the same string if it is an exception with Case variation or
     * returns all lower case if it is a word that needs to be ignored when
     * converting.
     */
    private static String rateExceptions(String word) {
        boolean isException = Arrays.stream(exceptions.split(" "))
                .parallel().anyMatch(w -> w.equals(word));
        return capitalWord || isException ? word : word.toLowerCase();
    }

    /**
     * Private auxiliary method that checks if there are exceptions, simply to
     * improve readability
     *
     * @return boolean true if there are and false if not.
     */
    private static boolean hasExceptions() {
        return !TitleCase.exceptions.isEmpty();
    }

    /**
     * Private auxiliary method that converts the first word of the array to a title
     * case if necessary.
     */
    private static void rateFirstWordOfArray() {
        boolean isFirstWordNonCapital = capitalWord && !arrayWords[0].matches(CAPITAL_WORD);
        if (!capitalWord || isFirstWordNonCapital) {
            arrayWords[0] = toTitleCase(arrayWords[0]);
        }
    }

    /**
     * Private method that really does the heavy lifting of this utility class, it
     * checks if the word is made up of letters only or has special characters, for
     * each case proceeds with the conversion in a different way.
     *
     * @param word the string word itself that will be converted
     * @return a string word converted to a Title Case
     */
    private static String toTitleCase(String word) {
        return (word.matches(JUST_LETTERS)) ? titleJustLetters(word) : titleWithPunts(word);
    }

    /**
     * Private auxiliary method, if the word is only letters proceed with the
     * simplest conversion using substring.
     *
     * @param word the string word itself that will be converted
     * @return a string word converted to a Title Case
     */
    private static String titleJustLetters(String word) {
        return word.substring(0, 1).toUpperCase().concat(word.substring(1).toLowerCase());
    }

    /**
     * Private auxiliary method that create a new Builder instance and add each
     * converted character then return it as a string
     *
     * @param word the string word itself that will be converted
     * @return a string word converted to a Title Case
     */
    private static String titleWithPunts(String word) {
        builder = new StringBuilder();
        Arrays.stream(word.split("")).forEach(TitleCase::append);
        return builder.toString();
    }

    /**
     * Private auxiliary method which adds to the Builder each character converted
     * from the word
     *
     * @param letter the character to be appended in builder
     */
    private static void append(String letter) {
        builder.append(lowOrUp(letter));
    }

    /**
     * Private auxiliary method, which evaluates each letter, needs to be capitalized
     * or not.
     *
     * @param letter the character in question that is being analyzed
     * @return the same character in upper or lower case
     */
    private static String lowOrUp(String letter) {
        return conditionToUpper() ? letter.toUpperCase() : letter.toLowerCase();
    }

    /**
     * Private auxiliary method, verify if is the first letter of the word, if there
     * was a space before or if there were any of these chars before:
     * !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
     *
     * @return boolean true if it is the first letter of the word or if it has a
     * special char, false if not.
     */
    private static boolean conditionToUpper() {
        if (builder.isEmpty())
            return true;
        String lastCharOnBuilder = String.valueOf(builder.charAt(builder.length() - 1));
        return lastCharOnBuilder.matches("\\p{Punct}|\\s");
    }

    /**
     * method that configures whether the conversion will ignore capitalized words
     * or convert them too
     *
     * @param capitalWord boolean true to ignore words capitalized on conversion and
     *                    false to convert them too
     */
    private static void setCapitalWord(boolean capitalWord) {
        TitleCase.capitalWord = capitalWord;
    }

    /**
     * Method that configures exceptions, that is, the words that will be ignored
     * when converting to TitleCase. This method has Varargs as a parameter, and
     * therefore the way of passing multiple words is in the form of strings
     * separated by a comma or an array of strings.
     *
     * @param words Varargs with de words to be ignored
     */
    private static void setExceptions(String... words) {

        TitleCase.exceptions = Arrays.stream(words).parallel()
                .map(TitleCase::concatAllVariations)
                .collect(Collectors.joining(" "));
    }

    // Concat all variations possibles with a symbol library
    private static String concatAllVariations(String word) {
        return word.concat(withSymbols(word)).concat(withWraps(word));
    }

    private static String withSymbols(String word) {
        return Arrays.stream(SYMBOLS.split("")).parallel()
                .map(s -> String.format(" %s%s %s%s%s %s%s", s, word, s, word, s, word, s))
                .collect(Collectors.joining());
    }

    private static String withWraps(String word) {
        builder = new StringBuilder();
        for (int i = 0; i < RIGHT_WRAPS.length; i++) {
            builder.append(String.format(" %s%s%s", RIGHT_WRAPS[i], word, LEFT_WRAPS[i]));
        }
        return builder.toString();
    }

    // set of static variables used by this utility class
    private static String exceptions;
    private static boolean capitalWord;
    private static String theInput;
    private static String[] arrayWords;
    private static StringBuilder builder;
    private static final String SYMBOLS = "¬°!¬ø?‚∏ò‚ÄΩ‚Äú‚Äù‚Äò‚Äô‚Äõ‚Äü.,‚Äö‚Äû'\"‚Ä≤‚Ä≥¬¥Àù^¬∞¬∏Àõ¬®`ÀôÀö¬™¬∫‚Ä¶:;&_¬Ø¬ß#¬∂‚Ä†‚Ä°@%‚Ä∞‚Ä±¬¶|/\\ÀâÀÜÀòÀá~*‚ÄºÔ∏é‚Åá‚Åà‚ÅâÔ∏é‚ùõ‚ùú‚ùù‚ùû‚ù¢‚ù£‚ù°"
            + "$‚Ç¨¬•¬¢¬£‚ÇΩ‚Ç®‚Ç©‡∏ø‚Ç∫‚ÇÆ‚Ç±‚Ç≠‚Ç¥‚Ç¶‡ß≤‡ß≥‡´±‡ØπÔ∑º‚Çπ‚Ç≤‚Ç™‚Ç°‚Ç´·üõ‚Çµ‚Ç¢‚Ç∏‚Ç§‚Ç≥‚Ç•‚Ç†‚Ç£‚Ç∞‚Çß‚ÇØ‚Ç∂‚Ç∑¬Æ¬©‚Ñó‚Ñ¢‚Ñ†‚Ññ¬™¬∫‚Ñî‚Ñ•‚Ñ®‚Ñ¨‚Ñä¬µ‚ÑπÔ∏é‚Ñå‚Ñû‚Ñ≥‚ÑÉ‚Ñâ‚ÑÄ‚ÑÅ‚ÑÖ‚ÑÜ+√ó=‚àû‚Ñá‚àÄ‚àÅ‚àÉ‚àÑ‚àÖ‚àÜ‚àá<>‚â§‚â•‚àë‚®ã‚àö‚àõ‚àú‚à¨-";
    private static final String[] RIGHT_WRAPS = "‚Äπ¬´<‚ü®‚ü™‚ù®(‚ùÆ{[„Äî„Äê„Äñ‚ù™‚ù¥‚ù≤‚ù¨‚éß‚é°‚é®‚éú‚é¢‚é™‚é£‚éù‚é©¬°¬ø‚∏ò‚Äú‚Äò".split("");
    private static final String[] LEFT_WRAPS = "‚Ä∫¬ª>‚ü©‚ü´‚ù©)‚ùØ}]„Äï„Äë„Äó‚ù´‚ùµ‚ù≥‚ù≠‚é´‚é§‚é¨‚éü‚é•‚é™‚é¶‚é†‚é≠!?‚ÄΩ‚Äù‚Äô".split("");
    private static final String JUST_LETTERS = "^\\p{L}+$";
    private static final String CAPITAL_WORD = "^[\\p{Lu}\\p{Punct}\\p{N}]*$";
    private static final String UPPER_SENTENCE = "^\\s*[\\p{Lu}\\p{Punct}\\p{N}]+\\s*$";

}

package com.whatacook.cookers.utilities;

import jakarta.validation.Constraint;
import jakarta.validation.Payload;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.Pattern;

import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

/**
 * Annotation for validating email addresses.
 * Ensures emails are properly formatted.
 * <p>
 * Annotations:
 * - @Documented: Indicates that elements using this annotation should be documented by javadoc and similar tools.
 * - @Constraint: Specifies the validator class.
 * - @Target: Specifies the kinds of elements an annotation type can be applied to.
 * - @Retention: Specifies how long annotations with the annotated type are to be retained.
 * <p>
 * Fields:
 * - message: Custom error message for invalid email addresses.
 * - groups: Allows the specification of validation groups.
 * - payload: Can be used by clients to associate metadata with a given constraint declaration.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
@Documented
@Constraint(validatedBy = {}) // No necesita un validador personalizado
@Target({FIELD, METHOD, PARAMETER, ANNOTATION_TYPE})
@Retention(RUNTIME)
@Email(message = "Invalid email format")
@Pattern(regexp = "^[\\p{L}\\p{N}!#$%&'*+/=?^_`{|}~-]+(?:\\.[\\p{L}\\p{N}!#$%&'*+/=?^_`{|}~-]+)*@(?:[\\p{L}\\p{N}](?:[a-z0-9-]*[\\p{L}\\p{N}])?\\.)+[\\p{L}\\p{N}](?:[a-z0-9-]*[\\p{L}\\p{N}])?$")
public @interface ValidEmail {

    String message() default "Properly formatted email is required";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};
}

package com.whatacook.cookers.model.auth;

import com.whatacook.cookers.utilities.ValidEmail;
import jakarta.validation.constraints.NotBlank;
import lombok.*;

import java.io.Serial;
import java.io.Serializable;

/**
 * Data Transfer Object (DTO) for authentication requests.
 * Contains the username and password required for authentication.
 * <p>
 * Annotations:
 * - @NoArgsConstructor: Generates a no-arguments constructor.
 * - @AllArgsConstructor: Generates an all-arguments constructor.
 * - @Getter: Generates getter methods for all fields.
 * - @Setter: Generates setter methods for all fields.
 * - @ToString: Generates a toString method for the class.
 * - @EqualsAndHashCode: Generates equals and hashCode methods for the class.
 * <p>
 * Fields:
 * - serialVersionUID: Unique identifier for serializable classes.
 * - username: The username (email) of the user.
 * - password: The password of the user.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
@NoArgsConstructor
@AllArgsConstructor
@Getter
@Setter
@ToString
@EqualsAndHashCode
public class AuthRequestDto implements Serializable {
    @Serial
    private static final long serialVersionUID = -8635136711286938592L;

    @NotBlank(message = "username is mandatory!")
    @ValidEmail
    private String username;

    @NotBlank(message = "password is mandatory!")
    private String password;
}

package com.whatacook.cookers.model.auth;

import com.whatacook.cookers.model.users.UserDto;
import lombok.*;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;

import java.security.SecureRandom;
import java.time.LocalDateTime;
import java.util.Base64;

/**
 * Data Transfer Object (DTO) for account activation.
 * Contains the activation code and expiration time.
 * <p>
 * Annotations:
 * - @NoArgsConstructor: Generates a no-arguments constructor.
 * - @AllArgsConstructor: Generates an all-arguments constructor.
 * - @Getter: Generates getter methods for all fields.
 * - @Setter: Generates setter methods for all fields.
 * - @ToString: Generates a toString method for the class.
 * - @EqualsAndHashCode: Generates equals and hashCode methods for the class.
 * - @Document: Marks this class as a MongoDB document.
 * <p>
 * Fields:
 * - id: The unique identifier for the activation entity.
 * - code: The activation code.
 * - expiration: The expiration time of the activation code.
 * <p>
 * Methods:
 * - to(UserDto user): Converts a UserDto to an ActivationDto.
 * - generateCode(): Generates a secure random activation code.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
@NoArgsConstructor
@AllArgsConstructor
@Getter
@Setter
@ToString
@EqualsAndHashCode
@Document(collection = "activation")
public class ActivationDto {

    @Id
    private String id;
    private String code = generateCode();
    private LocalDateTime expiration = LocalDateTime.now();

    /**
     * Converts a UserDto to an ActivationDto.
     *
     * @param user The user to convert.
     * @return The corresponding ActivationDto.
     */
    public static ActivationDto to(UserDto user) {
        ActivationDto activationDto = new ActivationDto();
        activationDto.setId(user.get_id());
        return activationDto;
    }

    /**
     * Generates a secure random activation code.
     *
     * @return The generated activation code.
     */
    private String generateCode() {
        SecureRandom random = new SecureRandom();
        byte[] bytes = new byte[24];
        random.nextBytes(bytes);
        return Base64.getUrlEncoder().withoutPadding().encodeToString(bytes);
    }
}

package com.whatacook.cookers.model.auth;

import com.whatacook.cookers.model.users.UserDto;
import lombok.*;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;

import java.security.SecureRandom;
import java.time.LocalDateTime;
import java.util.Base64;

/**
 * Data Transfer Object (DTO) for password reset.
 * Contains the reset code and expiration time.
 * <p>
 * Annotations:
 * - @NoArgsConstructor: Generates a no-arguments constructor.
 * - @AllArgsConstructor: Generates an all-arguments constructor.
 * - @Getter: Generates getter methods for all fields.
 * - @Setter: Generates setter methods for all fields.
 * - @ToString: Generates a toString method for the class.
 * - @EqualsAndHashCode: Generates equals and hashCode methods for the class.
 * - @Document: Marks this class as a MongoDB document.
 * <p>
 * Fields:
 * - id: The unique identifier for the reset entity.
 * - code: The reset code.
 * - expiration: The expiration time of the reset code.
 * <p>
 * Methods:
 * - to(UserDto user): Converts a UserDto to a ResetDto.
 * - generateCode(): Generates a secure random reset code.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
@NoArgsConstructor
@AllArgsConstructor
@Getter
@Setter
@ToString
@EqualsAndHashCode
@Document(collection = "reset")
public class ResetDto {

    @Id
    private String id;
    private String code = generateCode();
    private LocalDateTime expiration = LocalDateTime.now();

    /**
     * Converts a UserDto to a ResetDto.
     *
     * @param user The user to convert.
     * @return The corresponding ResetDto.
     */
    public static ResetDto to(UserDto user) {
        var resetDto = new ResetDto();
        resetDto.setId(user.get_id());
        return resetDto;
    }

    /**
     * Generates a secure random reset code.
     *
     * @return The generated reset code.
     */
    private String generateCode() {
        SecureRandom random = new SecureRandom();
        byte[] bytes = new byte[64];
        random.nextBytes(bytes);
        return Base64.getUrlEncoder().withoutPadding().encodeToString(bytes);
    }
}

package com.whatacook.cookers.model.constants;

/**
 * Enumeration representing the different statuses an account can have.
 * <p>
 * Fields:
 * - PENDING: Account pending confirmation with a message.
 * - OK: Account activated with a message.
 * - OFF: Account deactivated with a message.
 * - OUTDATED: Password outdated with a message.
 * - REQUEST_DELETE: Account deletion requested with a message.
 * - MARKED_DELETE: Account marked for deletion with a message.
 * <p>
 * Methods:
 * - getDetails(): Returns the message associated with the status.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
public enum AccountStatus {

    PENDING("Falta confirmar el e-mail para activar la cuenta!"),
    OK("Cuenta activada correctamente!"),
    OFF("Cuenta desactivada, solicite activaci√≥n"),
    OUTDATED("Contrase√±a desactualizada, solicite actualizaci√≥n"),
    REQUEST_DELETE("Borrado de cuenta solicitado!"),
    MARKED_DELETE("Cuenta marcada para ser borrada!");

    private final String message;

    AccountStatus(String message) {
        this.message = message;
    }

    /**
     * Returns the message associated with the status.
     *
     * @return The status message.
     */
    public String getDetails() {
        return message;
    }
}

package com.whatacook.cookers.model.constants;

/**
 * Enumeration representing different HTML templates used in the application.
 * <p>
 * Templates:
 * - ActivationEmail: HTML template for account activation email.
 * - FailActivation: HTML template for failed account activation.
 * - SuccessActivation: HTML template for successful account activation.
 * - ResetPasswordMail: HTML template for password reset email.
 * - FailReset: HTML template for failed password reset.
 * - FormToSendNewPassword: HTML template for the form to send a new password.
 * - FailSetNewPassword: HTML template for failed password setting.
 * - SuccessSetNewPassword: HTML template for successful password setting.
 * <p>
 * Methods:
 * - get(): Returns the HTML code associated with the template.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
public enum Htmls {

    ActivationEmail("""
            <!DOCTYPE html>
            <html lang="es">
            <head>
                <meta charset="UTF-8">
                <title>Activaci√≥n de Cuenta</title>
            </head>
            <body style="text-align: center; font-family: Arial, sans-serif; color: #333;">
                <div style="max-width: 600px; margin: auto; padding: 20px; border: 1px solid #ddd; border-radius: 8px;">
                    <img src="LOGO_WAC" alt="Logo WhataCook" style="width: 100px; height: auto;"/>
                    <h1 style="color: #4F81BD;">Bienvenido a WhataCook, USER_NAME!</h1>
                    <p>Para activar su cuenta, por favor haga clic en el siguiente bot√≥n:</p>
                    <a href="ACTIVATION_LINK" style="background-color: #4F81BD; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px; display: inline-block;">Activar Cuenta</a>
                    <p style="font-size: 12px; margin-top: 15px;">Si no puede hacer clic en el bot√≥n, copie y pegue este enlace en su navegador:</p>
                    <p style="font-size: 12px;"><a href="ACTIVATION_LINK">ACTIVATION_LINK</a></p>
                </div>
            </body>
            </html>
            """
    ),
    FailActivation("""
                <!DOCTYPE html>
                    <html lang="es">
                    <head>
                        <meta charset="UTF-8">
                        <title>Activaci√≥n de Cuenta Fallida</title>
                    </head>
                    <body style="text-align: center; font-family: Arial, sans-serif; color: #333;">
                        <div style="max-width: 600px; margin: auto; padding: 20px; border: 1px solid #dda; border-radius: 8px; background-color: #FFEEDD;">
                            <img src="LOGO_WAC" alt="Logo WhataCook" style="width: 200px; height: auto; margin-bottom: 20px;"/>
                            <h1 style="color: #CC7700;">Lamentamos mucho, pero no fue posible activar su cuenta.</h1>
                            <p style="font-size: 17px">
                            Por favor, intenta activar tu cuenta nuevamente utilizando el enlace proporcionado en el correo electr√≥nico de activaci√≥n.</p>
                            <p style="font-size: 13px";>
                                Tambi√©n puede
                                <a href="PATH_TO_RESEND" style="color: #FFA500;">solicitar un nuevo c√≥digo de activaci√≥n</a>.</p>
                            <p style="font-size: 11px";>
                                Si sigues teniendo problemas,\s
                                <a href="mailto:EMAIL_WAC"" style="color: #FFA500;">contacta con soporte</a>.</p>
                        </div>
                    </body>
                    </html>
            """
    ),

    SuccessActivation("""
            <!DOCTYPE html>
                <html lang="es">
                <head>
                    <meta charset="UTF-8">
                    <title>Cuenta Activada</title>
                </head>
                <body style="text-align: center; font-family: Arial, sans-serif; color: #333;">
                    <div style="max-width: 600px; margin: auto; padding: 20px; border: 1px solid #ddd; border-radius: 8px;">
                        <img src="LOGO_WAC" alt="Logo WhataCook" style="width: 200px; height: auto; margin-bottom: 20px;"/>
                            <h1 style="color: #4F81BD;">¬°Hola, USER_NAME!</h1>
                                <h3>Su cuenta ha sido activada exitosamente.</h3>
                                    <p>Puede volver a la aplicaci√≥n y continuar con el inicio de sesi√≥n.</p>
                    </div>
                </body>
                </html>
            """
    ),

    ResetPasswordMail("""
            <!DOCTYPE html>
            <html lang="es">
            <head>
                <meta charset="UTF-8">
                <title>Restablecimiento de Contrase√±a</title>
            </head>
            <body style="text-align: center; font-family: Arial, sans-serif; color: #333;">
                <div style="max-width: 600px; margin: auto; padding: 20px; border: 1px solid #ddd; border-radius: 8px;">
                    <img src="LOGO_WAC" alt="Logo WhataCook" style="width: 100px; height: auto;"/>
                    <h1 style="color: #4F81BD;">¬°Hola, USER_NAME!</h1>
                    <h2 style="color: #4F81BD;">Restablecimiento de Contrase√±a</h2>
                    <p>Hemos recibido una solicitud para restablecer la contrase√±a de su cuenta.</p>
                    <p>Para restablecer su contrase√±a, haga clic en el siguiente bot√≥n:</p>
                    <a href="ACTIVATION_LINK" style="background-color: #4F81BD; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px; display: inline-block;">Restablecer Contrase√±a</a>
                    <p style="font-size: 12px; margin-top: 15px;">Si no solicit√≥ restablecer su contrase√±a, por favor ignore este correo.</p>
                    <p style="font-size: 12px;">Si tiene problemas para hacer clic en el bot√≥n, copie y pegue el siguiente enlace en su navegador:</p>
                    <p style="font-size: 12px;"><a href="ACTIVATION_LINK">ACTIVATION_LINK</a></p>
                </div>
            </body>
            </html>
            """
    ),

    FailReset("""
                <!DOCTYPE html>
                    <html lang="es">
                    <head>
                        <meta charset="UTF-8">
                        <title>Reinicio de Contrase√±a Fallido</title>
                    </head>
                    <body style="text-align: center; font-family: Arial, sans-serif; color: #333;">
                        <div style="max-width: 600px; margin: auto; padding: 20px; border: 1px solid #dda; border-radius: 8px; background-color: #FFEEDD;">
                            <img src="LOGO_WAC" alt="Logo WhataCook" style="width: 200px; height: auto; margin-bottom: 20px;"/>
                            <h1 style="color: #CC7700;">No fue posible procesar tu solicitud de reinicio de contrase√±a.</h1>
                            <p style="font-size: 17px">
                            Por favor, intenta reiniciar tu contrase√±a nuevamente utilizando el enlace proporcionado en el correo electr√≥nico de reinicio.</p>
                            <p style="font-size: 13px";>
                                Si sigues teniendo problemas,\s
                                <a href="mailto:EMAIL_WAC" style="color: #FFA500;">contacta con soporte</a>.</p>
                                <input type="hidden" id="errorDescription" value="errorDescriptionValue">
                        </div>
                    </body>
                    </html>
            """
    ),

    FormToSendNewPassword("""
            <!DOCTYPE html>
            <html lang="es">
            <head>
                <meta charset="UTF-8">
                <title>Restablecimiento de Contrase√±a</title>
                <script>
                    window.onload = function() {
                        document.getElementById("resetPasswordForm").addEventListener('submit', function(e) {
                            e.preventDefault();
                        
                            var userId = document.getElementById('user_id').value;
                            var newPassword = document.getElementById("newPassword").value;
                            var confirmPassword = document.getElementById("confirmPassword").value;
                            var regex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!¬°|'¬¥`¬®^*+@¬∑#$%&/{}()=-_:.;,<>?¬ø])[A-Za-z\\d!¬°|'¬¥`¬®^*+@¬∑#$%&/{}()=-_:.;,<>?¬ø]{8,}$/;
                        
                            // Verifica si las contrase√±as coinciden
                            if (newPassword !== confirmPassword) {
                                alert("Las contrase√±as no coinciden.");
                                return;
                            } else if (!regex.test(newPassword)) {
                                alert("La contrase√±a no cumple con los requisitos m√≠nimos.");
                                return;
                            }
                        
                        
                        
                            var data = {
                                "_id": userId,
                                "newPassword": newPassword
                            };
                        
                        
                            fetch('ENDPOINT_RESET_PASS', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify(data)
                            })
                            .then(response => {
                                if (!response.ok) {
                                    throw new Error('Network response was not ok');
                                }
                                return response.json();
                            })
                            .then(data => {
                                // Manejar respuesta del servidor
                                console.log('Success:', data);
                            })
                            .catch((error) => {
                                console.error('Error:', error);
                            });
                        
                        });
                    };
                </script>
            </head>
            <body style="text-align: center; font-family: Arial, sans-serif; color: #333;">
                <div style="max-width: 600px; margin: auto; padding: 20px; border: 1px solid #ddd; border-radius: 8px;">
                    <img src="LOGO_WAC" alt="Logo WhataCook" style="width: 100px; height: auto;"/>
                    <h1 style="color: #4F81BD;">¬°Hola!</h1>
                    <h2 style="color: #4F81BD;">Restablecimiento de Contrase√±a</h2>
                    <p>Hemos recibido una solicitud para restablecer la contrase√±a de su cuenta.</p>
                    <form id="resetPasswordForm" action="ENDPOINT_RESET_PASS" method="POST">
                        <input type="hidden" id="user_id" value="RESET_CODE">
                        <p>Por favor, ingrese su nueva contrase√±a:</p>
                        <input type="password" id="newPassword" name="newPassword" placeholder="Nueva Contrase√±a" required>
                        <input type="password" id="confirmPassword" placeholder="Confirmar Nueva Contrase√±a" required>
                        <div style="margin-top: 20px;">
                            <button type="submit" style="background-color: #4F81BD; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px; display: inline-block;">Restablecer Contrase√±a</button>
                        </div>
                    </form>
                    <p style="font-size: 12px; margin-top: 15px;">Si no solicit√≥ restablecer su contrase√±a, por favor ignore este correo.</p>
                </div>
            </body>
            </html>
            """
    ),

    FailSetNewPassword("""
                <!DOCTYPE html>
                    <html lang="es">
                    <head>
                        <meta charset="UTF-8">
                        <title>Restabelecer nueva contrase√±a</title>
                    </head>
                    <body style="text-align: center; font-family: Arial, sans-serif; color: #333;">
                        <div style="max-width: 600px; margin: auto; padding: 20px; border: 1px solid #dda; border-radius: 8px; background-color: #FFEEDD;">
                            <img src="LOGO_WAC" alt="Logo WhataCook" style="width: 200px; height: auto; margin-bottom: 20px;"/>
                            <h1 style="color: #CC7700;">Lamentamos mucho, pero no fue posible restabelecer su contrase√±a.</h1>
                            <p style="font-size: 17px">
                            Por favor, intenta restabelecer su contrase√±a nuevamente utilizando el enlace proporcionado en el correo electr√≥nico de restabelicimiento.</p>
                            <p style="font-size: 13px";>
                                Tambi√©n puede
                                <a href="URL_FORGOT_PASS" style="color: #FFA500;">solicitar un nuevo c√≥digo de activaci√≥n</a>.</p>
                            <p style="font-size: 11px";>
                                Si sigues teniendo problemas,s
                                <a href="mailto:EMAIL_WAC" style="color: #FFA500;">contacta con soporte</a>.</p>
                                <input type="hidden" id="errorDescription" value="errorDescriptionValue">
                        </div>
                    </body>
                    </html>
            """
    ),
    SuccessSetNewPassword("""
                <!DOCTYPE html>
                    <html lang="es">
                    <head>
                        <meta charset="UTF-8">
                        <title>Contrase√±a Restabelecida</title>
                    </head>
                    <body style="text-align: center; font-family: Arial, sans-serif; color: #333;">
                        <div style="max-width: 600px; margin: auto; padding: 20px; border: 1px solid #ddd; border-radius: 8px;">
                            <img src="LOGO_WAC" alt="Logo WhataCook" style="width: 200px; height: auto; margin-bottom: 20px;"/>
                                <h1 style="color: #4F81BD;">¬°Hola, USER_NAME!</h1>
                                    <h3>Su contrase√±a ha sido restabelecida exitosamente.</h3>
                                        <p>Puede volver a la aplicaci√≥n y continuar con el inicio de sesi√≥n.</p>
                        </div>
                    </body>
                    </html>
            """
    );

    Htmls(String code) {
        this.code = code;
    }

    private final String code;

    public String get() {
        return code;
    }
}

package com.whatacook.cookers.model.constants;

/**
 * Enumeration representing the different roles a user can have.
 * <p>
 * Fields:
 * - BASIC: Basic user role.
 * - SUBSCRIBER: Subscriber role with premium privileges.
 * - CHIEF: Administrator role.
 * - FULL: Full access role with all privileges.
 * <p>
 * Methods:
 * - get(): Returns the role string associated with the role.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
public enum Role {

    BASIC("USER"), SUBSCRIBER("USER,PREMIUM"), CHIEF("ADMIN"), FULL("ADMIN,USER,PREMIUM");

    private final String role;

    Role(String role) {
        this.role = role;
    }

    /**
     * Returns the role string associated with the role.
     *
     * @return The role string.
     */
    public String get() {
        return role;
    }
}

package com.whatacook.cookers.model.favorites;

import lombok.*;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;
import reactor.core.publisher.Mono;

import java.util.List;

/**
 * Data Transfer Object (DTO) for Favorite entity.
 * Represents the favorite recipes and ingredients for a user.
 * <p>
 * Annotations:
 * - @NoArgsConstructor: Generates a no-arguments constructor.
 * - @AllArgsConstructor: Generates an all-arguments constructor.
 * - @Getter: Generates getter methods for all fields.
 * - @Setter: Generates setter methods for all fields.
 * - @ToString: Generates a toString method for the class.
 * - @EqualsAndHashCode: Generates equals and hashCode methods for the class.
 * - @Document: Marks this class as a MongoDB document.
 * <p>
 * Fields:
 * - id: The unique identifier for the favorite entity.
 * - recipes: A list of recipe IDs that are marked as favorites.
 * - ingredients: A list of ingredient IDs that are marked as favorites.
 * <p>
 * Methods:
 * - addRecipe(String recipeId): Adds a recipe to the list of favorite recipes.
 * - removeRecipe(String recipeId): Removes a recipe from the list of favorite recipes.
 * - containsRecipe(String recipeId): Checks if a recipe is in the list of favorite recipes.
 * - notContainsRecipe(String recipeId): Checks if a recipe is not in the list of favorite recipes.
 * - addIngredient(String ingredientId): Adds an ingredient to the list of favorite ingredients.
 * - removeIngredient(String ingredientId): Removes an ingredient from the list of favorite ingredients.
 * - containsFavoriteIngredient(String ingredientId): Checks if an ingredient is in the list of favorite ingredients.
 * - notContainsFavoriteIngredient(String ingredientId): Checks if an ingredient is not in the list of favorite ingredients.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
@NoArgsConstructor
@AllArgsConstructor
@Getter
@Setter
@ToString
@EqualsAndHashCode
@Document(collection = "favorite")
public class FavoriteDto {

    @Id
    private String id;
    private List<String> recipes;
    private List<String> ingredients;

    /**
     * Adds a recipe to the list of favorite recipes if not already present.
     *
     * @param recipeId The ID of the recipe to add.
     * @return A Mono emitting this FavoriteDto.
     */
    public Mono<FavoriteDto> addRecipe(String recipeId) {
        return Mono.just(recipeId)
                .filterWhen(this::notContainsRecipe)
                .doOnNext(recipes::add)
                .thenReturn(this);
    }

    /**
     * Removes a recipe from the list of favorite recipes.
     *
     * @param recipeId The ID of the recipe to remove.
     * @return A Mono emitting this FavoriteDto.
     */
    public Mono<FavoriteDto> removeRecipe(String recipeId) {
        return Mono.just(recipeId)
                .doOnNext(recipes::remove)
                .thenReturn(this);
    }

    /**
     * Checks if a recipe is in the list of favorite recipes.
     *
     * @param recipeId The ID of the recipe to check.
     * @return A Mono emitting true if the recipe is in the list, otherwise false.
     */
    public Mono<Boolean> containsRecipe(String recipeId) {
        return Mono.just(recipes.contains(recipeId));
    }

    /**
     * Checks if a recipe is not in the list of favorite recipes.
     *
     * @param recipeId The ID of the recipe to check.
     * @return A Mono emitting true if the recipe is not in the list, otherwise false.
     */
    public Mono<Boolean> notContainsRecipe(String recipeId) {
        return containsRecipe(recipeId).map(exists -> !exists);
    }

    /**
     * Adds an ingredient to the list of favorite ingredients if not already present.
     *
     * @param ingredientId The ID of the ingredient to add.
     * @return A Mono emitting this FavoriteDto.
     */
    public Mono<FavoriteDto> addIngredient(String ingredientId) {
        return Mono.just(ingredientId)
                .filterWhen(this::notContainsFavoriteIngredient)
                .doOnNext(ingredients::add)
                .thenReturn(this);
    }

    /**
     * Removes an ingredient from the list of favorite ingredients.
     *
     * @param ingredientId The ID of the ingredient to remove.
     * @return A Mono emitting this FavoriteDto.
     */
    public Mono<FavoriteDto> removeIngredient(String ingredientId) {
        return Mono.just(ingredientId)
                .doOnNext(ingredients::remove)
                .thenReturn(this);
    }

    /**
     * Checks if an ingredient is in the list of favorite ingredients.
     *
     * @param ingredientId The ID of the ingredient to check.
     * @return A Mono emitting true if the ingredient is in the list, otherwise false.
     */
    public Mono<Boolean> containsFavoriteIngredient(String ingredientId) {
        return Mono.just(ingredients.contains(ingredientId));
    }

    /**
     * Checks if an ingredient is not in the list of favorite ingredients.
     *
     * @param ingredientId The ID of the ingredient to check.
     * @return A Mono emitting true if the ingredient is not in the list, otherwise false.
     */
    public Mono<Boolean> notContainsFavoriteIngredient(String ingredientId) {
        return containsFavoriteIngredient(ingredientId).map(exists -> !exists);
    }
}

package com.whatacook.cookers.model.favorites;

import com.whatacook.cookers.model.users.UserJson;
import lombok.*;

/**
 * Request object for managing user favorites.
 * Inherits from UserJson and adds fields for user ID, recipe ID, and ingredient ID.
 * <p>
 * Annotations:
 * - @NoArgsConstructor: Generates a no-arguments constructor.
 * - @AllArgsConstructor: Generates an all-arguments constructor.
 * - @Getter: Generates getter methods for all fields.
 * - @Setter: Generates setter methods for all fields.
 * - @ToString: Generates a toString method for the class.
 * - @EqualsAndHashCode: Generates equals and hashCode methods for the class.
 * <p>
 * Fields:
 * - userId: The unique identifier for the user.
 * - recipeId: The ID of the recipe to add/remove from favorites.
 * - ingredientId: The ID of the ingredient to add/remove from favorites.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
@NoArgsConstructor
@AllArgsConstructor
@Getter
@Setter
@ToString
@EqualsAndHashCode(callSuper = true)
public class FavoriteRequest extends UserJson {

    private String userId;
    private String recipeId;
    private String ingredientId;

    /**
     * Gets the user ID.
     *
     * @return The user ID.
     */
    public String get_id() {
        return userId;
    }
}

package com.whatacook.cookers.model.responses;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.whatacook.cookers.model.exceptions.UserServiceException;
import jakarta.annotation.Nullable;
import reactor.core.publisher.Mono;

import java.util.HashMap;

import static com.whatacook.cookers.utilities.Util.notNullOrEmpty;

/**
 * Standard response structure for API responses.
 * Provides methods to create success and error responses.
 * <p>
 * Annotations:
 * - @SuppressWarnings: Suppresses the specified compiler warnings.
 * - @JsonPropertyOrder: Defines the order of properties in JSON serialization.
 * - @JsonInclude: Specifies inclusion criteria for JSON serialization.
 * <p>
 * Methods:
 * - error(String message): Creates an error response with a message.
 * - monoError(String message): Creates a Mono wrapping an error response with a message.
 * - monoError(Exception e): Creates a Mono wrapping an error response from an exception.
 * - monoError(Throwable e): Creates a Mono wrapping an error response from a throwable.
 * - error(String message, @Nullable Object content): Creates an error response with a message and additional content.
 * - monoError(String message, @Nullable Object content): Creates a Mono wrapping an error response with a message and additional content.
 * - monoError(UserServiceException e): Creates a Mono wrapping an error response from a UserServiceException.
 * - success(String message, @Nullable Object content): Creates a success response with a message and additional content.
 * - setMessage(String message): Sets the message if it's not null or empty.
 * - getMessage(): Gets the message from the response.
 * - isSuccess(): Checks if the response indicates success.
 * - getContent(): Gets the content from the response.
 * - addMessage(String message): Adds a message to the response.
 * - toString(): Returns the string representation of the response.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
@SuppressWarnings("unused")
@JsonPropertyOrder({"success", "message"})
@JsonInclude(JsonInclude.Include.NON_NULL)
public class Response {

    /**
     * Creates an error response with a message.
     *
     * @param message The error message.
     * @return A Response object indicating an error.
     */
    public static Response error(String message) {
        Response response = new Response();
        response.put(SUCCESS, false);
        response.put(MESSAGE, setMessage(message));
        return response;
    }

    /**
     * Creates a Mono wrapping an error response with a message.
     *
     * @param message The error message.
     * @return A Mono wrapping a Response object indicating an error.
     */
    public static Mono<Response> monoError(String message) {
        return Mono.just(error(message));
    }

    /**
     * Creates a Mono wrapping an error response from an exception.
     *
     * @param e The exception.
     * @return A Mono wrapping a Response object indicating an error.
     */
    public static Mono<Response> monoError(Exception e) {
        return monoError(e.getMessage());
    }

    /**
     * Creates a Mono wrapping an error response from a throwable.
     *
     * @param e The throwable.
     * @return A Mono wrapping a Response object indicating an error.
     */
    public static Mono<Response> monoError(Throwable e) {
        return monoError(e.getMessage());
    }

    /**
     * Creates an error response with a message and additional content.
     *
     * @param message The error message.
     * @param content The additional content.
     * @return A Response object indicating an error.
     */
    public static Response error(String message, @Nullable Object content) {
        Response response = error(message);
        if (content != null)
            response.put(CONTENT, content);
        return response;
    }

    /**
     * Creates a Mono wrapping an error response with a message and additional content.
     *
     * @param message The error message.
     * @param content The additional content.
     * @return A Mono wrapping a Response object indicating an error.
     */
    public static Mono<Response> monoError(String message, @Nullable Object content) {
        return Mono.just(error(message, content));
    }

    /**
     * Creates a Mono wrapping an error response from a UserServiceException.
     *
     * @param e The UserServiceException.
     * @return A Mono wrapping a Response object indicating an error.
     */
    public static Mono<Response> monoError(UserServiceException e) {
        return monoError(e.getMessage(), e.getErrors());
    }

    /**
     * Creates a success response with a message and additional content.
     *
     * @param message The success message.
     * @param content The additional content.
     * @return A Response object indicating success.
     */
    public static Response success(String message, @Nullable Object content) {
        Response response = new Response();
        response.put(SUCCESS, true);
        response.put(MESSAGE, setMessage(message));
        if (content != null)
            response.put(CONTENT, content);
        return response;
    }

    /**
     * Sets the message if it's not null or empty.
     *
     * @param message The message to set.
     * @return The message if not null or empty, otherwise a default error message.
     */
    public static String setMessage(String message) {
        return (notNullOrEmpty(message)) ? message : MESSAGE_ERROR;
    }

    /**
     * Gets the message from the response.
     *
     * @return The message from the response.
     */
    public String getMessage() {
        return (get(MESSAGE) == null) ? MESSAGE_ERROR : (String) get(MESSAGE);
    }

    /**
     * Checks if the response indicates success.
     *
     * @return True if the response indicates success, otherwise false.
     */
    public boolean isSuccess() {
        return (boolean) get(SUCCESS);
    }

    /**
     * Gets the content from the response.
     *
     * @return The content from the response.
     */
    public Object getContent() {
        return map.containsKey(CONTENT) ? map.get(CONTENT) : map.remove(CONTENT);
    }

    /**
     * Adds a message to the response.
     *
     * @param message The message to add.
     */
    public void addMessage(String message) {
        if (notNullOrEmpty(message))
            this.put(MESSAGE, this.get(MESSAGE) + message);
    }

    @Override
    public String toString() {
        return this.map.toString();
    }

    private Response() {
        map = new HashMap<>();
    }

    private void put(String key, Object value) {
        map.put(key, value);
    }

    private Object get(String key) {
        return map.get(key);
    }

    private final HashMap<String, Object> map;
    private final static String MESSAGE_ERROR = "Sorry, this Response has no message!";
    private final static String SUCCESS = "success";
    private final static String MESSAGE = "message";
    private final static String CONTENT = "content";
}

package com.whatacook.cookers.model.exceptions;

import lombok.Getter;
import reactor.core.publisher.Mono;

import java.io.Serial;
import java.util.Map;

/**
 * Custom exception for user service-related errors.
 * This exception provides additional context by allowing errors to be stored in a map.
 * <p>
 * Fields:
 * - serialVersionUID: Unique identifier for serializable classes.
 * - errors: A map containing error details.
 * <p>
 * Methods:
 * - UserServiceException(String message): Constructor with a message.
 * - UserServiceException(String message, Map<String, Object> errors): Constructor with a message and error details.
 * - <T> Mono<T> mono(String message): Creates a Mono that emits this exception with a message.
 * - <T> Mono<T> mono(String message, Map<String, Object> errors): Creates a Mono that emits this exception with a message and error details.
 * - <T> Mono<T> mono(Throwable e): Creates a Mono that emits this exception based on another throwable.
 * - void doOnErrorMap(Throwable throwable): Throws this exception based on another throwable.
 * - Throwable onErrorMap(Throwable throwable): Returns this exception based on another throwable.
 * - UserServiceException passNotMatch(): Returns a new instance of this exception indicating a password mismatch.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
@Getter
public final class UserServiceException extends RuntimeException {

    @Serial
    private static final long serialVersionUID = -1266524152146144087L;
    private Map<String, Object> errors;

    /**
     * Constructs a new UserServiceException with the specified detail message.
     *
     * @param message The detail message.
     */
    public UserServiceException(String message) {
        super(message);
    }

    /**
     * Constructs a new UserServiceException with the specified detail message and errors.
     *
     * @param message The detail message.
     * @param errors  The errors map.
     */
    public UserServiceException(String message, Map<String, Object> errors) {
        super(message);
        this.errors = errors;
    }

    /**
     * Creates a Mono that emits this exception with the specified message.
     *
     * @param message The detail message.
     * @param <T>     The type parameter.
     * @return A Mono that emits this exception.
     */
    public static <T> Mono<T> mono(String message) {
        return Mono.error(new UserServiceException(message));
    }

    /**
     * Creates a Mono that emits this exception with the specified message and errors.
     *
     * @param message The detail message.
     * @param errors  The errors map.
     * @param <T>     The type parameter.
     * @return A Mono that emits this exception.
     */
    public static <T> Mono<T> mono(String message, Map<String, Object> errors) {
        return Mono.error(new UserServiceException(message, errors));
    }

    /**
     * Creates a Mono that emits this exception based on another throwable.
     *
     * @param e   The throwable to base the exception on.
     * @param <T> The type parameter.
     * @return A Mono that emits this exception.
     */
    public static <T> Mono<T> mono(Throwable e) {
        return Mono.error(new UserServiceException(e.getMessage()));
    }

    /**
     * Throws this exception based on another throwable.
     *
     * @param throwable The throwable to base the exception on.
     */
    public static void doOnErrorMap(Throwable throwable) {
        throw new UserServiceException(throwable.getMessage());
    }

    /**
     * Returns this exception based on another throwable.
     *
     * @param throwable The throwable to base the exception on.
     * @return This exception.
     */
    public static Throwable onErrorMap(Throwable throwable) {
        return new UserServiceException(throwable.getMessage());
    }

    /**
     * Returns a new instance of this exception indicating a password mismatch.
     *
     * @return A new UserServiceException indicating a password mismatch.
     */
    public static UserServiceException passNotMatch() {
        return new UserServiceException("Password doesn't match!");
    }
}

package com.whatacook.cookers.model.users;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.whatacook.cookers.utilities.ValidEmail;
import com.whatacook.cookers.utilities.ValidPassword;
import jakarta.validation.constraints.*;
import lombok.*;

import java.time.LocalDate;

import static com.whatacook.cookers.utilities.Util.encryptPassword;

/**
 * Representation of user data for saving purposes.
 * Used to transfer user data from input forms to the UserDto entity.
 * <p>
 * Annotations:
 * - @NoArgsConstructor: Generates a no-arguments constructor.
 * - @Getter: Generates getter methods for all fields.
 * - @Setter: Generates setter methods for all fields.
 * - @ToString: Generates a toString method for the class.
 * - @JsonInclude: Specifies inclusion criteria for JSON serialization.
 * - @JsonIgnoreProperties: Specifies properties to ignore during JSON serialization.
 * <p>
 * Fields:
 * - email: The email address of the user.
 * - password: The password of the user.
 * - firstName: The first name of the user.
 * - surNames: The surnames of the user.
 * - birthdate: The birthdate of the user.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
@NoArgsConstructor
@Getter
@Setter
@ToString
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonIgnoreProperties(value = {"password"}, allowSetters = true)
public class UserJustToSave {

    @NotBlank(message = "Email is mandatory")
    @ValidEmail
    private String email;

    @NotBlank(message = "Password is mandatory")
    @ValidPassword
    private String password;

    @NotBlank(message = "FirstName is mandatory")
    @NotNull
    @NotEmpty
    private String firstName;

    @NotBlank(message = "Surnames is mandatory")
    @NotNull
    @NotEmpty
    private String surNames;

    @NotNull(message = "Birthdate is mandatory")
    @Past(message = "The date must be in the past")
    private LocalDate birthdate;

    /**
     * Converts this UserJustToSave to a UserDto object.
     *
     * @return A UserDto object representing this UserJustToSave.
     */
    public UserDto toUserDTO() {

        UserDto userDTO = new UserDto();

        userDTO.setEmail(email);
        userDTO.setPassword(encryptPassword(password));
        userDTO.setFirstName(firstName);
        userDTO.setSurNames(surNames);
        userDTO.setBirthdate(birthdate);

        return userDTO;
    }

}

package com.whatacook.cookers.model.users;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.whatacook.cookers.utilities.ValidEmail;
import com.whatacook.cookers.utilities.ValidPassword;
import jakarta.validation.constraints.NotBlank;
import lombok.*;

import java.time.LocalDate;
import java.time.LocalDateTime;

/**
 * JSON representation of the User entity.
 * Used for serialization and deserialization of user data.
 * <p>
 * Annotations:
 * - @NoArgsConstructor: Generates a no-arguments constructor.
 * - @Getter: Generates getter methods for all fields.
 * - @Setter: Generates setter methods for all fields.
 * - @ToString: Generates a toString method for the class.
 * - @EqualsAndHashCode: Generates equals and hashCode methods for the class.
 * - @JsonInclude: Specifies inclusion criteria for JSON serialization.
 * - @JsonIgnoreProperties: Specifies properties to ignore during JSON serialization.
 * <p>
 * Fields:
 * - _id: The unique identifier for the user.
 * - registration: The registration date and time of the user.
 * - email: The email address of the user.
 * - password: The password of the user.
 * - newPassword: The new password for the user.
 * - firstName: The first name of the user.
 * - surNames: The surnames of the user.
 * - birthdate: The birthdate of the user.
 * - roleType: The role type of the user.
 * - accountStatus: The account status of the user.
 * - accountStatusMsg: The message describing the account status.
 * - requestDeleteDate: The date and time when the user requested account deletion.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
@NoArgsConstructor
@Getter
@Setter
@ToString
@EqualsAndHashCode
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonIgnoreProperties(value = {"password"}, allowSetters = true)
public class UserJson {

    private String _id;

    private LocalDateTime registration;

    @NotBlank(message = "Email is mandatory")
    @ValidEmail
    private String email;

    @ValidPassword
    private String password;

    @ValidPassword
    private String newPassword;

    private String firstName;
    private String surNames;
    private LocalDate birthdate;
    private String roleType;
    private String accountStatus;
    private String accountStatusMsg;
    private LocalDateTime requestDeleteDate;

    /**
     * Constructs a UserJson object from a UserDto object.
     *
     * @param userDTO The UserDto object to convert.
     */
    public UserJson(UserDto userDTO) {

        if (userDTO.get_id() != null)
            this._id = userDTO.get_id();
        this.registration = userDTO.getRegistration();
        this.email = userDTO.getEmail();
        this.firstName = userDTO.getFirstName();
        this.surNames = userDTO.getSurNames();
        this.birthdate = userDTO.getBirthdate();
        this.roleType = userDTO.getRoleType().get();
        this.accountStatus = userDTO.getAccountStatus().toString();
        this.accountStatusMsg = userDTO.getAccountStatus().getDetails();
        this.requestDeleteDate = userDTO.getRequestDeleteDate();
    }

    /**
     * Constructs a UserJson object with a given ID.
     *
     * @param id The ID of the user.
     */
    public UserJson(String id) {
        _id = id;
    }

    /**
     * Creates a UserJson object from a UserDto object.
     *
     * @param userDTO The UserDto object to convert.
     * @return A UserJson object.
     */
    public static UserJson from(UserDto userDTO) {
        return new UserJson(userDTO);
    }

}

package com.whatacook.cookers.model.users;

import com.whatacook.cookers.model.constants.AccountStatus;
import com.whatacook.cookers.model.constants.Role;
import com.whatacook.cookers.utilities.ValidEmail;
import com.whatacook.cookers.utilities.ValidPassword;
import jakarta.validation.constraints.NotBlank;
import lombok.*;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;

import java.time.LocalDate;
import java.time.LocalDateTime;

/**
 * Data Transfer Object (DTO) for User entity.
 * Represents the user data stored in the database.
 * <p>
 * Annotations:
 * - @NoArgsConstructor: Generates a no-arguments constructor.
 * - @AllArgsConstructor: Generates an all-arguments constructor.
 * - @Getter: Generates getter methods for all fields.
 * - @Setter: Generates setter methods for all fields.
 * - @ToString: Generates a toString method for the class.
 * - @EqualsAndHashCode: Generates equals and hashCode methods for the class.
 * - @Document: Marks this class as a MongoDB document.
 * <p>
 * Fields:
 * - _id: The unique identifier for the user.
 * - registration: The registration date and time of the user.
 * - email: The email address of the user.
 * - password: The password of the user.
 * - firstName: The first name of the user.
 * - surNames: The surnames of the user.
 * - birthdate: The birthdate of the user.
 * - roleType: The role type of the user.
 * - accountStatus: The account status of the user.
 * - requestDeleteDate: The date and time when the user requested account deletion.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
@NoArgsConstructor
@AllArgsConstructor
@Getter
@Setter
@ToString
@EqualsAndHashCode
@Document(collection = "users")
public class UserDto {

    @Id
    private String _id;

    private LocalDateTime registration = LocalDateTime.now();

    @NotBlank(message = "Email is mandatory")
    @ValidEmail
    private String email;

    @ValidPassword
    private String password;

    private String firstName;

    private String surNames;

    private LocalDate birthdate;

    private Role roleType = Role.BASIC;

    private AccountStatus accountStatus = AccountStatus.PENDING;

    private LocalDateTime requestDeleteDate;

    /**
     * Converts this UserDto to a UserJson object.
     *
     * @return A UserJson object representing this UserDto.
     */
    public UserJson toJson() {
        return UserJson.from(this);
    }

    /**
     * Converts this UserDto to a UserJson object without the ID.
     *
     * @return A UserJson object representing this UserDto without the ID.
     */
    public UserJson toJsonWithoutId() {
        this.set_id(null);
        return UserJson.from(this);
    }

}

package com.whatacook.cookers;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * Main class for the WhataCook Users Application.
 * This class initializes and runs the Spring Boot application.
 * <p>
 * Annotations:
 * - @SpringBootApplication: Indicates that this is a Spring Boot application.
 * <p>
 * Methods:
 * - main(String[] args): Main method that serves as the entry point of the application.
 * It runs the Spring Boot application using SpringApplication.run.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
@SpringBootApplication
public class WhataCookUsersApplication {

    public static void main(String[] args) {
        SpringApplication.run(WhataCookUsersApplication.class, args);
    }

}

package com.whatacook.cookers.service;

import com.whatacook.cookers.model.exceptions.UserServiceException;
import com.whatacook.cookers.model.responses.Response;
import com.whatacook.cookers.model.users.UserJson;
import com.whatacook.cookers.service.components.*;
import com.whatacook.cookers.service.contracts.UserAccessContractModel;
import lombok.AllArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

import static com.whatacook.cookers.model.responses.Response.error;
import static com.whatacook.cookers.model.responses.Response.success;
import static com.whatacook.cookers.utilities.Util.convertToJsonAsString;

/**
 * Service class for managing user operations such as authentication, registration, and user information updates.
 * <p>
 * Annotations:
 * - @AllArgsConstructor: Generates a constructor with 1 parameter for each field.
 * - @Service: Indicates that this class is a Spring service.
 * <p>
 * Fields:
 * - read: Component for reading user information.
 * - update: Component for updating user information.
 * - delete: Component for deleting user information.
 * - login: Component for login operations.
 * - activate: Component for account activation operations.
 * - resetComponent: Component for password reset operations.
 * <p>
 * Methods:
 * - existsByEmail(UserJson userJson): Checks if a user exists by email.
 * - activateAccount(String activationCode): Activates a user account using an activation code.
 * - resendActivateCode(String email): Resends the activation code to a user's email.
 * - resetPasswordByCode(String resetCode): Resets a user's password using a reset code.
 * - setNewPasswordByCode(UserJson userJson): Sets a new password for a user using a reset code.
 * - readOne(UserJson userJson): Reads a user's information.
 * - updateOne(UserJson userJson): Updates a user's information.
 * - deleteOne(UserJson userJson): Deletes a user's information.
 * - findByUsername(String userEmailOrId): Finds a user by username (email or ID).
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 * @see FindComponent
 * @see UpdateComponent
 * @see DeleteComponent
 * @see LoginComponent
 * @see ActivateComponent
 * @see ResetComponent
 * @see UserAccessContractModel
 * @see Response
 * @see UserJson
 * @see Mono
 * @see AllArgsConstructor
 * @see Service
 */
@AllArgsConstructor
@Service
public final class UserService implements UserAccessContractModel {
    private final FindComponent read;
    private final UpdateComponent update;
    private final DeleteComponent delete;
    private final LoginComponent login;
    private final ActivateComponent activate;
    private final ResetComponent resetComponent;

    /**
     * Checks if a user exists by email.
     *
     * @param userJson the user details
     * @return a response indicating whether the user exists
     */
    @Override
    public Mono<Response> existsByEmail(UserJson userJson) {
        return read.checkIfExistsByEmail(userJson)
                .map(alreadyExists -> alreadyExists
                        ? success("User already exists", true)
                        : success("User does not exist yet", false))
                .onErrorResume(UserServiceException.class, Response::monoError)
                .onErrorResume(Exception.class, Response::monoError);
    }

    /**
     * Activates a user account using an activation code.
     *
     * @param activationCode the activation code
     * @return a response entity indicating the result of the activation
     */
    public Mono<ResponseEntity<String>> activateAccount(String activationCode) {
        return activate.byActivationCodeSentByEmail(activationCode)
                .map(ResponseEntity::ok)
                .onErrorResume(UserServiceException.class, uEx ->
                        Mono.just(ResponseEntity.badRequest()
                                .body(error(uEx.getMessage(), uEx.getErrors()).toString()))
                )
                .onErrorResume(Exception.class, ex ->
                        Mono.just(ResponseEntity.badRequest()
                                .body(error(ex.getMessage()).toString())));

    }

    /**
     * Resends the activation code to a user's email.
     *
     * @param email the user's email
     * @return a response indicating whether the activation code was resent successfully
     */
    public Mono<Response> resendActivateCode(String email) {
        return activate.resendActivationCode(email)
                .map(resended -> success("Activation mail successfully resented", resended))
                .onErrorResume(UserServiceException.class, Response::monoError)
                .onErrorResume(Exception.class, Response::monoError);
    }

    /**
     * Resets a user's password using a reset code.
     *
     * @param resetCode the reset code
     * @return a response entity indicating the result of the password reset
     */
    public Mono<ResponseEntity<String>> resetPasswordByCode(String resetCode) {
        return resetComponent.resetPasswordByCodeAndReturnNewPassForm(resetCode)
                .map(ResponseEntity::ok)
                .onErrorResume(UserServiceException.class, uEx ->
                        Mono.just(ResponseEntity.badRequest()
                                .body(convertToJsonAsString(error(uEx.getMessage(), uEx.getErrors()))))
                )
                .onErrorResume(Exception.class, ex ->
                        Mono.just(ResponseEntity.badRequest()
                                .body(convertToJsonAsString(error(ex.getMessage())))));
    }

    /**
     * Sets a new password for a user using a reset code.
     *
     * @param userJson the user details
     * @return a response entity indicating the result of setting the new password
     */
    public Mono<ResponseEntity<String>> setNewPasswordByCode(UserJson userJson) {
        return resetComponent.setNewPasswordByCode(userJson)
                .map(ResponseEntity::ok)
                .onErrorResume(UserServiceException.class, uEx ->
                        Mono.just(ResponseEntity.badRequest().body(convertToJsonAsString(error(uEx.getMessage(), uEx.getErrors()))))
                )
                .onErrorResume(Exception.class, ex ->
                        Mono.just(ResponseEntity.badRequest().body(convertToJsonAsString(error(ex.getMessage())))));
    }

    /**
     * Reads a user's information.
     *
     * @param userJson the user details
     * @return a response containing the user's information
     */
    @Override
    public Mono<Response> readOne(UserJson userJson) {
        return read.findUserByEmail(userJson)
                .map(found ->
                        success("User successfully read", found))
                .onErrorResume(UserServiceException.class, Response::monoError)
                .onErrorResume(Exception.class, Response::monoError);
    }

    /**
     * Updates a user's information.
     *
     * @param userJson the user details
     * @return a response indicating the result of the update
     */
    @Override
    public Mono<Response> updateOne(UserJson userJson) {
        return update.updateUser(userJson)
                .map(updated ->
                        success("User successfully UPDATED", updated))
                .onErrorResume(UserServiceException.class, Response::monoError)
                .onErrorResume(Exception.class, Response::monoError);
    }

    /**
     * Deletes a user's information.
     *
     * @param userJson the user details
     * @return a response indicating the result of the deletion
     */
    @Override
    public Mono<Response> deleteOne(UserJson userJson) {
        return delete.proceedIfApplicable(userJson)
                .onErrorResume(UserServiceException.class, Response::monoError)
                .onErrorResume(Exception.class, Response::monoError);
    }

    /**
     * Finds a user by username (email or ID).
     *
     * @param userEmailOrId the user's email or ID
     * @return the user details
     * @throws UsernameNotFoundException if the user is not found
     */
    @Override
    public Mono<UserDetails> findByUsername(String userEmailOrId) throws UsernameNotFoundException {
        try {
            return login.validSpringUserToLogin(userEmailOrId);
        } catch (Exception e) {
            throw new UsernameNotFoundException(userEmailOrId);
        }
    }

}

package com.whatacook.cookers.service.contracts;

import com.whatacook.cookers.model.auth.ResetDto;
import org.springframework.data.mongodb.repository.ReactiveMongoRepository;
import org.springframework.stereotype.Repository;
import reactor.core.publisher.Mono;

/**
 * Repository interface for accessing reset data from MongoDB.
 * Extends ReactiveMongoRepository for reactive CRUD operations.
 * <p>
 * Methods:
 * - findByCode(String code): Finds a reset DTO by its code.
 * <p>
 * Annotations:
 * - @Repository: Indicates that this interface is a Spring repository.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 * @see ResetDto
 * @see Mono
 * @see ReactiveMongoRepository
 */
@Repository
public interface ResetDao extends ReactiveMongoRepository<ResetDto, String> {

    Mono<ResetDto> findByCode(String code);

}

package com.whatacook.cookers.service.contracts;

import com.whatacook.cookers.model.responses.Response;
import com.whatacook.cookers.model.users.UserJson;
import org.springframework.security.core.userdetails.ReactiveUserDetailsService;
import reactor.core.publisher.Mono;

/**
 * Interface for accessing user-related data and operations.
 * Extends ReactiveUserDetailsService for user authentication details.
 * <p>
 * Methods:
 * - existsByEmail(UserJson userJson): Checks if a user exists by their email.
 * - readOne(UserJson userJson): Reads a user by their details.
 * - updateOne(UserJson userJson): Updates a user by their details.
 * - deleteOne(UserJson userJson): Deletes a user by their details.
 * <p>
 * Annotations:
 * - None
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 * @see ReactiveUserDetailsService
 * @see Response
 * @see UserJson
 */
public interface UserAccessContractModel extends ReactiveUserDetailsService {

    Mono<Response> existsByEmail(UserJson userJson);

//    Mono<Response> createOne(UserJustToSave userJson);
//    transferred for authentication service

    Mono<Response> readOne(UserJson userJson);

    Mono<Response> updateOne(UserJson userJson);

    Mono<Response> deleteOne(UserJson userJson);

}

package com.whatacook.cookers.service.contracts;

import com.whatacook.cookers.model.auth.ActivationDto;
import org.springframework.data.mongodb.repository.ReactiveMongoRepository;
import org.springframework.stereotype.Repository;
import reactor.core.publisher.Mono;

/**
 * Repository interface for accessing activation data from MongoDB.
 * Extends ReactiveMongoRepository for reactive CRUD operations.
 * <p>
 * Methods:
 * - findByCode(String code): Finds an activation DTO by its code.
 * <p>
 * Annotations:
 * - @Repository: Indicates that this interface is a Spring repository.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 * @see ActivationDto
 * @see Mono
 * @see ReactiveMongoRepository
 */
@Repository
public interface ActivationDao extends ReactiveMongoRepository<ActivationDto, String> {

    Mono<ActivationDto> findByCode(String code);

}

package com.whatacook.cookers.service.contracts;

import com.whatacook.cookers.model.users.UserDto;
import org.springframework.data.mongodb.repository.ReactiveMongoRepository;
import org.springframework.stereotype.Repository;
import reactor.core.publisher.Mono;

/**
 * Repository interface for accessing user data from MongoDB.
 * Extends ReactiveMongoRepository for reactive CRUD operations.
 * <p>
 * Methods:
 * - findByEmail(String email): Finds a user by their email.
 * - findBy_id(String _id): Finds a user by their ID.
 * - existsByEmail(String email): Checks if a user exists by their email.
 * <p>
 * Annotations:
 * - @Repository: Indicates that this interface is a Spring repository.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 */
@Repository
public interface UserDao extends ReactiveMongoRepository<UserDto, String> {

    Mono<UserDto> findByEmail(String email);

    Mono<UserDto> findBy_id(String _id);

    Mono<Boolean> existsByEmail(String email);

}

package com.whatacook.cookers.service.contracts;

import com.whatacook.cookers.model.favorites.FavoriteDto;
import org.springframework.data.mongodb.repository.ReactiveMongoRepository;

/**
 * Repository interface for accessing favorite data from MongoDB.
 * Extends ReactiveMongoRepository for reactive CRUD operations.
 * <p>
 * Annotations:
 * - None
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 * @see FavoriteDto
 * @see ReactiveMongoRepository
 */
public interface FavoriteDao extends ReactiveMongoRepository<FavoriteDto, String> {
}

package com.whatacook.cookers.service.components;

import com.whatacook.cookers.config.jwt.CustomUserDetails;
import com.whatacook.cookers.model.constants.AccountStatus;
import com.whatacook.cookers.model.exceptions.UserServiceException;
import com.whatacook.cookers.model.users.UserDto;
import com.whatacook.cookers.service.contracts.UserDao;
import com.whatacook.cookers.utilities.Util;
import lombok.AllArgsConstructor;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;
import org.springframework.validation.annotation.Validated;
import reactor.core.publisher.Mono;

import java.util.Arrays;
import java.util.EnumSet;
import java.util.Set;
import java.util.stream.Collectors;

import static com.whatacook.cookers.model.constants.AccountStatus.*;

/**
 * Component for handling user login operations.
 * <p>
 * Annotations:
 * - @AllArgsConstructor: Generates a constructor with 1 parameter for each field.
 * - @Component: Indicates that this class is a Spring component.
 * - @Validated: Indicates that this class is eligible for Spring's method-level validation.
 * <p>
 * Fields:
 * - DAO: Data Access Object for UserDto.
 * - deleteComponent: Component for handling account deletions.
 * <p>
 * Methods:
 * - validSpringUserToLogin(String userEmailOrId): Validates and retrieves a Spring Security user.
 * - findUserByEmail(String email): Finds a user by email.
 * - verifyAccountStatusByEmail(UserDto userDTO): Verifies the account status by email.
 * - newValidUserByEmail(UserDto userDTO): Creates a valid UserDetails object by email.
 * - listAuthorities(UserDto userDTO): Lists the authorities for a user.
 * - findUserById(String id): Finds a user by ID.
 * - verifyAccountStatusById(UserDto userDTO): Verifies the account status by ID.
 * - newValidUserById(UserDto userDTO): Creates a valid UserDetails object by ID.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 * @see UserDao
 * @see UserDto
 * @see UserDetails
 * @see CustomUserDetails
 * @see DeleteComponent
 * @see Util
 * @see Mono
 * @see AllArgsConstructor
 * @see Component
 * @see Validated
 * @see AccountStatus
 */
@AllArgsConstructor
@Component
@Validated
public class LoginComponent {

    private final UserDao DAO;
    private final DeleteComponent deleteComponent;

    /**
     * Validates and retrieves a Spring Security user.
     *
     * @param userEmailOrId the user email or ID
     * @return a Mono of UserDetails
     */
    public Mono<UserDetails> validSpringUserToLogin(String userEmailOrId) {
        return Mono.just(userEmailOrId)
                .flatMap(info -> {
                    if (Util.isValidEmail(info))
                        return findUserByEmail(info);
                    else
                        return findUserById(info);
                });
    }

    /**
     * Finds a user by email.
     *
     * @param email the user email
     * @return a Mono of UserDetails
     */
    private Mono<UserDetails> findUserByEmail(String email) {
        return DAO.findByEmail(email)
                .switchIfEmpty(UserServiceException.mono("USER NOT FOUND!"))
                .flatMap(this::verifyAccountStatusByEmail)
                .map(this::newValidUserByEmail);
    }

    /**
     * Verifies the account status by email.
     *
     * @param userDTO the user details
     * @return a Mono of UserDto
     */
    private Mono<UserDto> verifyAccountStatusByEmail(UserDto userDTO) {
        final AccountStatus accountStatus = userDTO.getAccountStatus();
        if (EnumSet.of(OK, OFF, REQUEST_DELETE).contains(accountStatus))
            return Mono.just(userDTO);
        else if (MARKED_DELETE.equals(accountStatus))
            return deleteComponent.proceedIfApplicable(userDTO.toJson())
                    .flatMap(response -> UserServiceException.mono(response.getMessage()));
        else
            return UserServiceException.mono(accountStatus.getDetails());
    }

    /**
     * Creates a valid UserDetails object by email.
     *
     * @param userDTO the user details
     * @return the UserDetails object
     */
    private UserDetails newValidUserByEmail(UserDto userDTO) {
        Set<GrantedAuthority> authorities = listAuthorities(userDTO);
        authorities.add(new SimpleGrantedAuthority("ROLE_SELF"));
        return new CustomUserDetails(userDTO.getEmail() + userDTO.get_id(), userDTO.getPassword(), authorities, userDTO.getEmail(), userDTO.get_id());
    }

    /**
     * Lists the authorities for a user.
     *
     * @param userDTO the user details
     * @return a set of GrantedAuthority
     */
    private Set<GrantedAuthority> listAuthorities(UserDto userDTO) {
        return Arrays.stream(userDTO.getRoleType().get().split(","))
                .map(String::trim)
                .map(role -> new SimpleGrantedAuthority("ROLE_" + role))
                .collect(Collectors.toSet());
    }

    /**
     * Finds a user by ID.
     *
     * @param id the user ID
     * @return a Mono of UserDetails
     */
    private Mono<UserDetails> findUserById(String id) {
        return DAO.findBy_id(id)
                .switchIfEmpty(UserServiceException.mono("USER NOT FOUND!"))
                .flatMap(this::verifyAccountStatusById)
                .map(this::newValidUserById);
    }

    /**
     * Verifies the account status by ID.
     *
     * @param userDTO the user details
     * @return a Mono of UserDto
     */
    private Mono<UserDto> verifyAccountStatusById(UserDto userDTO) {
        String errorMsg = "Account Status Incorrect for this request: " + userDTO.getAccountStatus().getDetails();
        if (EnumSet.of(AccountStatus.OK, AccountStatus.PENDING, AccountStatus.OUTDATED)
                .contains(userDTO.getAccountStatus())) {
            return Mono.just(userDTO);
        } else {
            return UserServiceException.mono(errorMsg);
        }
    }

    /**
     * Creates a valid UserDetails object by ID.
     *
     * @param userDTO the user details
     * @return the UserDetails object
     */
    private UserDetails newValidUserById(UserDto userDTO) {
        Set<GrantedAuthority> authorities = listAuthorities(userDTO);
        authorities.add(new SimpleGrantedAuthority("ROLE_SELF"));
        return new CustomUserDetails(userDTO.get_id(), userDTO.getPassword(), authorities, userDTO.getEmail(), userDTO.get_id());
    }

}

package com.whatacook.cookers.service.components;

import com.whatacook.cookers.model.constants.AccountStatus;
import com.whatacook.cookers.model.exceptions.UserServiceException;
import com.whatacook.cookers.model.users.UserDto;
import com.whatacook.cookers.model.users.UserJson;
import com.whatacook.cookers.utilities.Util;
import com.whatacook.cookers.service.contracts.UserDao;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

import java.time.LocalDate;
import java.util.EnumSet;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;
import java.util.function.Supplier;

/**
 * Component for updating user information.
 * <p>
 * Fields:
 * - DAO: Data Access Object for UserDto.
 * <p>
 * Methods:
 * - updateUser(UserJson userJson): Updates user information.
 * - updatePlayerIfNecessary(UserDto oldUser, UserJson updateInfo): Updates user attributes if necessary.
 * - updateFirstName(UserDto user, UserJson updateInfo, AtomicBoolean updated): Updates first name if necessary.
 * - updateSurnames(UserDto user, UserJson updateInfo, AtomicBoolean updated): Updates surnames if necessary.
 * - updateEmail(UserDto user, UserJson updateInfo, AtomicBoolean updated): Updates email if necessary.
 * - updateBirthdate(UserDto user, UserJson updateInfo, AtomicBoolean updated): Updates birthdate if necessary.
 * - updatePassword(UserDto user, UserJson updateInfo, AtomicBoolean updated): Updates password if necessary.
 * - updateAccountStatus(UserDto user, UserJson updateInfo, AtomicBoolean updated): Updates account status if necessary.
 * - updateUserByDtoReturnJson(UserDto userToSave): Updates user and returns UserJson.
 * - updateAttribute(Supplier<T> original, Supplier<T> updated, Consumer<T> setter): Updates attribute if necessary.
 * - verifyNames(String nameOrSurname): Verifies and formats name or surname.
 * - verifyEmail(String email): Verifies email format.
 * - verifyBirthdate(LocalDate localDate): Verifies birthdate format.
 *
 * @see UserServiceException
 * @see UserDto
 * @see UserJson
 * @see UserDao
 * @see Util
 * @see AccountStatus
 * @see Mono
 * @see Component
 */
@Component
public class UpdateComponent {

    private final UserDao DAO;

    public UpdateComponent(UserDao DAO) {
        this.DAO = DAO;
    }

    /**
     * Updates user information.
     *
     * @param userJson the user details to update
     * @return a Mono containing the updated user details as UserJson
     */
    public Mono<UserJson> updateUser(UserJson userJson) {
        return DAO.findBy_id(userJson.get_id())
                .switchIfEmpty(UserServiceException.mono(
                        "User not found with this ID", Map.of("_id", userJson.get_id())))
                .flatMap(oldUser -> updatePlayerIfNecessary(oldUser, userJson))
                .flatMap(this::updateUserByDtoReturnJson);
    }

    /**
     * Updates user attributes if necessary.
     *
     * @param oldUser    the current user details
     * @param updateInfo the new user details
     * @return a Mono containing the updated user details as UserDto
     */
    private static Mono<UserDto> updatePlayerIfNecessary(UserDto oldUser, UserJson updateInfo) {
        AtomicBoolean updated = new AtomicBoolean(false);
        return Mono.just(oldUser)
                .flatMap(user -> {
                    updateFirstName(user, updateInfo, updated);
                    updateSurnames(user, updateInfo, updated);
                    updateEmail(user, updateInfo, updated);
                    updateBirthdate(user, updateInfo, updated);
                    updatePassword(user, updateInfo, updated);
                    updateAccountStatus(user, updateInfo, updated);

                    if (!updated.get()) {
                        return UserServiceException.mono("No update required or data is invalid.");
                    }
                    return Mono.just(user);
                });
    }

    private static void updateFirstName(UserDto user, UserJson updateInfo, AtomicBoolean updated) {
        boolean isFirstNameUpdated = updateAttribute(user::getFirstName, () -> verifyNames(updateInfo.getFirstName()), user::setFirstName);
        updated.set(isFirstNameUpdated || updated.get());
    }

    private static void updateSurnames(UserDto user, UserJson updateInfo, AtomicBoolean updated) {
        boolean isSurnamesUpdated = updateAttribute(user::getSurNames, () -> verifyNames(updateInfo.getSurNames()), user::setSurNames);
        updated.set(isSurnamesUpdated || updated.get());
    }

    private static void updateEmail(UserDto user, UserJson updateInfo, AtomicBoolean updated) {
        boolean isEmailUpdated = updateAttribute(user::getEmail, () -> verifyEmail(updateInfo.getEmail()), user::setEmail);
        updated.set(isEmailUpdated || updated.get());
    }

    private static void updateBirthdate(UserDto user, UserJson updateInfo, AtomicBoolean updated) {
        boolean isBirthdateUpdated = updateAttribute(user::getBirthdate, () -> verifyBirthdate(updateInfo.getBirthdate()), user::setBirthdate);
        updated.set(isBirthdateUpdated || updated.get());
    }

    private static void updatePassword(UserDto user, UserJson updateInfo, AtomicBoolean updated) {
        if (updateInfo.getNewPassword() != null) {
            Optional.ofNullable(updateInfo.getPassword())
                    .filter(pwd -> Util.encryptMatches(pwd, user.getPassword()))
                    .orElseThrow(UserServiceException::passNotMatch);
            Optional.ofNullable(updateInfo.getNewPassword())
                    .filter(Util::isValidPassword)
                    .ifPresent(newPwd -> {
                        user.setPassword(Util.encryptPassword(newPwd));
                        updated.set(true);
                    });
        }
    }

    private static void updateAccountStatus(UserDto user, UserJson updateInfo, AtomicBoolean updated) {
        if (updateInfo.getAccountStatus() != null) {
            boolean isCurrentStatusEligibleForUpdate =
                    EnumSet.of(AccountStatus.OK, AccountStatus.OFF, AccountStatus.OUTDATED, AccountStatus.REQUEST_DELETE).contains(user.getAccountStatus());
            AccountStatus toUpdate = AccountStatus.valueOf(updateInfo.getAccountStatus());
            boolean isNewStatusValid = !AccountStatus.MARKED_DELETE.equals(toUpdate);

            if (isCurrentStatusEligibleForUpdate && isNewStatusValid) {
                boolean isAccountStatusUpdated =
                        updateAttribute(user::getAccountStatus, () -> toUpdate, user::setAccountStatus);
                updated.set(isAccountStatusUpdated || updated.get());
            }
        }
    }

    private Mono<UserJson> updateUserByDtoReturnJson(UserDto userToSave) {
        return Mono.just(userToSave).flatMap(DAO::save).map(UserDto::toJson);
    }

    private static <T> boolean updateAttribute(Supplier<T> original, Supplier<T> updated, Consumer<T> setter) {
        T originalValue = original.get();
        T updatedValue = updated.get();
        if (updatedValue != null && !Objects.equals(originalValue, updatedValue)) {
            setter.accept(updatedValue);
            return true;
        }
        return false;
    }

    private static String verifyNames(String nameOrSurname) {
        return Optional.ofNullable(nameOrSurname).map(Util::TitleCase).orElse(null);
    }

    private static String verifyEmail(String email) {
        return Optional.ofNullable(email).filter(Util::isValidEmail).orElse(null);
    }

    private static LocalDate verifyBirthdate(LocalDate localDate) {
        return Optional.ofNullable(localDate).filter(Util::isValidBirthdate).orElse(null);
    }

}

package com.whatacook.cookers.service.components;

import com.whatacook.cookers.model.constants.AccountStatus;
import com.whatacook.cookers.model.constants.Htmls;
import com.whatacook.cookers.model.exceptions.UserServiceException;
import com.whatacook.cookers.model.users.UserDto;
import com.whatacook.cookers.model.users.UserJson;
import com.whatacook.cookers.utilities.GlobalValues;
import com.whatacook.cookers.service.ActivationService;
import com.whatacook.cookers.service.EmailService;
import com.whatacook.cookers.service.contracts.UserDao;
import lombok.AllArgsConstructor;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;

/**
 * Component for handling user account activation processes.
 * <p>
 * Annotations:
 * - @AllArgsConstructor: Generates a constructor with 1 parameter for each field.
 * - @Component: Indicates that this class is a Spring component.
 * <p>
 * Fields:
 * - activationService: Service for activation operations.
 * - emailService: Service for email operations.
 * - globalValues: Global configuration values.
 * - DAO: Data Access Object for UserDto.
 * <p>
 * Methods:
 * - byActivationCodeSentByEmail(String activationCode): Activates a user account using the provided activation code.
 * - buildHtmlOkAccountActivatedContent(UserDto userDTO): Builds HTML content for successful account activation.
 * - buildHtmlFailAccountActivatedContent(Throwable error): Builds HTML content for failed account activation.
 * - resendActivationCode(String email): Resends the activation code to the user's email.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 * @see ActivationService
 * @see EmailService
 * @see GlobalValues
 * @see UserDao
 * @see UserDto
 * @see UserJson
 * @see Mono
 * @see AllArgsConstructor
 * @see Component
 */
@AllArgsConstructor
@Component
public class ActivateComponent {

    private final ActivationService activationService;
    private final EmailService emailService;
    private final GlobalValues globalValues;
    private final UserDao DAO;

    /**
     * Activates a user account using the provided activation code.
     *
     * @param activationCode the activation code
     * @return HTML content indicating the result of the activation process
     */
    public Mono<String> byActivationCodeSentByEmail(String activationCode) {
        return Mono.just(activationCode)
                .flatMap(activationService::findByCode)
                .switchIfEmpty(UserServiceException.mono("This Code is Invalid"))
                .flatMap(activationDto -> {
                    if (ChronoUnit.HOURS.between(activationDto.getExpiration(), LocalDateTime.now()) > 24)
                        return UserServiceException.mono("This Code is Expired");
                    else
                        return Mono.just(activationDto);
                })
                .flatMap(activationDto ->
                        DAO.findBy_id(activationDto.getId())
                                .flatMap(userDTO -> {
                                    if (userDTO.getAccountStatus() == AccountStatus.PENDING) {
                                        userDTO.setAccountStatus(AccountStatus.OK);
                                        return DAO.save(userDTO)
                                                .then(activationService.deleteById(activationDto.getId()))
                                                .thenReturn(userDTO);
                                    } else {
                                        return UserServiceException.mono("The Account Status is not correct to activate account");
                                    }
                                }))
                .map(this::buildHtmlOkAccountActivatedContent)
                .onErrorResume(this::buildHtmlFailAccountActivatedContent);
    }

    /**
     * Builds HTML content for successful account activation.
     *
     * @param userDTO the user details
     * @return the HTML content
     */
    private String buildHtmlOkAccountActivatedContent(UserDto userDTO) {
        return Htmls.SuccessActivation.get()
                .replace("LOGO_WAC", globalValues.getUrlWacLogoPngSmall())
                .replace("USER_NAME", userDTO.getFirstName());
    }

    /**
     * Builds HTML content for failed account activation.
     *
     * @param error the error occurred
     * @return the HTML content
     */
    private Mono<String> buildHtmlFailAccountActivatedContent(Throwable error) {
        return Mono.just(Htmls.FailActivation.get()
                .replace("LOGO_WAC", globalValues.getUrlWacLogoPngSmall())
                .replace("PATH_TO_RESEND", globalValues.getPathToResendActvationMail())
                .replace("EMAIL_WAC", globalValues.getMailToWac()));
    }

    /**
     * Resends the activation code to the user's email.
     *
     * @param email the user's email
     * @return the user details
     */
    public Mono<UserJson> resendActivationCode(String email) {
        return DAO.findByEmail(email)
                .switchIfEmpty(UserServiceException.mono("This Email is Invalid"))
                .flatMap(userDTO -> activationService.findById(userDTO.get_id())
                        .flatMap(activationDto -> {
                            if (ChronoUnit.HOURS.between(activationDto.getExpiration(), LocalDateTime.now()) <= 24) {
                                return emailService.sendActivationMail(activationDto, userDTO);
                            } else {
                                return emailService.createActivationCodeAndSendEmail(userDTO);
                            }
                        }))
                .onErrorMap(UserServiceException::onErrorMap);
    }

}

package com.whatacook.cookers.service.components;

import com.whatacook.cookers.model.auth.ResetDto;
import com.whatacook.cookers.model.constants.AccountStatus;
import com.whatacook.cookers.model.constants.Htmls;
import com.whatacook.cookers.model.exceptions.UserServiceException;
import com.whatacook.cookers.model.users.UserDto;
import com.whatacook.cookers.model.users.UserJson;
import com.whatacook.cookers.service.ResetService;
import com.whatacook.cookers.service.contracts.UserDao;
import com.whatacook.cookers.utilities.GlobalValues;
import com.whatacook.cookers.utilities.Util;
import lombok.AllArgsConstructor;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;

import static com.whatacook.cookers.utilities.Util.encryptPassword;

/**
 * Component for handling password reset operations.
 * <p>
 * Annotations:
 * - @AllArgsConstructor: Generates a constructor with 1 parameter for each field.
 * - @Component: Indicates that this class is a Spring component.
 * <p>
 * Fields:
 * - resetService: Service for handling reset operations.
 * - globalValues: Global configuration values.
 * - DAO: Data Access Object for UserDto.
 * <p>
 * Methods:
 * - resetPasswordByCodeAndReturnNewPassForm(String resetCode): Resets password by code and returns a new password form.
 * - setNewPasswordByCode(UserJson userJson): Sets a new password by code.
 * - buildHtmlFormToSendNewPassword(ResetDto resetDto): Builds HTML form for sending new password.
 * - buildHtmlSuccessSetNewPassword(UserDto userDTO): Builds HTML for successful password reset.
 * - buildHtmlFailSetNewPassword(Throwable throwable): Builds HTML for failed password reset.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 * @see ResetService
 * @see GlobalValues
 * @see UserDao
 * @see UserDto
 * @see UserJson
 * @see Mono
 * @see AllArgsConstructor
 * @see Component
 * @see ChronoUnit
 * @see LocalDateTime
 * @see Htmls
 * @see Util
 * @see UserServiceException
 * @see AccountStatus
 */
@AllArgsConstructor
@Component
public class ResetComponent {

    private final ResetService resetService;
    private final GlobalValues globalValues;
    private final UserDao DAO;

    /**
     * Resets password by code and returns a new password form.
     *
     * @param resetCode the reset code
     * @return a Mono of the HTML form
     */
    public Mono<String> resetPasswordByCodeAndReturnNewPassForm(String resetCode) {
        return Mono.just(resetCode)
                .flatMap(resetService::findByCode)
                .switchIfEmpty(UserServiceException.mono("This Code is Invalid"))
                .flatMap(resetDto -> {
                    if (ChronoUnit.HOURS.between(resetDto.getExpiration(), LocalDateTime.now()) > 1)
                        return UserServiceException.mono("This Code is Expired");
                    else
                        return Mono.just(resetDto);
                }).flatMap(resetDto -> DAO.findBy_id(resetDto.getId())
                        .flatMap(userDTO -> resetService.createNew(userDTO)
                                .flatMap(newCode -> {
                                    userDTO.setPassword(encryptPassword(newCode.getCode()));
                                    userDTO.setAccountStatus(AccountStatus.OUTDATED);
                                    return DAO.save(userDTO).thenReturn(newCode);
                                })))
                .map(this::buildHtmlFormToSendNewPassword)
                .onErrorMap(UserServiceException::onErrorMap);
    }

    /**
     * Builds HTML form for sending new password.
     *
     * @param resetDto the reset details
     * @return the HTML form
     */
    private String buildHtmlFormToSendNewPassword(ResetDto resetDto) {
        String endPoint = globalValues.getUrlSetNewPassword() + resetDto.getCode();
        return Htmls.FormToSendNewPassword.get()
                .replace("LOGO_WAC", globalValues.getUrlWacLogoPngSmall())
                .replace("RESET_CODE", resetDto.getCode())
                .replace("ENDPOINT_RESET_PASS", endPoint);
    }

    /**
     * Sets a new password by code.
     *
     * @param userJson the user details
     * @return a Mono of the HTML response
     */
    public Mono<String> setNewPasswordByCode(UserJson userJson) {
        return resetService.findByCode(userJson.get_id())
                .switchIfEmpty(UserServiceException.mono("No user was found"))
                .flatMap(resetDto -> {
                    if (ChronoUnit.HOURS.between(resetDto.getExpiration(), LocalDateTime.now()) > 1)
                        return UserServiceException.mono("This Code is Expired");
                    else
                        return DAO.findBy_id(resetDto.getId());
                })
                .flatMap(userDTO -> {
                    // To not expose the ID, the ID provided is the same reset password code
                    if (Util.encryptMatches(userJson.get_id(), userDTO.getPassword())
                            && Util.isValidPassword(userJson.getNewPassword())) {
                        userDTO.setPassword(encryptPassword(userJson.getNewPassword()));
                        return DAO.save(userDTO);
                    } else
                        return UserServiceException.mono("Reset code is invalid");
                }).flatMap(this::buildHtmlSuccessSetNewPassword)
                .onErrorResume(this::buildHtmlFailSetNewPassword);
    }

    /**
     * Builds HTML for successful password reset.
     *
     * @param userDTO the user details
     * @return a Mono of the HTML response
     */
    private Mono<String> buildHtmlSuccessSetNewPassword(UserDto userDTO) {
        return resetService.deleteById(userDTO.get_id())
                .then(Mono.fromCallable(() -> Htmls.SuccessSetNewPassword.get()
                        .replace("LOGO_WAC", globalValues.getUrlWacLogoPngSmall())
                        .replace("USER_NAME", userDTO.getFirstName())));
    }

    /**
     * Builds HTML for failed password reset.
     *
     * @param throwable the error
     * @return a Mono of the HTML response
     */
    private Mono<String> buildHtmlFailSetNewPassword(Throwable throwable) {
        return Mono.just(Htmls.FailSetNewPassword.get()
                .replace("LOGO_WAC", globalValues.getUrlWacLogoPngSmall())
                .replace("EMAIL_WAC", globalValues.getMailToWac())
                .replace("URL_FORGOT_PASS", globalValues.getUrlForgotPassword())
                .replace("errorDescriptionValue", throwable.getMessage()));
    }

}

package com.whatacook.cookers.service.components;

import com.whatacook.cookers.model.exceptions.UserServiceException;
import com.whatacook.cookers.model.users.UserDto;
import com.whatacook.cookers.model.users.UserJson;
import com.whatacook.cookers.model.users.UserJustToSave;
import com.whatacook.cookers.service.EmailService;
import com.whatacook.cookers.service.contracts.UserDao;
import com.whatacook.cookers.utilities.Util;
import jakarta.validation.Valid;
import lombok.AllArgsConstructor;
import org.springframework.stereotype.Component;
import org.springframework.validation.annotation.Validated;
import reactor.core.publisher.Mono;

import java.util.LinkedHashMap;
import java.util.Map;

import static com.whatacook.cookers.utilities.Util.*;

/**
 * Component for saving user information and sending activation emails.
 * <p>
 * Fields:
 * - DAO: Data Access Object for UserDto.
 * - emailService: Service for sending emails.
 * <p>
 * Methods:
 * - saveUser(UserJustToSave userJustToSave): Saves a new user and sends an activation email.
 * - validateAttributes(UserJustToSave userJustToSave): Validates the attributes of the user.
 * - checkEmailNotRegistered(UserJustToSave userJustToSave): Checks if the email is not already registered.
 * - saveUserByJtsReturnDto(UserJustToSave userJustToSave): Saves the user and returns the UserDto.
 *
 * @see UserServiceException
 * @see UserDto
 * @see UserJson
 * @see UserJustToSave
 * @see EmailService
 * @see UserDao
 * @see Util
 * @see Mono
 * @see Component
 * @see Validated
 * @see AllArgsConstructor
 */
@AllArgsConstructor
@Validated
@Component
public class SaveComponent {

    private final UserDao DAO;
    private final EmailService emailService;

    /**
     * Saves a new user and sends an activation email.
     *
     * @param userJustToSave the user details to save
     * @return a Mono containing the user details as UserJson
     */
    public Mono<UserJson> saveUser(@Valid UserJustToSave userJustToSave) {
        return Mono.just(userJustToSave)
                .flatMap(this::validateAttributes)
                .flatMap(this::checkEmailNotRegistered)
                .flatMap(this::saveUserByJtsReturnDto)
                .flatMap(emailService::createActivationCodeAndSendEmail);
    }

    /**
     * Validates the attributes of the user.
     *
     * @param userJustToSave the user details to validate
     * @return a Mono containing the validated user details
     */
    private Mono<UserJustToSave> validateAttributes(UserJustToSave userJustToSave) {
        Map<String, Object> errors = new LinkedHashMap<>();

        if (isNullOrEmptyOrLiteralNull(userJustToSave.getEmail()))
            errors.put("email", "E-mail is missing!");
        if (notValidEmail(userJustToSave.getEmail()))
            errors.put("email", "This email has invalid format!");
        if (isNullOrEmptyOrLiteralNull(userJustToSave.getPassword()))
            errors.put("password", "Password is missing!");
        if (notValidPassword(userJustToSave.getPassword()))
            errors.put("password", "Password is invalid format: 8 characters " +
                    "-> uppercase lowercase letters numbers and special characters !");
        if (isNullOrEmptyOrLiteralNull(userJustToSave.getFirstName()))
            errors.put("firstName", "First Name is missing!");
        if (isNullOrEmptyOrLiteralNull(userJustToSave.getSurNames()))
            errors.put("surNames", "Last Name is missing!");
        if (notValidBirthdate(userJustToSave.getBirthdate()))
            errors.put("birthdate", "Missing or invalid format : 'YYYY-MM-DD' and more than 7 years!");

        if (!errors.isEmpty())
            return UserServiceException.mono("Look in content for errors", errors);
        else
            return Mono.just(userJustToSave);
    }

    /**
     * Checks if the email is not already registered.
     *
     * @param userJustToSave the user details to check
     * @return a Mono containing the user details if email is not registered
     */
    private Mono<UserJustToSave> checkEmailNotRegistered(UserJustToSave userJustToSave) {
        return DAO.existsByEmail(userJustToSave.getEmail())
                .flatMap(exists -> exists
                        ? UserServiceException.mono("This email is already registered!")
                        : Mono.just(userJustToSave));
    }

    /**
     * Saves the user and returns the UserDto.
     *
     * @param userJustToSave the user details to save
     * @return a Mono containing the saved UserDto
     */
    private Mono<UserDto> saveUserByJtsReturnDto(UserJustToSave userJustToSave) {
        return Mono.just(userJustToSave)
                .flatMap(user -> {
                    user.setFirstName(TitleCase(user.getFirstName()));
                    user.setSurNames(TitleCase(user.getSurNames()));
                    return Mono.just(user);
                }).map(UserJustToSave::toUserDTO)
                .flatMap(DAO::save)
                .doOnError(UserServiceException::doOnErrorMap);
    }

}

package com.whatacook.cookers.service.components;

import com.whatacook.cookers.model.constants.AccountStatus;
import com.whatacook.cookers.model.exceptions.UserServiceException;
import com.whatacook.cookers.model.responses.Response;
import com.whatacook.cookers.model.users.UserDto;
import com.whatacook.cookers.model.users.UserJson;
import com.whatacook.cookers.service.contracts.UserDao;
import lombok.AllArgsConstructor;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;

/**
 * Component for handling user account deletion processes.
 * <p>
 * Annotations:
 * - @AllArgsConstructor: Generates a constructor with 1 parameter for each field.
 * - @Component: Indicates that this class is a Spring component.
 * <p>
 * Fields:
 * - DAO: Data Access Object for UserDto.
 * <p>
 * Methods:
 * - proceedIfApplicable(UserJson userJson): Checks and proceeds with the deletion if applicable.
 * - handleStatusChange(UserDto userDTO): Handles the account status change during deletion.
 * - handleOkStatus(UserDto userDTO): Handles the OK status during deletion.
 * - handleRequestDeleteStatus(UserDto userDTO): Handles the REQUEST_DELETE status during deletion.
 * - handleMarkedDeleteStatus(UserDto userDTO): Handles the MARKED_DELETE status during deletion.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 * @see UserDao
 * @see UserDto
 * @see UserJson
 * @see Response
 * @see Mono
 * @see AllArgsConstructor
 * @see Component
 */
@AllArgsConstructor
@Component
public class DeleteComponent {

    private final UserDao DAO;

    /**
     * Checks and proceeds with the deletion if applicable.
     *
     * @param userJson the user details
     * @return a response indicating the result of the deletion process
     */
    public Mono<Response> proceedIfApplicable(UserJson userJson) {
        return DAO.findBy_id(userJson.get_id())
                .switchIfEmpty(UserServiceException.mono("User not found"))
                .flatMap(this::handleStatusChange);
    }

    /**
     * Handles the account status change during deletion.
     *
     * @param userDTO the user details
     * @return a response indicating the result of the status change
     */
    private Mono<Response> handleStatusChange(UserDto userDTO) {
        return switch (userDTO.getAccountStatus()) {
            case OK -> handleOkStatus(userDTO);
            case REQUEST_DELETE -> handleRequestDeleteStatus(userDTO);
            case MARKED_DELETE -> handleMarkedDeleteStatus(userDTO);
            default -> UserServiceException.mono("Invalid account status to request deletion");
        };
    }

    /**
     * Handles the OK status during deletion.
     *
     * @param userDTO the user details
     * @return a response indicating the result of setting the REQUEST_DELETE status
     */
    private Mono<Response> handleOkStatus(UserDto userDTO) {
        userDTO.setAccountStatus(AccountStatus.REQUEST_DELETE);
        userDTO.setRequestDeleteDate(LocalDateTime.now());
        return DAO.save(userDTO)
                .map(savedUserDTO -> Response.success("REQUEST_DELETE set, you have one year to revoke the deletion", savedUserDTO.toJson()))
                .onErrorResume(UserServiceException::mono);
    }

    /**
     * Handles the REQUEST_DELETE status during deletion.
     *
     * @param userDTO the user details
     * @return a response indicating the result of handling the REQUEST_DELETE status
     */
    private Mono<Response> handleRequestDeleteStatus(UserDto userDTO) {
        LocalDateTime requestDeleteDate = userDTO.getRequestDeleteDate();
        if (requestDeleteDate != null && ChronoUnit.YEARS.between(requestDeleteDate, LocalDateTime.now()) >= 1) {
            userDTO.setAccountStatus(AccountStatus.MARKED_DELETE);
            return DAO.save(userDTO)
                    .map(savedUserDTO -> Response.success("MARKED_DELETE set, your account has been invalidated you have one year to request your data", savedUserDTO.toJson()))
                    .onErrorResume(UserServiceException::mono);
        }
        return Mono.just(Response.success("REQUEST_DELETE request is not yet a year old", userDTO.toJson()));
    }

    /**
     * Handles the MARKED_DELETE status during deletion.
     *
     * @param userDTO the user details
     * @return a response indicating the result of handling the MARKED_DELETE status
     */
    private Mono<Response> handleMarkedDeleteStatus(UserDto userDTO) {
        LocalDateTime requestDeleteDate = userDTO.getRequestDeleteDate();
        if (requestDeleteDate != null && ChronoUnit.YEARS.between(requestDeleteDate, LocalDateTime.now()) >= 2) {
            return DAO.delete(userDTO)
                    .thenReturn(Response.success("Your account has been terminated", true))
                    .onErrorResume(UserServiceException::mono);
        }
        String message = "Your account is set to be deleted, but you still have time to request your data";
        return Mono.just(Response.success(message, userDTO.toJson()));
    }

}

package com.whatacook.cookers.service.components;

import com.whatacook.cookers.model.exceptions.UserServiceException;
import com.whatacook.cookers.model.users.UserDto;
import com.whatacook.cookers.model.users.UserJson;
import com.whatacook.cookers.service.contracts.UserDao;
import com.whatacook.cookers.utilities.Util;
import lombok.AllArgsConstructor;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

/**
 * Component for handling user retrieval operations.
 * <p>
 * Annotations:
 * - @AllArgsConstructor: Generates a constructor with 1 parameter for each field.
 * - @Component: Indicates that this class is a Spring component.
 * <p>
 * Fields:
 * - DAO: Data Access Object for UserDto.
 * <p>
 * Methods:
 * - checkIfExistsByEmail(UserJson userJson): Checks if a user exists by email.
 * - findUserByEmail(UserJson userJson): Finds a user by email.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 * @see UserDao
 * @see UserDto
 * @see UserJson
 * @see Mono
 * @see AllArgsConstructor
 * @see Component
 */
@AllArgsConstructor
@Component
public class FindComponent {

    private final UserDao DAO;

    /**
     * Checks if a user exists by email.
     *
     * @param userJson the user details
     * @return a Mono indicating if the user exists
     */
    public Mono<Boolean> checkIfExistsByEmail(UserJson userJson) {
        return Mono.just(userJson)
                .map(UserJson::getEmail)
                .filter(Util::isValidEmail)
                .flatMap(DAO::existsByEmail)
                .switchIfEmpty(UserServiceException.mono("Email not found!"))
                .doOnError(UserServiceException::onErrorMap);
    }

    /**
     * Finds a user by email.
     *
     * @param userJson the user details
     * @return a Mono of the user details
     */
    public Mono<UserJson> findUserByEmail(UserJson userJson) {
        return Mono.just(userJson)
                .map(UserJson::getEmail)
                .filter(Util::isValidEmail)
                .flatMap(DAO::findByEmail)
                .switchIfEmpty(UserServiceException.mono("This user does not exist or email is invalid!"))
                .map(UserDto::toJson)
                .doOnError(UserServiceException::onErrorMap);
    }

}

package com.whatacook.cookers.service;

import com.whatacook.cookers.config.jwt.JwtUtil;
import com.whatacook.cookers.model.auth.AuthRequestDto;
import com.whatacook.cookers.model.exceptions.UserServiceException;
import com.whatacook.cookers.model.responses.Response;
import com.whatacook.cookers.model.users.UserJson;
import com.whatacook.cookers.model.users.UserJustToSave;
import com.whatacook.cookers.service.components.SaveComponent;
import com.whatacook.cookers.service.contracts.UserDao;
import jakarta.validation.Valid;
import lombok.AllArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.ReactiveAuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Service;
import org.springframework.validation.annotation.Validated;
import reactor.core.publisher.Mono;

import static com.whatacook.cookers.model.responses.Response.error;
import static com.whatacook.cookers.model.responses.Response.success;

/**
 * Service class for handling authentication and user registration.
 * <p>
 * Annotations:
 * - @AllArgsConstructor: Generates a constructor with 1 parameter for each field.
 * - @Service: Indicates that this class is a Spring service.
 * - @Validated: Enables validation for method parameters in this class.
 * <p>
 * Fields:
 * - reactiveAuthenticationManager: The authentication manager for handling authentication requests.
 * - jwtUtil: Utility class for generating and validating JWT tokens.
 * - DAO: The user data access object for interacting with the database.
 * - create: Component for saving new users.
 * - emailService: Service for handling email-related operations.
 * <p>
 * Methods:
 * - registerNewUser(UserJustToSave userJson): Registers a new user.
 * - authenticationByLogin(@Valid AuthRequestDto authRequestDto): Authenticates a user by login.
 * - sendEmailCodeToResetPassword(@Valid UserJson userJson): Sends an email with a reset code for password reset.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 * @see ReactiveAuthenticationManager
 * @see JwtUtil
 * @see UserDao
 * @see SaveComponent
 * @see EmailService
 * @see AuthRequestDto
 * @see UserJson
 * @see UserJustToSave
 * @see Mono
 * @see ResponseEntity
 * @see Response
 * @see HttpStatus
 * @see Authentication
 * @see UsernamePasswordAuthenticationToken
 * @see Validated
 * @see Valid
 * @see AllArgsConstructor
 * @see Service
 */
@AllArgsConstructor
@Service
@Validated
public class AuthService {

    private final ReactiveAuthenticationManager reactiveAuthenticationManager;
    private final JwtUtil jwtUtil;
    private final UserDao DAO;
    private final SaveComponent create;
    private final EmailService emailService;

    /**
     * Registers a new user.
     *
     * @param userJson the user details to save
     * @return a Mono containing the response with the saved user details
     */
    public Mono<Response> registerNewUser(UserJustToSave userJson) {
        return create.saveUser(userJson)
                .map(saved -> success("User successfully created", saved))
                .onErrorResume(UserServiceException.class, Response::monoError)
                .onErrorResume(Exception.class, Response::monoError);
    }

    /**
     * Authenticates a user by login.
     *
     * @param authRequestDto the authentication request details
     * @return a Mono containing the response entity with the authentication result
     */
    public Mono<ResponseEntity<Response>> authenticationByLogin(@Valid AuthRequestDto authRequestDto) {
        Authentication authentication = new UsernamePasswordAuthenticationToken(
                authRequestDto.getUsername(), authRequestDto.getPassword());

        return reactiveAuthenticationManager.authenticate(authentication)
                .flatMap(auth -> Mono.just(ResponseEntity.ok(success("TOKEN",
                        jwtUtil.generateToken(authRequestDto)))))
                .onErrorResume(e -> Mono.just(ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                        .body(error("Authentication failed: " + e.getMessage()))));
    }

    /**
     * Sends an email with a reset code for password reset.
     *
     * @param userJson the user details for password reset
     * @return a Mono containing the response entity with the result of the email sending
     */
    public Mono<ResponseEntity<Response>> sendEmailCodeToResetPassword(@Valid UserJson userJson) {
        return DAO.findByEmail(userJson.getEmail())
                .flatMap(userDTO -> {
                    if (userDTO.getBirthdate().equals(userJson.getBirthdate())) {
                        return emailService.createResetCodeAndSendEmail(userDTO)
                                .map(user -> ResponseEntity.ok(success("Email sent with reset code", user)));
                    } else {
                        return Mono.just(ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                                .body(error("Incorrect information")));
                    }
                })
                .switchIfEmpty(Mono.just(ResponseEntity.ok(error("Unregistered email"))));
    }

}

package com.whatacook.cookers.service;

import com.whatacook.cookers.model.auth.ResetDto;
import com.whatacook.cookers.model.users.UserDto;
import com.whatacook.cookers.service.contracts.ResetDao;
import lombok.AllArgsConstructor;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

/**
 * Service class for handling password reset operations.
 * <p>
 * Annotations:
 * - @AllArgsConstructor: Generates a constructor with 1 parameter for each field.
 * - @Service: Indicates that this class is a Spring service.
 * <p>
 * Fields:
 * - DAO: The Data Access Object for ResetDto.
 * <p>
 * Methods:
 * - createNew(UserDto userDTO): Creates a new reset entry for a user.
 * - findById(String id): Finds a reset entry by ID.
 * - findByCode(String code): Finds a reset entry by code.
 * - deleteById(String id): Deletes a reset entry by ID.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 * @see ResetDao
 * @see ResetDto
 * @see UserDto
 * @see Mono
 * @see AllArgsConstructor
 * @see Service
 */
@AllArgsConstructor
@Service
public class ResetService {

    private final ResetDao DAO;

    /**
     * Creates a new reset entry for a user.
     *
     * @param userDTO the user details
     * @return the created reset entry
     */
    public Mono<ResetDto> createNew(UserDto userDTO) {
        return DAO.save(ResetDto.to(userDTO));
    }

    /**
     * Finds a reset entry by ID.
     *
     * @param id the ID of the reset entry
     * @return the found reset entry
     */
    public Mono<ResetDto> findById(String id) {
        return DAO.findById(id);
    }

    /**
     * Finds a reset entry by code.
     *
     * @param code the reset code
     * @return the found reset entry
     */
    public Mono<ResetDto> findByCode(String code) {
        return DAO.findByCode(code);
    }

    /**
     * Deletes a reset entry by ID.
     *
     * @param id the ID of the reset entry
     * @return a Mono signaling completion
     */
    public Mono<Void> deleteById(String id) {
        return DAO.deleteById(id);
    }
}

package com.whatacook.cookers.service;

import com.whatacook.cookers.model.favorites.FavoriteDto;
import com.whatacook.cookers.model.favorites.FavoriteRequest;
import com.whatacook.cookers.model.responses.Response;
import com.whatacook.cookers.service.contracts.FavoriteDao;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

import java.util.ArrayList;
import java.util.Optional;

import static com.whatacook.cookers.model.responses.Response.success;

/**
 * Service class for handling favorite-related operations.
 * <p>
 * Annotations:
 * - @Slf4j: Enables logging.
 * - @AllArgsConstructor: Generates a constructor with 1 parameter for each field.
 * - @Service: Indicates that this class is a Spring service.
 * <p>
 * Fields:
 * - favoriteDao: The favorite data access object for interacting with the database.
 * <p>
 * Methods:
 * - getFavorites(FavoriteRequest favoriteRequest): Retrieves the favorites of a user.
 * - addFavoriteRecipe(FavoriteRequest favoriteRequest): Adds a recipe to the user's favorites.
 * - addFavoriteIngredient(FavoriteRequest favoriteRequest): Adds an ingredient to the user's favorites.
 * - removeFavoriteRecipe(FavoriteRequest favoriteRequest): Removes a recipe from the user's favorites.
 * - removeFavoriteIngredient(FavoriteRequest favoriteRequest): Removes an ingredient from the user's favorites.
 * - createEmptyFavorite(FavoriteRequest favoriteRequest): Creates an empty favorite entry for a user.
 * - ensureNonNullLists(Mono<FavoriteDto> favoriteDtoMono): Ensures that the favorite lists are not null.
 * - handleError(String methodName, Throwable e): Handles errors that occur during processing.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 * @see FavoriteDao
 * @see FavoriteDto
 * @see FavoriteRequest
 * @see Response
 * @see Mono
 * @see Service
 * @see AllArgsConstructor
 * @see Slf4j
 */
@Slf4j
@AllArgsConstructor
@Service
public class FavoriteService {

    private final FavoriteDao favoriteDao;

    public static final String USER_FAVORITES_RETRIEVED = "User favorites retrieved";
    public static final String INGREDIENT_SUCCESSFULLY_REMOVED_FROM_FAVORITES = "Ingredient successfully removed from favorites";
    public static final String RECIPE_SUCCESSFULLY_REMOVED_FROM_FAVORITES = "Recipe successfully removed from favorites";
    public static final String INGREDIENT_SUCCESSFULLY_ADDED_TO_FAVORITES = "Ingredient successfully added to favorites";
    public static final String RECIPE_SUCCESSFULLY_ADDED_TO_FAVORITES = "Recipe successfully added to favorites";

    /**
     * Retrieves the favorites of a user.
     *
     * @param favoriteRequest the favorite request containing the user ID
     * @return a Mono containing the response with the user's favorites
     */
    public Mono<Response> getFavorites(FavoriteRequest favoriteRequest) {
        return favoriteDao.findById(favoriteRequest.getUserId())
                .switchIfEmpty(createEmptyFavorite(favoriteRequest))
                .transform(this::ensureNonNullLists)
                .map(favorites -> success(USER_FAVORITES_RETRIEVED, favorites))
                .onErrorResume(e -> handleError("getFavorites", e));
    }

    /**
     * Adds a recipe to the user's favorites.
     *
     * @param favoriteRequest the favorite request containing the user ID and recipe ID
     * @return a Mono containing the response with the updated favorites
     */
    public Mono<Response> addFavoriteRecipe(FavoriteRequest favoriteRequest) {
        return favoriteDao.findById(favoriteRequest.getUserId())
                .switchIfEmpty(createEmptyFavorite(favoriteRequest))
                .transform(this::ensureNonNullLists)
                .flatMap(favorites -> favorites.addRecipe(favoriteRequest.getRecipeId()))
                .flatMap(favoriteDao::save)
                .map(saved -> success(RECIPE_SUCCESSFULLY_ADDED_TO_FAVORITES, saved))
                .onErrorResume(e -> handleError("addFavoriteRecipe", e));
    }

    /**
     * Adds an ingredient to the user's favorites.
     *
     * @param favoriteRequest the favorite request containing the user ID and ingredient ID
     * @return a Mono containing the response with the updated favorites
     */
    public Mono<Response> addFavoriteIngredient(FavoriteRequest favoriteRequest) {
        return favoriteDao.findById(favoriteRequest.getUserId())
                .switchIfEmpty(createEmptyFavorite(favoriteRequest))
                .transform(this::ensureNonNullLists)
                .flatMap(favorites -> favorites.addIngredient(favoriteRequest.getIngredientId()))
                .flatMap(favoriteDao::save)
                .map(saved -> success(INGREDIENT_SUCCESSFULLY_ADDED_TO_FAVORITES, saved))
                .onErrorResume(e -> handleError("addFavoriteIngredient", e));
    }

    /**
     * Removes a recipe from the user's favorites.
     *
     * @param favoriteRequest the favorite request containing the user ID and recipe ID
     * @return a Mono containing the response with the updated favorites
     */
    public Mono<Response> removeFavoriteRecipe(FavoriteRequest favoriteRequest) {
        return favoriteDao.findById(favoriteRequest.getUserId())
                .switchIfEmpty(createEmptyFavorite(favoriteRequest))
                .transform(this::ensureNonNullLists)
                .flatMap(favorites -> favorites.removeRecipe(favoriteRequest.getRecipeId()))
                .flatMap(favoriteDao::save)
                .map(saved -> success(RECIPE_SUCCESSFULLY_REMOVED_FROM_FAVORITES, saved))
                .onErrorResume(e -> handleError("removeFavoriteRecipe", e));
    }

    /**
     * Removes an ingredient from the user's favorites.
     *
     * @param favoriteRequest the favorite request containing the user ID and ingredient ID
     * @return a Mono containing the response with the updated favorites
     */
    public Mono<Response> removeFavoriteIngredient(FavoriteRequest favoriteRequest) {
        return favoriteDao.findById(favoriteRequest.getUserId())
                .switchIfEmpty(createEmptyFavorite(favoriteRequest))
                .transform(this::ensureNonNullLists)
                .flatMap(favorites -> favorites.removeIngredient(favoriteRequest.getIngredientId()))
                .flatMap(favoriteDao::save)
                .map(saved -> success(INGREDIENT_SUCCESSFULLY_REMOVED_FROM_FAVORITES, saved))
                .onErrorResume(e -> handleError("removeFavoriteIngredient", e));
    }

    /**
     * Creates an empty favorite entry for a user.
     *
     * @param favoriteRequest the favorite request containing the user ID
     * @return a Mono containing the created empty favorite entry
     */
    private Mono<FavoriteDto> createEmptyFavorite(FavoriteRequest favoriteRequest) {
        return Mono.defer(() -> Mono.just(new FavoriteDto(favoriteRequest.getUserId(), new ArrayList<>(), new ArrayList<>())));
    }

    /**
     * Ensures that the favorite lists are not null.
     *
     * @param favoriteDtoMono the Mono containing the favorite DTO
     * @return a Mono containing the favorite DTO with non-null lists
     */
    private Mono<FavoriteDto> ensureNonNullLists(Mono<FavoriteDto> favoriteDtoMono) {
        return favoriteDtoMono.map(favorites -> {
            favorites.setRecipes(Optional.ofNullable(favorites.getRecipes()).orElseGet(ArrayList::new));
            favorites.setIngredients(Optional.ofNullable(favorites.getIngredients()).orElseGet(ArrayList::new));
            return favorites;
        });
    }

    /**
     * Handles errors that occur during processing.
     *
     * @param methodName the name of the method where the error occurred
     * @param e          the throwable representing the error
     * @return a Mono containing the response with the error message
     */
    private Mono<Response> handleError(String methodName, Throwable e) {
        log.error("Error in {}: {}", methodName, e.getMessage(), e);
        return Response.monoError(e);
    }

}

package com.whatacook.cookers.service;

import com.whatacook.cookers.model.auth.ActivationDto;
import com.whatacook.cookers.model.users.UserDto;
import com.whatacook.cookers.service.contracts.ActivationDao;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

/**
 * Service class for handling activation-related operations.
 * <p>
 * Annotations:
 * - @Slf4j: Enables logging.
 * - @AllArgsConstructor: Generates a constructor with 1 parameter for each field.
 * - @Service: Indicates that this class is a Spring service.
 * <p>
 * Fields:
 * - DAO: The activation data access object for interacting with the database.
 * <p>
 * Methods:
 * - createNew(UserDto userDTO): Creates a new activation entry for a given user.
 * - findById(String id): Finds an activation entry by its ID.
 * - findByCode(String code): Finds an activation entry by its code and logs the result.
 * - deleteById(String id): Deletes an activation entry by its ID.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 * @see ActivationDao
 * @see ActivationDto
 * @see UserDto
 * @see Mono
 * @see Service
 * @see AllArgsConstructor
 * @see Slf4j
 */
@Slf4j
@AllArgsConstructor
@Service
public class ActivationService {

    private final ActivationDao DAO;

    public Mono<ActivationDto> createNew(UserDto userDTO) {
        return DAO.save(ActivationDto.to(userDTO));
    }

    public Mono<ActivationDto> findById(String id) {
        return DAO.findById(id);
    }

    public Mono<ActivationDto> findByCode(String code) {
        return DAO.findByCode(code)
                .doOnNext(dto -> log.info("ActivationDto encontrado: {}", dto))
                .doOnError(e -> log.error("Error al buscar ActivationDto", e));
    }

    public Mono<Void> deleteById(String id) {
        return DAO.deleteById(id);
    }

}

package com.whatacook.cookers.service;

import com.whatacook.cookers.config.SpringMailConfig;
import com.whatacook.cookers.model.auth.ActivationDto;
import com.whatacook.cookers.model.auth.ResetDto;
import com.whatacook.cookers.model.constants.Htmls;
import com.whatacook.cookers.model.exceptions.UserServiceException;
import com.whatacook.cookers.model.users.UserDto;
import com.whatacook.cookers.model.users.UserJson;
import com.whatacook.cookers.utilities.GlobalValues;
import jakarta.mail.MessagingException;
import jakarta.mail.internet.MimeMessage;
import lombok.AllArgsConstructor;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

/**
 * Service class for handling email-related operations.
 * <p>
 * Annotations:
 * - @AllArgsConstructor: Generates a constructor with 1 parameter for each field.
 * - @Component: Indicates that this class is a Spring component.
 * <p>
 * Fields:
 * - emailSender: The JavaMailSender instance for sending emails.
 * - springMailConfig: Configuration class for Spring Mail.
 * - activationService: Service for handling activation operations.
 * - resetService: Service for handling password reset operations.
 * - globalValues: Global values used in the application.
 * <p>
 * Methods:
 * - createActivationCodeAndSendEmail(UserDto userDTO): Creates an activation code and sends an email.
 * - sendActivationMail(ActivationDto activationDto, UserDto userDTO): Sends an activation email.
 * - buildMimeMessage(ActivationDto activationDto, UserDto userDTO): Builds a MimeMessage for activation.
 * - buildHtmlContentToActivateAccount(ActivationDto activationDto, UserDto userDTO): Builds HTML content for the activation email.
 * - sendEmail(MimeMessage message): Sends an email.
 * - createResetCodeAndSendEmail(UserDto userDTO): Creates a reset code and sends an email.
 * - sendResetMail(ResetDto resetCode, UserDto userDTO): Sends a reset email.
 * - buildMimeMessage(ResetDto resetCode, UserDto userDTO): Builds a MimeMessage for password reset.
 * - buildHtmlContentToResetAccount(ResetDto resetCode, UserDto userDTO): Builds HTML content for the reset email.
 *
 * @author <a href="https://about.me/prof.guazina">Fauno Guazina</a>
 * @see SpringMailConfig
 * @see ActivationService
 * @see ResetService
 * @see GlobalValues
 * @see JavaMailSender
 * @see MimeMessage
 * @see MimeMessageHelper
 * @see Htmls
 * @see UserDto
 * @see UserJson
 * @see Mono
 * @see MessagingException
 * @see AllArgsConstructor
 * @see Component
 */
@AllArgsConstructor
@Component
public class EmailService {

    private final JavaMailSender emailSender;
    private final SpringMailConfig springMailConfig;
    private final ActivationService activationService;
    private final ResetService resetService;
    private final GlobalValues globalValues;

    /**
     * Creates an activation code and sends an email.
     *
     * @param userDTO the user details to save
     * @return a Mono containing the user details without ID
     */
    public Mono<UserJson> createActivationCodeAndSendEmail(UserDto userDTO) {
        return activationService.createNew(userDTO)
                .flatMap(activation -> sendActivationMail(activation, userDTO));
    }

    /**
     * Sends an activation email.
     *
     * @param activationDto the activation details
     * @param userDTO       the user details
     * @return a Mono containing the user details without ID
     */
    public Mono<UserJson> sendActivationMail(ActivationDto activationDto, UserDto userDTO) {
        return Mono.fromCallable(() -> buildMimeMessage(activationDto, userDTO))
                .flatMap(this::sendEmail)
                .retry(2)
                .thenReturn(userDTO.toJsonWithoutId())
                .doOnError(UserServiceException::doOnErrorMap);
    }

    /**
     * Builds a MimeMessage for activation.
     *
     * @param activationDto the activation details
     * @param userDTO       the user details
     * @return the built MimeMessage
     * @throws MessagingException if an error occurs while building the message
     */
    private MimeMessage buildMimeMessage(ActivationDto activationDto, UserDto userDTO) throws MessagingException {
        MimeMessage message = emailSender.createMimeMessage();
        MimeMessageHelper helper = new MimeMessageHelper(message, true, "UTF-8");
        helper.setFrom(springMailConfig.getSpringMailUser());
        helper.setTo(userDTO.getEmail());
        helper.setSubject("WhataCook : Activaci√≥n de cuenta");
        String content = buildHtmlContentToActivateAccount(activationDto, userDTO);
        helper.setText(content, true);
        return message;
    }

    /**
     * Builds HTML content for the activation email.
     *
     * @param activationDto the activation details
     * @param userDTO       the user details
     * @return the HTML content
     */
    private String buildHtmlContentToActivateAccount(ActivationDto activationDto, UserDto userDTO) {
        String activationLink = globalValues.getUrlActivationAccount() + activationDto.getCode();
        return Htmls.ActivationEmail.get()
                .replace("LOGO_WAC", globalValues.getUrlWacLogoPngSmall())
                .replace("USER_NAME", userDTO.getFirstName())
                .replace("ACTIVATION_LINK", activationLink);
    }

    /**
     * Sends an email.
     *
     * @param message the MimeMessage to send
     * @return a Mono signaling completion
     */
    private Mono<Void> sendEmail(MimeMessage message) {
        return Mono.fromRunnable(() -> emailSender.send(message));
    }

    /**
     * Creates a reset code and sends an email.
     *
     * @param userDTO the user details to save
     * @return a Mono containing the user details without ID
     */
    public Mono<UserJson> createResetCodeAndSendEmail(UserDto userDTO) {
        return resetService.createNew(userDTO)
                .flatMap(resetCode -> sendResetMail(resetCode, userDTO));
    }

    /**
     * Sends a reset email.
     *
     * @param resetCode the reset details
     * @param userDTO   the user details
     * @return a Mono containing the user details without ID
     */
    public Mono<UserJson> sendResetMail(ResetDto resetCode, UserDto userDTO) {
        return Mono.fromCallable(() -> buildMimeMessage(resetCode, userDTO))
                .flatMap(this::sendEmail)
                .retry(2)
                .thenReturn(userDTO.toJsonWithoutId())
                .doOnError(UserServiceException::doOnErrorMap);
    }

    /**
     * Builds a MimeMessage for password reset.
     *
     * @param resetCode the reset details
     * @param userDTO   the user details
     * @return the built MimeMessage
     * @throws MessagingException if an error occurs while building the message
     */
    private MimeMessage buildMimeMessage(ResetDto resetCode, UserDto userDTO) throws MessagingException {
        MimeMessage message = emailSender.createMimeMessage();
        MimeMessageHelper helper = new MimeMessageHelper(message, true, "UTF-8");
        helper.setFrom(springMailConfig.getSpringMailUser());
        helper.setTo(userDTO.getEmail());
        helper.setSubject("WhataCook : reset contrase√±a");
        String content = buildHtmlContentToResetAccount(resetCode, userDTO);
        helper.setText(content, true);
        return message;
    }

    /**
     * Builds HTML content for the reset email.
     *
     * @param resetCode the reset details
     * @param userDTO   the user details
     * @return the HTML content
     */
    private String buildHtmlContentToResetAccount(ResetDto resetCode, UserDto userDTO) {
        String activationLink = globalValues.getUrlResetPassword() + resetCode.getCode();
        return Htmls.ResetPasswordMail.get()
                .replace("LOGO_WAC", globalValues.getUrlWacLogoPngSmall())
                .replace("USER_NAME", userDTO.getFirstName())
                .replace("ACTIVATION_LINK", activationLink);
    }
}

