[
  {
    "javadoc": "",
    "name": "mongoClient",
    "body": "{\n    return MongoClients.create(mongoUri);\n}",
    "parameters": "[]",
    "returnType": "MongoClient"
  },
  {
    "javadoc": "",
    "name": "reactiveMongoDatabaseFactory",
    "body": "{\n    return new SimpleReactiveMongoDatabaseFactory(mongoClient, DB_NAME);\n}",
    "parameters": "[MongoClient mongoClient]",
    "returnType": "ReactiveMongoDatabaseFactory"
  },
  {
    "javadoc": "",
    "name": "reactiveMongoTemplate",
    "body": "{\n    return new ReactiveMongoTemplate(reactiveMongoDatabaseFactory, mappingMongoConverter);\n}",
    "parameters": "[ReactiveMongoDatabaseFactory reactiveMongoDatabaseFactory, MappingMongoConverter mappingMongoConverter]",
    "returnType": "ReactiveMongoTemplate"
  },
  {
    "javadoc": "",
    "name": "mappingMongoConverter",
    "body": "{\n    MappingMongoConverter converter = new MappingMongoConverter(NoOpDbRefResolver.INSTANCE, mongoMappingContext);\n    converter.setTypeMapper(new DefaultMongoTypeMapper(null));\n    return converter;\n}",
    "parameters": "[MongoMappingContext mongoMappingContext]",
    "returnType": "MappingMongoConverter"
  },
  {
    "javadoc": "",
    "name": "contextLoads",
    "body": "{\n    assertThat(context).isNotNull();\n    assertThat(context.getBean(\"testMongoClient\")).isNotNull();\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "generateIngredientDtoList",
    "body": "{\n    MeasureDto cucharadita = new MeasureDto(\"measure-1\", \"Cucharadita\");\n    MeasureDto cucharada = new MeasureDto(\"measure-2\", \"Cucharada\");\n    MeasureDto taza = new MeasureDto(\"measure-3\", \"Taza\");\n    MeasureDto gramo = new MeasureDto(\"measure-11\", \"Gramo\");\n    MeasureDto kilogramo = new MeasureDto(\"measure-12\", \"Kilogramo\");\n    return Arrays.asList(new IngredientDto(\"ingredient-1\", \"Azúcar\", 100.0, gramo), new IngredientDto(\"ingredient-2\", \"Sal\", 200.0, gramo), new IngredientDto(\"ingredient-3\", \"Harina\", 1.0, kilogramo), new IngredientDto(\"ingredient-4\", \"Leche\", 2.0, taza), new IngredientDto(\"ingredient-5\", \"Aceite\", 3.0, cucharada), new IngredientDto(\"ingredient-6\", \"Huevos\", 4.0, cucharadita), new IngredientDto(\"ingredient-7\", \"Pollo\", 1.5, kilogramo), new IngredientDto(\"ingredient-8\", \"Tomates\", 2.5, kilogramo), new IngredientDto(\"ingredient-9\", \"Papas\", 1.2, kilogramo), new IngredientDto(\"ingredient-10\", \"Cebollas\", 1.0, kilogramo), new IngredientDto(\"ingredient-11\", \"Ajo\", 5.0, cucharadita), new IngredientDto(\"ingredient-12\", \"Zanahorias\", 0.5, kilogramo), new IngredientDto(\"ingredient-13\", \"Frijoles\", 1.0, taza), new IngredientDto(\"ingredient-14\", \"Arroz\", 2.0, taza), new IngredientDto(\"ingredient-15\", \"Lentejas\", 3.0, taza), new IngredientDto(\"ingredient-16\", \"Pan\", 6.0, cucharada), new IngredientDto(\"ingredient-17\", \"Mantequilla\", 7.0, cucharada), new IngredientDto(\"ingredient-18\", \"Queso\", 8.0, cucharada), new IngredientDto(\"ingredient-19\", \"Jamón\", 9.0, cucharada), new IngredientDto(\"ingredient-20\", \"Tocino\", 10.0, cucharada), new IngredientDto(\"ingredient-21\", \"Yogur\", 11.0, cucharada), new IngredientDto(\"ingredient-22\", \"Crema\", 12.0, cucharada), new IngredientDto(\"ingredient-23\", \"Café\", 13.0, cucharada), new IngredientDto(\"ingredient-24\", \"Té\", 14.0, cucharada), new IngredientDto(\"ingredient-25\", \"Agua\", 15.0, taza), new IngredientDto(\"ingredient-26\", \"Vino\", 16.0, taza), new IngredientDto(\"ingredient-27\", \"Cerveza\", 17.0, taza), new IngredientDto(\"ingredient-28\", \"Jugo\", 18.0, taza), new IngredientDto(\"ingredient-29\", \"Refresco\", 19.0, taza), new IngredientDto(\"ingredient-30\", \"Miel\", 20.0, cucharada), new IngredientDto(\"ingredient-31\", \"Canela\", 21.0, cucharadita), new IngredientDto(\"ingredient-32\", \"Pimienta\", 22.0, cucharadita), new IngredientDto(\"ingredient-33\", \"Perejil\", 23.0, cucharadita), new IngredientDto(\"ingredient-34\", \"Orégano\", 24.0, cucharadita), new IngredientDto(\"ingredient-35\", \"Tomillo\", 25.0, cucharadita), new IngredientDto(\"ingredient-36\", \"Albahaca\", 26.0, cucharadita));\n}",
    "parameters": "[]",
    "returnType": "List<IngredientDto>"
  },
  {
    "javadoc": "",
    "name": "getNumberLastElements",
    "body": "{\n    return amount % size == 0 ? size : amount % size;\n}",
    "parameters": "[]",
    "returnType": "int"
  },
  {
    "javadoc": "",
    "name": "getExpectedDto",
    "body": "{\n    List<T> sortedList = new ArrayList<>(listToSort);\n    sortedList.sort((a, b) -> desc ? b.getName().compareTo(a.getName()) : a.getName().compareTo(b.getName()));\n    int startIndex = page * size;\n    // if (startIndex >= sortedList.size() || startIndex < 0) {\n    // throw new IndexOutOfBoundsException(\"Start index is out of bounds\");\n    // }\n    return sortedList.get(startIndex);\n}",
    "parameters": "[boolean desc, List<T> listToSort]",
    "returnType": "T"
  },
  {
    "javadoc": "",
    "name": "TestGetByPathVariableFounded",
    "body": "{\n    webTestClient.get().uri(uriBuilder -> uriBuilder.path(pathVariable).build(valuePathVariable)).accept(APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"$.id\").isEqualTo(namedEntity.getId()).jsonPath(\"$.name\").isEqualTo(namedEntity.getName());\n}",
    "parameters": "[WebTestClient webTestClient, String pathVariable, String valuePathVariable, NamedEntity namedEntity]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "TestGetByPathVariableNotFound",
    "body": "{\n    webTestClient.get().uri(uriBuilder -> uriBuilder.path(pathVariable).build(valuePathVariable)).accept(APPLICATION_JSON).exchange().expectStatus().isNotFound();\n}",
    "parameters": "[WebTestClient webTestClient, String pathVariable, String valuePathVariable]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    MockitoAnnotations.openMocks(this);\n    recipeDtoFlux = Flux.fromIterable(recipeDtoList);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "createRecipesNew",
    "body": "{\n    when(recipeDao.findByNameIgnoreCase(anyString())).thenReturn(Mono.empty());\n    when(recipeDao.save(any(RecipeDto.class))).thenAnswer(i -> Mono.just(i.getArgument(0)));\n    when(ingredientDao.findByNameIgnoreCase(anyString())).thenReturn(Mono.empty());\n    when(ingredientDao.save(any(IngredientDto.class))).thenAnswer(i -> Mono.just(i.getArgument(0)));\n    when(categoryDao.findByNameIgnoreCase(anyString())).thenReturn(Mono.empty());\n    when(categoryDao.save(any(CategoryDto.class))).thenAnswer(i -> Mono.just(i.getArgument(0)));\n    when(measureDao.findByNameIgnoreCase(anyString())).thenReturn(Mono.empty());\n    when(measureDao.save(any(MeasureDto.class))).thenAnswer(i -> Mono.just(i.getArgument(0)));\n    testCreateRecipes();\n    verify(recipeDao, times(recipeDtoList.size())).save(any(RecipeDto.class));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "createRecipesExistingRecipes",
    "body": "{\n    when(recipeDao.findByNameIgnoreCase(anyString())).thenAnswer(invocation -> {\n        String name = invocation.getArgument(0);\n        return recipeDtoList.stream().filter(recipeDto -> recipeDto.getName().equalsIgnoreCase(name)).findFirst().map(Mono::just).orElse(Mono.empty());\n    });\n    testCreateRecipes();\n    verify(recipeDao, times(0)).save(any(RecipeDto.class));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testCreateRecipes",
    "body": "{\n    webTestClient.post().uri(recipesUri + PATH_Bulk).body(recipeDtoFlux, RecipeDto.class).exchange().expectStatus().isOk().expectBodyList(RecipeDto.class).hasSize(recipeDtoList.size()).value(recipes -> {\n        List<String> responseNames = recipes.stream().map(RecipeDto::getName).toList();\n        assert responseNames.contains(recipeDtoList.getFirst().getName());\n        assert responseNames.contains(recipeDtoList.getLast().getName());\n    });\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "generateRecipeDtoList",
    "body": "{\n    CategoryDto categoria1 = new CategoryDto(\"category-1\", \"Desayuno\");\n    CategoryDto categoria2 = new CategoryDto(\"category-2\", \"Almuerzo\");\n    CategoryDto categoria3 = new CategoryDto(\"category-3\", \"Cena\");\n    CategoryDto categoria4 = new CategoryDto(\"category-4\", \"Postre\");\n    return Arrays.asList(new RecipeDto(\"recipe-1\", \"Receta de Azúcar\", List.of(ingredientDtoList.getFirst(), ingredientDtoList.get(10)), List.of(categoria4), \"Preparación de receta de azúcar\", 4), new RecipeDto(\"recipe-2\", \"Receta de Sal\", List.of(ingredientDtoList.get(1), ingredientDtoList.get(11)), List.of(categoria2), \"Preparación de receta de sal\", 2), new RecipeDto(\"recipe-3\", \"Receta de Harina\", List.of(ingredientDtoList.get(2), ingredientDtoList.get(12)), List.of(categoria1), \"Preparación de receta de harina\", 6), new RecipeDto(\"recipe-4\", \"Receta de Leche\", List.of(ingredientDtoList.get(3), ingredientDtoList.get(13)), List.of(categoria3), \"Preparación de receta de leche\", 1), new RecipeDto(\"recipe-5\", \"Receta de Aceite\", List.of(ingredientDtoList.get(4), ingredientDtoList.get(14)), List.of(categoria4), \"Preparación de receta de aceite\", 3), new RecipeDto(\"recipe-6\", \"Receta de Huevos\", List.of(ingredientDtoList.get(5), ingredientDtoList.get(15)), List.of(categoria2), \"Preparación de receta de huevos\", 5), new RecipeDto(\"recipe-7\", \"Receta de Pollo\", List.of(ingredientDtoList.get(6), ingredientDtoList.get(16)), List.of(categoria1), \"Preparación de receta de pollo\", 4), new RecipeDto(\"recipe-8\", \"Receta de Tomates\", List.of(ingredientDtoList.get(7), ingredientDtoList.get(17)), List.of(categoria3), \"Preparación de receta de tomates\", 2), new RecipeDto(\"recipe-9\", \"Receta de Papas\", List.of(ingredientDtoList.get(8), ingredientDtoList.get(18)), List.of(categoria4), \"Preparación de receta de papas\", 7), new RecipeDto(\"recipe-10\", \"Receta de Cebollas\", List.of(ingredientDtoList.get(9), ingredientDtoList.get(19)), List.of(categoria2), \"Preparación de receta de cebollas\", 3), new RecipeDto(\"recipe-11\", \"Receta de Frijoles\", List.of(ingredientDtoList.get(12), ingredientDtoList.get(1)), List.of(categoria1), \"Preparación de receta de frijoles\", 8), new RecipeDto(\"recipe-12\", \"Receta de Arroz\", List.of(ingredientDtoList.get(13), ingredientDtoList.get(3)), List.of(categoria3), \"Preparación de receta de arroz\", 6), new RecipeDto(\"recipe-13\", \"Receta de Lentejas\", List.of(ingredientDtoList.get(14), ingredientDtoList.getFirst()), List.of(categoria4), \"Preparación de receta de lentejas\", 5), new RecipeDto(\"recipe-14\", \"Receta de Pan\", List.of(ingredientDtoList.get(15), ingredientDtoList.get(2)), List.of(categoria2), \"Preparación de receta de pan\", 2), new RecipeDto(\"recipe-15\", \"Receta de Mantequilla\", List.of(ingredientDtoList.get(16), ingredientDtoList.get(4)), List.of(categoria1), \"Preparación de receta de mantequilla\", 3), new RecipeDto(\"recipe-16\", \"Receta de Queso\", List.of(ingredientDtoList.get(17), ingredientDtoList.get(5)), List.of(categoria3), \"Preparación de receta de queso\", 1), new RecipeDto(\"recipe-17\", \"Receta de Jamón\", List.of(ingredientDtoList.get(18), ingredientDtoList.get(6)), List.of(categoria4), \"Preparación de receta de jamón\", 2), new RecipeDto(\"recipe-18\", \"Receta de Tocino\", List.of(ingredientDtoList.get(19), ingredientDtoList.get(7)), List.of(categoria2), \"Preparación de receta de tocino\", 3), new RecipeDto(\"recipe-19\", \"Receta de Yogur\", List.of(ingredientDtoList.get(20), ingredientDtoList.get(8)), List.of(categoria1), \"Preparación de receta de yogur\", 4), new RecipeDto(\"recipe-20\", \"Receta de Crema\", List.of(ingredientDtoList.get(21), ingredientDtoList.get(9)), List.of(categoria3), \"Preparación de receta de crema\", 5), new RecipeDto(\"recipe-21\", \"Receta de Café\", List.of(ingredientDtoList.get(22), ingredientDtoList.get(10)), List.of(categoria4), \"Preparación de receta de café\", 6), new RecipeDto(\"recipe-22\", \"Receta de Té\", List.of(ingredientDtoList.get(23), ingredientDtoList.get(11)), List.of(categoria2), \"Preparación de receta de té\", 7), new RecipeDto(\"recipe-23\", \"Receta de Agua\", List.of(ingredientDtoList.get(24), ingredientDtoList.get(12)), List.of(categoria1), \"Preparación de receta de agua\", 8), new RecipeDto(\"recipe-24\", \"Receta de Vino\", List.of(ingredientDtoList.get(25), ingredientDtoList.get(13)), List.of(categoria3), \"Preparación de receta de vino\", 1), new RecipeDto(\"recipe-25\", \"Receta de Cerveza\", List.of(ingredientDtoList.get(26), ingredientDtoList.get(14)), List.of(categoria4), \"Preparación de receta de cerveza\", 2), new RecipeDto(\"recipe-26\", \"Receta de Jugo\", List.of(ingredientDtoList.get(27), ingredientDtoList.get(15)), List.of(categoria2), \"Preparación de receta de jugo\", 3), new RecipeDto(\"recipe-27\", \"Receta de Refresco\", List.of(ingredientDtoList.get(28), ingredientDtoList.get(16)), List.of(categoria1), \"Preparación de receta de refresco\", 4), new RecipeDto(\"recipe-28\", \"Receta de Miel\", List.of(ingredientDtoList.get(29), ingredientDtoList.get(17)), List.of(categoria3), \"Preparación de receta de miel\", 5), new RecipeDto(\"recipe-29\", \"Receta de Canela\", List.of(ingredientDtoList.get(30), ingredientDtoList.get(18)), List.of(categoria4), \"Preparación de receta de canela\", 6), new RecipeDto(\"recipe-30\", \"Receta de Pimienta\", List.of(ingredientDtoList.get(31), ingredientDtoList.get(19)), List.of(categoria2), \"Preparación de receta de pimienta\", 7), new RecipeDto(\"recipe-31\", \"Receta de Perejil\", List.of(ingredientDtoList.get(32), ingredientDtoList.get(20)), List.of(categoria1), \"Preparación de receta de perejil\", 8), new RecipeDto(\"recipe-32\", \"Receta de Orégano\", List.of(ingredientDtoList.get(33), ingredientDtoList.get(21)), List.of(categoria3), \"Preparación de receta de orégano\", 1), new RecipeDto(\"recipe-33\", \"Receta de Tomillo\", List.of(ingredientDtoList.get(34), ingredientDtoList.get(22)), List.of(categoria4), \"Preparación de receta de tomillo\", 2), new RecipeDto(\"recipe-34\", \"Receta de Albahaca\", List.of(ingredientDtoList.get(35), ingredientDtoList.get(23)), List.of(categoria2), \"Preparación de receta de albahaca\", 3), new RecipeDto(\"recipe-35\", \"Receta de Azúcar y Canela\", List.of(ingredientDtoList.getFirst(), ingredientDtoList.get(30)), List.of(categoria4), \"Preparación de receta de azúcar y canela\", 4), new RecipeDto(\"recipe-36\", \"Receta de Miel y Yogur\", List.of(ingredientDtoList.get(29), ingredientDtoList.get(20)), List.of(categoria1), \"Preparación de receta de miel y yogur\", 2));\n}",
    "parameters": "[]",
    "returnType": "List<RecipeDto>"
  },
  {
    "javadoc": "",
    "name": "getExpectedRecipeDto",
    "body": "{\n    List<RecipeDto> listToSort = (otherRecipeDtoList == null) ? recipeDtoList : otherRecipeDtoList;\n    return getExpectedDto(desc, listToSort);\n}",
    "parameters": "[boolean desc, List<RecipeDto> otherRecipeDtoList]",
    "returnType": "RecipeDto"
  },
  {
    "javadoc": "",
    "name": "generateRecipeDto",
    "body": "{\n    CategoryDto categoria1 = new CategoryDto(\"category-1\", \"Desayuno\");\n    return new RecipeDto(\"recipe-1\", \"Receta de Azúcar\", List.of(ingredientDtoList.getFirst(), ingredientDtoList.get(10)), List.of(categoria1), \"Preparación de receta de azúcar\", 4);\n}",
    "parameters": "[]",
    "returnType": "RecipeDto"
  },
  {
    "javadoc": "",
    "name": "generateRecipeDtoListStatic",
    "body": "{\n    return new BaseRecipesTest().recipeDtoList;\n}",
    "parameters": "[]",
    "returnType": "List<RecipeDto>"
  },
  {
    "javadoc": "",
    "name": "generateRecipeDtoStatic",
    "body": "{\n    return new BaseRecipesTest().recipeDtoList.getFirst();\n}",
    "parameters": "[]",
    "returnType": "RecipeDto"
  },
  {
    "javadoc": "",
    "name": "validateResponse",
    "body": "{\n    webTestClient.get().uri(uriBuilder -> uriBuilder.path(path).queryParam(\"page\", page).queryParam(\"size\", size).queryParam(\"mode\", mode).queryParam(queryParam, queryParamValue).build()).exchange().expectStatus().isOk().expectBody().jsonPath(\"$.content\").isArray().jsonPath(\"$.content.length()\").isEqualTo(recipeDtoListFiltered.size()).jsonPath(\"$.content[0].id\").isEqualTo(expectedFirstRecipe.getId()).jsonPath(\"$.content[0].name\").isEqualTo(expectedFirstRecipe.getName()).jsonPath(\"$.pageable.pageNumber\").isEqualTo(page).jsonPath(\"$.pageable.pageSize\").isEqualTo(size).jsonPath(\"$.totalElements\").isEqualTo(recipeDtoListFiltered.size()).jsonPath(\"$.totalPages\").isEqualTo((int) Math.ceil((double) recipeDtoListFiltered.size() / size)).jsonPath(\"$.first\").isEqualTo(true).jsonPath(\"$.last\").isEqualTo(true);\n}",
    "parameters": "[String path, String mode, String queryParam, String queryParamValue, RecipeDto expectedFirstRecipe, List<RecipeDto> recipeDtoListFiltered]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    MockitoAnnotations.openMocks(this);\n    pathVariable = recipesUri + PATH_ByName;\n    size = 10;\n    page = 0;\n    queryParam = \"name\";\n    queryParamValue = \"c\";\n    recipeDtoListFiltered = recipeDtoList.stream().filter(recipe -> recipe.getName().replace(\"Receta de \", \"\").contains(queryParamValue)).collect(Collectors.toList());\n    when(recipeDao.findByNameContainingIgnoreCase(queryParamValue)).thenReturn(Flux.fromIterable(recipeDtoListFiltered));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getExpectedRecipeDto",
    "body": "{\n    return getExpectedRecipeDto(desc, recipeDtoListFiltered);\n}",
    "parameters": "[boolean desc]",
    "returnType": "RecipeDto"
  },
  {
    "javadoc": "",
    "name": "getRecipesByNameContainingAsc",
    "body": "{\n    validateResponse(pathVariable, \"\", queryParam, queryParamValue, getExpectedRecipeDto(false), recipeDtoListFiltered);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getRecipesByNameContainingDesc",
    "body": "{\n    validateResponse(pathVariable, \"D\", queryParam, queryParamValue, getExpectedRecipeDto(true), recipeDtoListFiltered);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    MockitoAnnotations.openMocks(this);\n    pathVariable = recipesUri + PATH_ByIngredients;\n    size = 10;\n    page = 0;\n    // Azúcar, Zanahorias\n    ingredientSelected = List.of(ingredientDtoList.getFirst(), ingredientDtoList.get(11));\n    List<String> ingredientNames = ingredientSelected.stream().map(IngredientDto::getName).toList();\n    queryParam = \"ingredients\";\n    queryParamValue = String.join(\",\", ingredientNames);\n    recipeDtoListFiltered = recipeDtoList.stream().filter(recipe -> recipe.getIngredients().contains(ingredientSelected.getFirst()) || recipe.getIngredients().contains(ingredientSelected.getLast())).toList();\n    when(recipeDao.findByIngredientsNameIn(ingredientNames)).thenReturn(Flux.fromIterable(recipeDtoListFiltered));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getExpectedRecipeDto",
    "body": "{\n    return getExpectedRecipeDto(desc, recipeDtoListFiltered);\n}",
    "parameters": "[boolean desc]",
    "returnType": "RecipeDto"
  },
  {
    "javadoc": "",
    "name": "getRecipesByIngredientsAsc",
    "body": "{\n    validateResponse(pathVariable, \"\", queryParam, queryParamValue, getExpectedRecipeDto(false), recipeDtoListFiltered);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getRecipesByIngredientsDesc",
    "body": "{\n    validateResponse(pathVariable, \"D\", queryParam, queryParamValue, getExpectedRecipeDto(true), recipeDtoListFiltered);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    MockitoAnnotations.openMocks(this);\n    pathVariable = recipesUri + PATH_ByAllIngredients;\n    size = 10;\n    page = 0;\n    // Azúcar, Arroz\n    ingredientSelected = List.of(ingredientDtoList.getFirst(), ingredientDtoList.get(14));\n    List<String> ingredientNames = ingredientSelected.stream().map(IngredientDto::getName).toList();\n    queryParam = \"ingredients\";\n    queryParamValue = String.join(\",\", ingredientNames);\n    recipeDtoListFiltered = recipeDtoList.stream().filter(recipe -> recipe.getIngredients().contains(ingredientSelected.getFirst()) && recipe.getIngredients().contains(ingredientSelected.getLast())).toList();\n    when(recipeDao.findByAllIngredientsNameIn(ingredientNames)).thenReturn(Flux.fromIterable(recipeDtoListFiltered));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getExpectedRecipeDto",
    "body": "{\n    return getExpectedRecipeDto(desc, recipeDtoListFiltered);\n}",
    "parameters": "[boolean desc]",
    "returnType": "RecipeDto"
  },
  {
    "javadoc": "",
    "name": "getRecipesByIngredientsAsc",
    "body": "{\n    validateResponse(pathVariable, \"\", queryParam, queryParamValue, getExpectedRecipeDto(false), recipeDtoListFiltered);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getRecipesByIngredientsDesc",
    "body": "{\n    validateResponse(pathVariable, \"D\", queryParam, queryParamValue, getExpectedRecipeDto(true), recipeDtoListFiltered);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    MockitoAnnotations.openMocks(this);\n    recipeDto = generateRecipeDto();\n    pathVariable = recipesUri + PATH_VARIABLE_ID;\n    valuePathVariable = recipeDto.getId();\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testDeleteRecipeByIdFounded",
    "body": "{\n    when(recipeDao.findById(anyString())).thenReturn(Mono.just(recipeDto));\n    when(recipeDao.delete(recipeDto)).thenReturn(Mono.empty());\n    webTestClient.delete().uri(uriBuilder -> uriBuilder.path(pathVariable).build(valuePathVariable)).accept(APPLICATION_JSON).exchange().expectStatus().isOk().expectBody(String.class).value(response -> {\n        assert response.contains(recipeDto.getName());\n        assert response.contains(DELETED);\n    });\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testDeleteRecipeByIdNotFound",
    "body": "{\n    when(recipeDao.findById(anyString())).thenReturn(Mono.empty());\n    webTestClient.delete().uri(uriBuilder -> uriBuilder.path(pathVariable).build(valuePathVariable)).accept(APPLICATION_JSON).exchange().expectStatus().isNotFound();\n    verify(recipeDao, times(0)).delete(any(RecipeDto.class));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    MockitoAnnotations.openMocks(this);\n    size = 10;\n    amount = recipeDtoList.size();\n    when(recipeDao.findAll()).thenReturn(Flux.fromIterable(recipeDtoList));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "validateResponse",
    "body": "{\n    webTestClient.get().uri(uriBuilder -> uriBuilder.path(recipesUri).queryParam(\"page\", page).queryParam(\"size\", size).queryParam(\"mode\", mode).build()).exchange().expectStatus().isOk().expectBody().jsonPath(\"$.content\").isArray().jsonPath(\"$.content.length()\").isEqualTo(numberOfElements).jsonPath(\"$.content[0].id\").isEqualTo(expectedFirstRecipe.getId()).jsonPath(\"$.content[0].name\").isEqualTo(expectedFirstRecipe.getName()).jsonPath(\"$.pageable.pageNumber\").isEqualTo(page).jsonPath(\"$.pageable.pageSize\").isEqualTo(size).jsonPath(\"$.totalElements\").isEqualTo(amount).jsonPath(\"$.totalPages\").isEqualTo((int) Math.ceil((double) amount / size)).jsonPath(\"$.first\").isEqualTo(isFirst).jsonPath(\"$.last\").isEqualTo(isLast);\n}",
    "parameters": "[String mode, RecipeDto expectedFirstRecipe, boolean isFirst, boolean isLast, int numberOfElements]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getAllRecipesPage0Asc",
    "body": "{\n    page = 0;\n    RecipeDto expectedFirstRecipe = getExpectedRecipeDto(false, null);\n    validateResponse(\"\", expectedFirstRecipe, true, false, size);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getAllRecipesPage0Desc",
    "body": "{\n    page = 0;\n    RecipeDto expectedFirstRecipe = getExpectedRecipeDto(true, null);\n    validateResponse(\"D\", expectedFirstRecipe, true, false, size);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getAllRecipesPage3Asc",
    "body": "{\n    page = 3;\n    RecipeDto expectedFirstRecipe = getExpectedRecipeDto(false, null);\n    validateResponse(\"\", expectedFirstRecipe, false, true, getNumberLastElements());\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getAllRecipesPage3Desc",
    "body": "{\n    page = 3;\n    RecipeDto expectedFirstRecipe = getExpectedRecipeDto(true, null);\n    validateResponse(\"D\", expectedFirstRecipe, false, true, getNumberLastElements());\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    MockitoAnnotations.openMocks(this);\n    recipeDto = generateRecipeDtoStatic();\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "createRecipe",
    "body": "{\n    when(recipeDao.findByNameIgnoreCase(anyString())).thenReturn(Mono.empty());\n    when(recipeDao.save(any(RecipeDto.class))).thenReturn(Mono.just(recipeDto));\n    when(ingredientDao.findByNameIgnoreCase(anyString())).thenReturn(Mono.empty());\n    when(ingredientDao.save(any(IngredientDto.class))).thenAnswer(i -> Mono.just(i.getArgument(0)));\n    when(categoryDao.findByNameIgnoreCase(anyString())).thenReturn(Mono.empty());\n    when(categoryDao.save(any(CategoryDto.class))).thenAnswer(i -> Mono.just(i.getArgument(0)));\n    when(measureDao.findByNameIgnoreCase(anyString())).thenReturn(Mono.empty());\n    when(measureDao.save(any(MeasureDto.class))).thenReturn(Mono.just(recipeDto.getIngredients().getFirst().getMeasure()));\n    verifyCreationRecipe();\n    verify(recipeDao, times(1)).save(any(RecipeDto.class));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "createRecipeAlreadyExists",
    "body": "{\n    when(recipeDao.findByNameIgnoreCase(anyString())).thenReturn(Mono.just(recipeDto));\n    verifyCreationRecipe();\n    verify(recipeDao, times(0)).save(any(RecipeDto.class));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "verifyCreationRecipe",
    "body": "{\n    webTestClient.post().uri(recipesUri).contentType(APPLICATION_JSON).body(fromValue(recipeDto)).exchange().expectStatus().isOk().expectBody().jsonPath(\"$.id\").isEqualTo(recipeDto.getId()).jsonPath(\"$.name\").isEqualTo(recipeDto.getName());\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    MockitoAnnotations.openMocks(this);\n    recipeDto = generateRecipeDto();\n    pathVariable = recipesUri + PATH_NAME;\n    valuePathVariable = recipeDto.getName();\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getRecipeByNameFound",
    "body": "{\n    when(recipeDao.findByNameIgnoreCase(anyString())).thenReturn(Mono.just(recipeDto));\n    TestGetByPathVariableFounded(webTestClient, pathVariable, valuePathVariable, recipeDto);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getRecipeByNameNotFound",
    "body": "{\n    when(recipeDao.findByNameIgnoreCase(anyString())).thenReturn(Mono.empty());\n    TestGetByPathVariableNotFound(webTestClient, pathVariable, valuePathVariable);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    MockitoAnnotations.openMocks(this);\n    recipeDto = generateRecipeDto();\n    pathVariable = recipesUri + PATH_ID;\n    valuePathVariable = recipeDto.getId();\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getRecipeByIdFound",
    "body": "{\n    when(recipeDao.findById(anyString())).thenReturn(Mono.just(recipeDto));\n    TestGetByPathVariableFounded(webTestClient, pathVariable, valuePathVariable, recipeDto);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getRecipeByIdNotFound",
    "body": "{\n    when(recipeDao.findById(anyString())).thenReturn(Mono.empty());\n    TestGetByPathVariableNotFound(webTestClient, pathVariable, valuePathVariable);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    MockitoAnnotations.openMocks(this);\n    pathVariable = recipesUri + byIdsEndpoint;\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testGetRecipesByIds",
    "body": "{\n    RecipeDto recipe1 = recipeDtoList.getFirst();\n    RecipeDto recipe2 = recipeDtoList.getLast();\n    String idNotFounded = \"recipe-40\";\n    List<String> ids = Arrays.asList(recipe1.getId(), recipe2.getId(), idNotFounded);\n    List<RecipeDto> foundRecipes = Arrays.asList(recipe1, recipe2);\n    List<String> notFoundIds = Arrays.asList(idNotFounded);\n    Map<String, Object> response = new HashMap<>();\n    response.put(\"found\", foundRecipes);\n    response.put(\"notFound\", notFoundIds);\n    when(recipeDao.findAllById(anyList())).thenReturn(Flux.fromIterable(foundRecipes));\n    webTestClient.post().uri(pathVariable).contentType(MediaType.APPLICATION_JSON).bodyValue(ids).exchange().expectStatus().isOk().expectBody().jsonPath(\"$.found\").isArray().jsonPath(\"$.found.length()\").isEqualTo(foundRecipes.size()).jsonPath(\"$.found[0].id\").isEqualTo(recipe1.getId()).jsonPath(\"$.found[0].name\").isEqualTo(recipe1.getName()).jsonPath(\"$.notFound\").isArray().jsonPath(\"$.notFound.length()\").isEqualTo(notFoundIds.size()).jsonPath(\"$.notFound[0]\").isEqualTo(notFoundIds.getFirst());\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    MockitoAnnotations.openMocks(this);\n    pathVariable = ingredientsUri + byIdsEndpoint;\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testGetIngredientsByIds",
    "body": "{\n    IngredientDto ingredient1 = ingredientDtoList.getFirst();\n    IngredientDto ingredient2 = ingredientDtoList.getLast();\n    String idNotFounded = \"ingredient-3\";\n    List<String> ids = Arrays.asList(ingredient1.getId(), ingredient2.getId(), idNotFounded);\n    List<IngredientDto> foundIngredients = Arrays.asList(ingredient1, ingredient2);\n    List<String> notFoundIds = List.of(idNotFounded);\n    Map<String, Object> response = new HashMap<>();\n    response.put(\"found\", foundIngredients);\n    response.put(\"notFound\", notFoundIds);\n    when(ingredientDao.findAllById(anyList())).thenReturn(Flux.fromIterable(foundIngredients));\n    webTestClient.post().uri(pathVariable).contentType(MediaType.APPLICATION_JSON).bodyValue(ids).exchange().expectStatus().isOk().expectBody().jsonPath(\"$.found\").isArray().jsonPath(\"$.found.length()\").isEqualTo(foundIngredients.size()).jsonPath(\"$.found[0].id\").isEqualTo(ingredient1.getId()).jsonPath(\"$.found[0].name\").isEqualTo(ingredient1.getName()).jsonPath(\"$.notFound\").isArray().jsonPath(\"$.notFound.length()\").isEqualTo(notFoundIds.size()).jsonPath(\"$.notFound[0]\").isEqualTo(notFoundIds.getFirst());\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "generateIngredientDto",
    "body": "{\n    MeasureDto cucharadita = new MeasureDto(\"measure-1\", \"Cucharadita\");\n    return new IngredientDto(\"ingredient-1\", \"Azúcar\", 1.0, cucharadita);\n}",
    "parameters": "[]",
    "returnType": "IngredientDto"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    MockitoAnnotations.openMocks(this);\n    ingredientDto = generateIngredientDto();\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "createIngredient",
    "body": "{\n    when(measureDao.findByNameIgnoreCase(anyString())).thenReturn(Mono.empty());\n    when(measureDao.save(any(MeasureDto.class))).thenReturn(Mono.just(ingredientDto.getMeasure()));\n    when(ingredientDao.findByNameIgnoreCase(anyString())).thenReturn(Mono.empty());\n    when(ingredientDao.save(any(IngredientDto.class))).thenAnswer(i -> Mono.just(i.getArgument(0)));\n    verifyCreationIngredient();\n    verify(measureDao, times(1)).findByNameIgnoreCase(anyString());\n    verify(measureDao, times(1)).save(any(MeasureDto.class));\n    verify(ingredientDao, times(1)).findByNameIgnoreCase(anyString());\n    verify(ingredientDao, times(1)).save(any(IngredientDto.class));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "createIngredientWithExistingMeasure",
    "body": "{\n    when(measureDao.findByNameIgnoreCase(anyString())).thenReturn(Mono.just(ingredientDto.getMeasure()));\n    when(measureDao.findByNameIgnoreCase(anyString())).thenReturn(Mono.just(ingredientDto.getMeasure()));\n    when(ingredientDao.findByNameIgnoreCase(anyString())).thenReturn(Mono.empty());\n    when(ingredientDao.save(any(IngredientDto.class))).thenAnswer(i -> Mono.just(i.getArgument(0)));\n    verifyCreationIngredient();\n    verify(measureDao, times(1)).findByNameIgnoreCase(anyString());\n    verify(measureDao, times(0)).save(any(MeasureDto.class));\n    verify(ingredientDao, times(1)).findByNameIgnoreCase(anyString());\n    verify(ingredientDao, times(1)).save(any(IngredientDto.class));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "createIngredientAlreadyExists",
    "body": "{\n    when(ingredientDao.findByNameIgnoreCase(anyString())).thenReturn(Mono.just(ingredientDto));\n    when(measureDao.findByNameIgnoreCase(anyString())).thenReturn(Mono.just(ingredientDto.getMeasure()));\n    verifyCreationIngredient();\n    verify(measureDao, times(1)).findByNameIgnoreCase(anyString());\n    verify(measureDao, times(0)).save(any(MeasureDto.class));\n    verify(ingredientDao, times(1)).findByNameIgnoreCase(anyString());\n    verify(ingredientDao, times(0)).save(any(IngredientDto.class));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "verifyCreationIngredient",
    "body": "{\n    webTestClient.post().uri(ingredientsUri).contentType(APPLICATION_JSON).body(fromValue(ingredientDto)).exchange().expectStatus().isOk().expectBody().jsonPath(\"$.id\").isEqualTo(ingredientDto.getId()).jsonPath(\"$.name\").isEqualTo(ingredientDto.getName());\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    MockitoAnnotations.openMocks(this);\n    ingredientDto = generateIngredientDto();\n    pathVariable = ingredientsUri + PATH_NAME;\n    valuePathVariable = ingredientDto.getName();\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getIngredientByNameFound",
    "body": "{\n    when(ingredientDao.findByNameIgnoreCase(anyString())).thenReturn(Mono.just(ingredientDto));\n    TestGetByPathVariableFounded(webTestClient, pathVariable, valuePathVariable, ingredientDto);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getIngredientByNameNotFound",
    "body": "{\n    when(ingredientDao.findByNameIgnoreCase(anyString())).thenReturn(Mono.empty());\n    TestGetByPathVariableNotFound(webTestClient, pathVariable, valuePathVariable);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    MockitoAnnotations.openMocks(this);\n    queryParamValue = \"c\";\n    size = 10;\n    ingredientDtoListFiltered = ingredientDtoList.stream().filter(ingredient -> ingredient.getName().contains(queryParamValue)).collect(Collectors.toList());\n    when(ingredientDao.findByNameContainingIgnoreCase(queryParamValue)).thenReturn(Flux.fromIterable(ingredientDtoListFiltered));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "validateResponse",
    "body": "{\n    webTestClient.get().uri(uriBuilder -> uriBuilder.path(ingredientsUri + PATH_ByName).queryParam(\"page\", page).queryParam(\"size\", size).queryParam(\"mode\", mode).queryParam(\"name\", name).build()).exchange().expectStatus().isOk().expectBody().jsonPath(\"$.content\").isArray().jsonPath(\"$.content.length()\").isEqualTo(numberOfElements).jsonPath(\"$.content[0].id\").isEqualTo(expectedFirstIngredient.getId()).jsonPath(\"$.content[0].name\").isEqualTo(expectedFirstIngredient.getName()).jsonPath(\"$.pageable.pageNumber\").isEqualTo(page).jsonPath(\"$.pageable.pageSize\").isEqualTo(size).jsonPath(\"$.totalElements\").isEqualTo(ingredientDtoListFiltered.size()).jsonPath(\"$.totalPages\").isEqualTo((int) Math.ceil((double) ingredientDtoListFiltered.size() / size)).jsonPath(\"$.first\").isEqualTo(true).jsonPath(\"$.last\").isEqualTo(true);\n}",
    "parameters": "[String mode, String name, IngredientDto expectedFirstIngredient, int numberOfElements]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getIngredientsByNameContainingAsc",
    "body": "{\n    page = 0;\n    IngredientDto expectedFirstIngredient = getExpectedIngredientDto(false, ingredientDtoListFiltered);\n    validateResponse(\"\", queryParamValue, expectedFirstIngredient, ingredientDtoListFiltered.size());\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getIngredientsByNameContainingDesc",
    "body": "{\n    page = 0;\n    IngredientDto expectedFirstIngredient = getExpectedIngredientDto(true, ingredientDtoListFiltered);\n    validateResponse(\"D\", queryParamValue, expectedFirstIngredient, ingredientDtoListFiltered.size());\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    MockitoAnnotations.openMocks(this);\n    ingredientDto = generateIngredientDto();\n    pathVariable = \"/{id}\";\n    valuePathVariable = ingredientDto.getId();\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testDeleteIngredientByIdFounded",
    "body": "{\n    when(ingredientDao.findById(anyString())).thenReturn(Mono.just(ingredientDto));\n    when(ingredientDao.delete(ingredientDto)).thenReturn(Mono.empty());\n    webTestClient.delete().uri(uriBuilder -> uriBuilder.path(ingredientsUri + pathVariable).build(valuePathVariable)).accept(APPLICATION_JSON).exchange().expectStatus().isOk().expectBody(String.class).value(response -> {\n        assert response.contains(ingredientDto.getName());\n        assert response.contains(DELETED);\n    });\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testDeleteIngredientByIdNotFound",
    "body": "{\n    when(ingredientDao.findById(anyString())).thenReturn(Mono.empty());\n    webTestClient.delete().uri(uriBuilder -> uriBuilder.path(ingredientsUri + pathVariable).build(valuePathVariable)).accept(APPLICATION_JSON).exchange().expectStatus().isNotFound();\n    verify(ingredientDao, times(0)).delete(any(IngredientDto.class));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    MockitoAnnotations.openMocks(this);\n    size = 10;\n    when(ingredientDao.findAll()).thenReturn(Flux.fromIterable(ingredientDtoList));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "validateResponse",
    "body": "{\n    webTestClient.get().uri(uriBuilder -> uriBuilder.path(ingredientsUri).queryParam(\"page\", page).queryParam(\"size\", size).queryParam(\"mode\", mode).build()).exchange().expectStatus().isOk().expectBody().jsonPath(\"$.content\").isArray().jsonPath(\"$.content.length()\").isEqualTo(numberOfElements).jsonPath(\"$.content[0].id\").isEqualTo(expectedFirstIngredient.getId()).jsonPath(\"$.content[0].name\").isEqualTo(expectedFirstIngredient.getName()).jsonPath(\"$.pageable.pageNumber\").isEqualTo(page).jsonPath(\"$.pageable.pageSize\").isEqualTo(size).jsonPath(\"$.totalElements\").isEqualTo(amount).jsonPath(\"$.totalPages\").isEqualTo((int) Math.ceil((double) amount / size)).jsonPath(\"$.first\").isEqualTo(isFirst).jsonPath(\"$.last\").isEqualTo(isLast);\n}",
    "parameters": "[String mode, IngredientDto expectedFirstIngredient, boolean isFirst, boolean isLast, int numberOfElements]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getAllIngredientsPage0Asc",
    "body": "{\n    page = 0;\n    IngredientDto expectedFirstIngredient = getExpectedIngredientDto(false, null);\n    validateResponse(\"\", expectedFirstIngredient, true, false, size);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getAllIngredientsPage0Desc",
    "body": "{\n    page = 0;\n    IngredientDto expectedFirstIngredient = getExpectedIngredientDto(true, null);\n    validateResponse(\"D\", expectedFirstIngredient, true, false, size);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getAllIngredientsPage3Asc",
    "body": "{\n    page = 3;\n    IngredientDto expectedFirstIngredient = getExpectedIngredientDto(false, null);\n    validateResponse(\"\", expectedFirstIngredient, false, true, getNumberLastElements());\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getAllIngredientsPage3Desc",
    "body": "{\n    page = 3;\n    IngredientDto expectedFirstIngredient = getExpectedIngredientDto(true, null);\n    validateResponse(\"D\", expectedFirstIngredient, false, true, getNumberLastElements());\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getExpectedIngredientDto",
    "body": "{\n    List<IngredientDto> listToSort = (otherIngredientDtoList == null) ? ingredientDtoList : otherIngredientDtoList;\n    return getExpectedDto(desc, listToSort);\n}",
    "parameters": "[boolean desc, List<IngredientDto> otherIngredientDtoList]",
    "returnType": "IngredientDto"
  },
  {
    "javadoc": "",
    "name": "generateIngredientDto",
    "body": "{\n    MeasureDto cucharadita = new MeasureDto(\"measure-1\", \"Cucharadita\");\n    return new IngredientDto(\"ingredient-1\", \"Azúcar\", 1.0, cucharadita);\n}",
    "parameters": "[]",
    "returnType": "IngredientDto"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    MockitoAnnotations.openMocks(this);\n    ingredientDto = generateIngredientDto();\n    pathVariable = ingredientsUri + PATH_ID;\n    valuePathVariable = ingredientDto.getId();\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getIngredientByIdFounded",
    "body": "{\n    when(ingredientDao.findById(anyString())).thenReturn(Mono.just(ingredientDto));\n    TestGetByPathVariableFounded(webTestClient, pathVariable, valuePathVariable, ingredientDto);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getIngredientByIdNotFound",
    "body": "{\n    when(ingredientDao.findById(anyString())).thenReturn(Mono.empty());\n    TestGetByPathVariableNotFound(webTestClient, pathVariable, valuePathVariable);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "generateIngredientDto",
    "body": "{\n    MeasureDto cucharadita = new MeasureDto(\"measure-1\", \"Cucharadita\");\n    return new IngredientDto(\"ingredient-1\", \"Azúcar\", 1.0, cucharadita);\n}",
    "parameters": "[]",
    "returnType": "IngredientDto"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    MockitoAnnotations.openMocks(this);\n    ingredientDto = generateIngredientDto();\n    ingredientDtoFlux = Flux.fromIterable(ingredientDtoList);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "createIngredientsNew",
    "body": "{\n    when(measureDao.findByNameIgnoreCase(anyString())).thenReturn(Mono.empty());\n    when(measureDao.save(any(MeasureDto.class))).thenReturn(Mono.just(ingredientDto.getMeasure()));\n    when(ingredientDao.findByNameIgnoreCase(anyString())).thenReturn(Mono.empty());\n    when(ingredientDao.save(any(IngredientDto.class))).thenAnswer(i -> Mono.just(i.getArgument(0)));\n    testCreateIngredients();\n    verify(ingredientDao, times(amount)).findByNameIgnoreCase(anyString());\n    verify(ingredientDao, times(amount)).save(any(IngredientDto.class));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "createIngredientsExistingIngredients",
    "body": "{\n    when(ingredientDao.findByNameIgnoreCase(anyString())).thenAnswer(invocation -> {\n        String name = invocation.getArgument(0);\n        return ingredientDtoList.stream().filter(ingredientDto -> ingredientDto.getName().equalsIgnoreCase(name)).findFirst().map(Mono::just).orElse(Mono.empty());\n    });\n    when(measureDao.findByNameIgnoreCase(anyString())).thenReturn(Mono.just(ingredientDto.getMeasure()));\n    testCreateIngredients();\n    verify(ingredientDao, times(amount)).findByNameIgnoreCase(anyString());\n    verify(ingredientDao, times(0)).save(any(IngredientDto.class));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testCreateIngredients",
    "body": "{\n    webTestClient.post().uri(ingredientsUri + PATH_Bulk).body(ingredientDtoFlux, IngredientDto.class).exchange().expectStatus().isOk().expectBodyList(IngredientDto.class).hasSize(amount).value(ingredients -> {\n        List<String> responseNames = ingredients.stream().map(IngredientDto::getName).toList();\n        assert responseNames.contains(ingredientDtoList.getFirst().getName());\n        assert responseNames.contains(ingredientDtoList.get(amount - 1).getName());\n    });\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "generateIngredientDtoList",
    "body": "{\n    MeasureDto cucharadita = new MeasureDto(\"measure-1\", \"Cucharadita\");\n    MeasureDto cucharada = new MeasureDto(\"measure-2\", \"Cucharada\");\n    MeasureDto taza = new MeasureDto(\"measure-3\", \"Taza\");\n    MeasureDto gramo = new MeasureDto(\"measure-11\", \"Gramo\");\n    MeasureDto kilogramo = new MeasureDto(\"measure-12\", \"Kilogramo\");\n    return Arrays.asList(new IngredientDto(\"ingredient-1\", \"Azúcar\", 100.0, gramo), new IngredientDto(\"ingredient-2\", \"Sal\", 200.0, gramo), new IngredientDto(\"ingredient-3\", \"Harina\", 1.0, kilogramo), new IngredientDto(\"ingredient-4\", \"Leche\", 2.0, taza), new IngredientDto(\"ingredient-5\", \"Aceite\", 3.0, cucharada), new IngredientDto(\"ingredient-6\", \"Huevos\", 4.0, cucharadita), new IngredientDto(\"ingredient-7\", \"Pollo\", 1.5, kilogramo), new IngredientDto(\"ingredient-8\", \"Tomates\", 2.5, kilogramo), new IngredientDto(\"ingredient-9\", \"Papas\", 1.2, kilogramo), new IngredientDto(\"ingredient-10\", \"Cebollas\", 1.0, kilogramo), new IngredientDto(\"ingredient-11\", \"Ajo\", 5.0, cucharadita), new IngredientDto(\"ingredient-12\", \"Zanahorias\", 0.5, kilogramo), new IngredientDto(\"ingredient-13\", \"Frijoles\", 1.0, taza), new IngredientDto(\"ingredient-14\", \"Arroz\", 2.0, taza), new IngredientDto(\"ingredient-15\", \"Lentejas\", 3.0, taza), new IngredientDto(\"ingredient-16\", \"Pan\", 6.0, cucharada), new IngredientDto(\"ingredient-17\", \"Mantequilla\", 7.0, cucharada), new IngredientDto(\"ingredient-18\", \"Queso\", 8.0, cucharada), new IngredientDto(\"ingredient-19\", \"Jamón\", 9.0, cucharada), new IngredientDto(\"ingredient-20\", \"Tocino\", 10.0, cucharada), new IngredientDto(\"ingredient-21\", \"Yogur\", 11.0, cucharada), new IngredientDto(\"ingredient-22\", \"Crema\", 12.0, cucharada), new IngredientDto(\"ingredient-23\", \"Café\", 13.0, cucharada), new IngredientDto(\"ingredient-24\", \"Té\", 14.0, cucharada), new IngredientDto(\"ingredient-25\", \"Agua\", 15.0, taza), new IngredientDto(\"ingredient-26\", \"Vino\", 16.0, taza), new IngredientDto(\"ingredient-27\", \"Cerveza\", 17.0, taza), new IngredientDto(\"ingredient-28\", \"Jugo\", 18.0, taza), new IngredientDto(\"ingredient-29\", \"Refresco\", 19.0, taza), new IngredientDto(\"ingredient-30\", \"Miel\", 20.0, cucharada), new IngredientDto(\"ingredient-31\", \"Canela\", 21.0, cucharadita), new IngredientDto(\"ingredient-32\", \"Pimienta\", 22.0, cucharadita), new IngredientDto(\"ingredient-33\", \"Perejil\", 23.0, cucharadita), new IngredientDto(\"ingredient-34\", \"Orégano\", 24.0, cucharadita), new IngredientDto(\"ingredient-35\", \"Tomillo\", 25.0, cucharadita), new IngredientDto(\"ingredient-36\", \"Albahaca\", 26.0, cucharadita));\n}",
    "parameters": "[]",
    "returnType": "List<IngredientDto>"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    MockitoAnnotations.openMocks(this);\n    measureDto = generateMeasureDto();\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "createMeasure",
    "body": "{\n    when(measureDao.findByNameIgnoreCase(anyString())).thenReturn(Mono.empty());\n    when(measureDao.save(any(MeasureDto.class))).thenAnswer(i -> Mono.just(i.getArgument(0)));\n    verifyCreationMeasure();\n    verify(measureDao, times(1)).save(any(MeasureDto.class));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "createMeasureAlreadyExists",
    "body": "{\n    when(measureDao.findByNameIgnoreCase(anyString())).thenReturn(Mono.just(measureDto));\n    verifyCreationMeasure();\n    verify(measureDao, times(0)).save(any(MeasureDto.class));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "verifyCreationMeasure",
    "body": "{\n    webTestClient.post().uri(measuresUri).contentType(APPLICATION_JSON).body(fromValue(measureDto)).exchange().expectStatus().isOk().expectBody().jsonPath(\"$.id\").isEqualTo(measureDto.getId()).jsonPath(\"$.name\").isEqualTo(measureDto.getName());\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "generateMeasureDto",
    "body": "{\n    MeasureDto measureDto = new MeasureDto();\n    measureDto.setId(measureDtoList.getFirst().getId().replace(\"1\", \"X\"));\n    measureDto.setName(measureDtoList.getFirst().getName());\n    return measureDto;\n}",
    "parameters": "[]",
    "returnType": "MeasureDto"
  },
  {
    "javadoc": "",
    "name": "TestGetMeasureByPathVariableFound",
    "body": "{\n    webTestClient.get().uri(uriBuilder -> uriBuilder.path(measuresUri + pathVariable).build(valuePathVariable)).accept(APPLICATION_JSON).exchange().expectStatus().isOk().expectBody().jsonPath(\"$.id\").isEqualTo(measureDto.getId()).jsonPath(\"$.name\").isEqualTo(measureDto.getName());\n}",
    "parameters": "[String pathVariable, String valuePathVariable]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "TestGetMeasureByPathVariableNotFound",
    "body": "{\n    webTestClient.get().uri(uriBuilder -> uriBuilder.path(measuresUri + pathVariable).build(valuePathVariable)).accept(APPLICATION_JSON).exchange().expectStatus().isNotFound();\n}",
    "parameters": "[String pathVariable, String valuePathVariable]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    MockitoAnnotations.openMocks(this);\n    measureDto = generateMeasureDto();\n    pathVariable = \"/id/{id}\";\n    valuePathVariable = measureDto.getId();\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getMeasureByIdFound",
    "body": "{\n    when(measureDao.findById(anyString())).thenReturn(Mono.just(measureDto));\n    TestGetMeasureByPathVariableFound(pathVariable, valuePathVariable);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getMeasureByIdNotFound",
    "body": "{\n    when(measureDao.findById(anyString())).thenReturn(Mono.empty());\n    TestGetMeasureByPathVariableNotFound(pathVariable, valuePathVariable);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    MockitoAnnotations.openMocks(this);\n    amount = measureDtoList.size();\n    measureDtoFlux = Flux.fromIterable(measureDtoList);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "createCategoriesNew",
    "body": "{\n    when(measureDao.findByNameIgnoreCase(anyString())).thenReturn(Mono.empty());\n    when(measureDao.save(any(MeasureDto.class))).thenAnswer(i -> Mono.just(i.getArgument(0)));\n    testCreateCategories();\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "createCategoriesExistingCategories",
    "body": "{\n    when(measureDao.findByNameIgnoreCase(anyString())).thenAnswer(invocation -> {\n        String name = invocation.getArgument(0);\n        return measureDtoList.stream().filter(measureDto -> measureDto.getName().equalsIgnoreCase(name)).findFirst().map(Mono::just).orElse(Mono.empty());\n    });\n    testCreateCategories();\n    verify(measureDao, times(0)).save(any(MeasureDto.class));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testCreateCategories",
    "body": "{\n    webTestClient.post().uri(measuresUri + PATH_Bulk).body(measureDtoFlux, MeasureDto.class).exchange().expectStatus().isOk().expectBodyList(MeasureDto.class).hasSize(amount).value(measures -> {\n        List<String> responseNames = measures.stream().map(MeasureDto::getName).toList();\n        assert responseNames.contains(measureDtoList.getFirst().getName());\n        assert responseNames.contains(measureDtoList.get(amount - 1).getName());\n    });\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    MockitoAnnotations.openMocks(this);\n    measureDto = generateMeasureDto();\n    pathVariable = measuresUri + \"/{id}\";\n    valuePathVariable = measureDto.getId();\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testDeleteMeasureByIdFounded",
    "body": "{\n    when(measureDao.findById(anyString())).thenReturn(Mono.just(measureDto));\n    when(measureDao.delete(measureDto)).thenReturn(Mono.empty());\n    webTestClient.delete().uri(uriBuilder -> uriBuilder.path(pathVariable).build(valuePathVariable)).accept(APPLICATION_JSON).exchange().expectStatus().isOk().expectBody(String.class).value(response -> {\n        assert response.contains(measureDto.getName());\n        assert response.contains(DELETED);\n    });\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testDeleteMeasureByIdNotFound",
    "body": "{\n    when(measureDao.findById(anyString())).thenReturn(Mono.empty());\n    webTestClient.delete().uri(uriBuilder -> uriBuilder.path(pathVariable).build(valuePathVariable)).accept(APPLICATION_JSON).exchange().expectStatus().isNotFound();\n    verify(measureDao, times(0)).delete(any(MeasureDto.class));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    MockitoAnnotations.openMocks(this);\n    measureDto = generateMeasureDto();\n    pathVariable = \"/name/{name}\";\n    valuePathVariable = measureDto.getName();\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getMeasureByNameFound",
    "body": "{\n    when(measureDao.findByNameIgnoreCase(anyString())).thenReturn(Mono.just(measureDto));\n    TestGetMeasureByPathVariableFound(pathVariable, valuePathVariable);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getMeasureByNameNotFound",
    "body": "{\n    when(measureDao.findByNameIgnoreCase(anyString())).thenReturn(Mono.empty());\n    TestGetMeasureByPathVariableNotFound(pathVariable, valuePathVariable);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    MockitoAnnotations.openMocks(this);\n    categoryDto = generateCategoryDto();\n    pathVariable = categoriesUri + PATH_ID;\n    valuePathVariable = categoryDto.getId();\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getCategoryByIdFound",
    "body": "{\n    when(categoryDao.findById(anyString())).thenReturn(Mono.just(categoryDto));\n    TestGetByPathVariableFounded(webTestClient, pathVariable, valuePathVariable, categoryDto);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getCategoryByIdNotFound",
    "body": "{\n    when(categoryDao.findById(anyString())).thenReturn(Mono.empty());\n    TestGetByPathVariableNotFound(webTestClient, pathVariable, valuePathVariable);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    MockitoAnnotations.openMocks(this);\n    categoryDto = generateCategoryDto();\n    pathVariable = categoriesUri + PATH_VARIABLE_ID;\n    valuePathVariable = categoryDto.getId();\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testDeleteCategoryByIdFounded",
    "body": "{\n    when(categoryDao.findById(anyString())).thenReturn(Mono.just(categoryDto));\n    when(categoryDao.delete(categoryDto)).thenReturn(Mono.empty());\n    webTestClient.delete().uri(uriBuilder -> uriBuilder.path(pathVariable).build(valuePathVariable)).accept(APPLICATION_JSON).exchange().expectStatus().isOk().expectBody(String.class).value(response -> {\n        assert response.contains(categoryDto.getName());\n        assert response.contains(DELETED);\n    });\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testDeleteCategoryByIdNotFound",
    "body": "{\n    when(categoryDao.findById(anyString())).thenReturn(Mono.empty());\n    webTestClient.delete().uri(uriBuilder -> uriBuilder.path(pathVariable).build(valuePathVariable)).accept(APPLICATION_JSON).exchange().expectStatus().isNotFound();\n    verify(categoryDao, times(0)).delete(any(CategoryDto.class));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "generateCategoryDtoList",
    "body": "{\n    List<CategoryDto> categoryDtoList = new ArrayList<>();\n    for (int i = 1; i <= amount; i++) {\n        CategoryDto categoryDto = new CategoryDto();\n        String prefix = getPrefix(i);\n        categoryDto.setId(\"id-\" + prefix + (i % 10 == 0 ? 10 : i % 10));\n        categoryDto.setName(\"Category-\" + prefix + (i % 10 == 0 ? 10 : i % 10));\n        categoryDtoList.add(categoryDto);\n    }\n    return categoryDtoList;\n}",
    "parameters": "[]",
    "returnType": "List<CategoryDto>"
  },
  {
    "javadoc": "",
    "name": "getPrefix",
    "body": "{\n    if (i <= 10) {\n        return \"A\";\n    } else if (i <= 20) {\n        return \"B\";\n    } else if (i <= 30) {\n        return \"C\";\n    } else {\n        return \"D\";\n    }\n}",
    "parameters": "[int i]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "getExpectedCategoryDto",
    "body": "{\n    List<CategoryDto> listToSort = (otherCategoryDtoList == null) ? categoryDtoList : otherCategoryDtoList;\n    return getExpectedDto(desc, listToSort);\n}",
    "parameters": "[boolean desc, List<CategoryDto> otherCategoryDtoList]",
    "returnType": "CategoryDto"
  },
  {
    "javadoc": "",
    "name": "generateCategoryDto",
    "body": "{\n    CategoryDto categoryDto = new CategoryDto();\n    categoryDto.setId(\"id-A1\");\n    categoryDto.setName(\"Category-A1\");\n    return categoryDto;\n}",
    "parameters": "[]",
    "returnType": "CategoryDto"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    MockitoAnnotations.openMocks(this);\n    categoryDto = generateCategoryDto();\n    pathVariable = categoriesUri + PATH_NAME;\n    valuePathVariable = categoryDto.getName();\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getCategoryByNameFound",
    "body": "{\n    when(categoryDao.findByNameIgnoreCase(anyString())).thenReturn(Mono.just(categoryDto));\n    TestGetByPathVariableFounded(webTestClient, pathVariable, valuePathVariable, categoryDto);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getCategoryByNameNotFound",
    "body": "{\n    when(categoryDao.findByNameIgnoreCase(anyString())).thenReturn(Mono.empty());\n    TestGetByPathVariableNotFound(webTestClient, pathVariable, valuePathVariable);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    MockitoAnnotations.openMocks(this);\n    categoryDtoFlux = Flux.fromIterable(categoryDtoList);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "createCategoriesNew",
    "body": "{\n    when(categoryDao.findByNameIgnoreCase(anyString())).thenReturn(Mono.empty());\n    when(categoryDao.save(any(CategoryDto.class))).thenAnswer(i -> Mono.just(i.getArgument(0)));\n    testCreateCategories();\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "createCategoriesExistingCategories",
    "body": "{\n    when(categoryDao.findByNameIgnoreCase(anyString())).thenAnswer(invocation -> {\n        String name = invocation.getArgument(0);\n        return categoryDtoList.stream().filter(categoryDto -> categoryDto.getName().equalsIgnoreCase(name)).findFirst().map(Mono::just).orElse(Mono.empty());\n    });\n    testCreateCategories();\n    verify(categoryDao, times(0)).save(any(CategoryDto.class));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testCreateCategories",
    "body": "{\n    webTestClient.post().uri(categoriesUri + PATH_Bulk).body(categoryDtoFlux, CategoryDto.class).exchange().expectStatus().isOk().expectBodyList(CategoryDto.class).hasSize(amount).value(categories -> {\n        List<String> responseNames = categories.stream().map(CategoryDto::getName).toList();\n        assert responseNames.contains(categoryDtoList.getFirst().getName());\n        assert responseNames.contains(categoryDtoList.get(amount - 1).getName());\n    });\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    MockitoAnnotations.openMocks(this);\n    queryParamValue = \"D\";\n    size = 10;\n    categoryDtoListFiltered = categoryDtoList.stream().filter(category -> category.getName().contains(queryParamValue)).collect(Collectors.toList());\n    when(categoryDao.findByNameContainingIgnoreCase(queryParamValue)).thenReturn(Flux.fromIterable(categoryDtoListFiltered));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "validateResponse",
    "body": "{\n    webTestClient.get().uri(uriBuilder -> uriBuilder.path(categoriesUri + PATH_ByName).queryParam(\"page\", page).queryParam(\"size\", size).queryParam(\"mode\", mode).queryParam(\"name\", name).build()).exchange().expectStatus().isOk().expectBody().jsonPath(\"$.content\").isArray().jsonPath(\"$.content.length()\").isEqualTo(numberOfElements).jsonPath(\"$.content[0].id\").isEqualTo(expectedFirstCategory.getId()).jsonPath(\"$.content[0].name\").isEqualTo(expectedFirstCategory.getName()).jsonPath(\"$.pageable.pageNumber\").isEqualTo(page).jsonPath(\"$.pageable.pageSize\").isEqualTo(size).jsonPath(\"$.totalElements\").isEqualTo(categoryDtoListFiltered.size()).jsonPath(\"$.totalPages\").isEqualTo((int) Math.ceil((double) categoryDtoListFiltered.size() / size)).jsonPath(\"$.first\").isEqualTo(true).jsonPath(\"$.last\").isEqualTo(true);\n}",
    "parameters": "[String mode, String name, CategoryDto expectedFirstCategory, int numberOfElements]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getCategoriesByNameContainingAsc",
    "body": "{\n    page = 0;\n    CategoryDto expectedFirstCategory = getExpectedCategoryDto(false, categoryDtoListFiltered);\n    validateResponse(\"\", queryParamValue, expectedFirstCategory, categoryDtoListFiltered.size());\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getCategoriesByNameContainingDesc",
    "body": "{\n    page = 0;\n    CategoryDto expectedFirstCategory = getExpectedCategoryDto(true, categoryDtoListFiltered);\n    validateResponse(\"D\", queryParamValue, expectedFirstCategory, categoryDtoListFiltered.size());\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    MockitoAnnotations.openMocks(this);\n    categoryDto = generateCategoryDto();\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "createCategory",
    "body": "{\n    when(categoryDao.findByNameIgnoreCase(anyString())).thenReturn(Mono.empty());\n    when(categoryDao.save(any(CategoryDto.class))).thenAnswer(i -> Mono.just(i.getArgument(0)));\n    verifyCreationCategory();\n    verify(categoryDao, times(1)).save(any(CategoryDto.class));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "createCategoryAlreadyExists",
    "body": "{\n    when(categoryDao.findByNameIgnoreCase(anyString())).thenReturn(Mono.just(categoryDto));\n    verifyCreationCategory();\n    verify(categoryDao, times(0)).save(any(CategoryDto.class));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "verifyCreationCategory",
    "body": "{\n    webTestClient.post().uri(categoriesUri).contentType(APPLICATION_JSON).body(fromValue(categoryDto)).exchange().expectStatus().isOk().expectBody().jsonPath(\"$.id\").isEqualTo(categoryDto.getId()).jsonPath(\"$.name\").isEqualTo(categoryDto.getName());\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    MockitoAnnotations.openMocks(this);\n    size = 10;\n    when(categoryDao.findAll()).thenReturn(Flux.fromIterable(categoryDtoList));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "validateResponse",
    "body": "{\n    webTestClient.get().uri(uriBuilder -> uriBuilder.path(categoriesUri).queryParam(\"page\", page).queryParam(\"size\", size).queryParam(\"mode\", mode).build()).exchange().expectStatus().isOk().expectBody().jsonPath(\"$.content\").isArray().jsonPath(\"$.content.length()\").isEqualTo(numberOfElements).jsonPath(\"$.content[0].id\").isEqualTo(expectedFirstCategory.getId()).jsonPath(\"$.content[0].name\").isEqualTo(expectedFirstCategory.getName()).jsonPath(\"$.pageable.pageNumber\").isEqualTo(page).jsonPath(\"$.pageable.pageSize\").isEqualTo(size).jsonPath(\"$.totalElements\").isEqualTo(amount).jsonPath(\"$.totalPages\").isEqualTo((int) Math.ceil((double) amount / size)).jsonPath(\"$.first\").isEqualTo(isFirst).jsonPath(\"$.last\").isEqualTo(isLast);\n}",
    "parameters": "[String mode, CategoryDto expectedFirstCategory, boolean isFirst, boolean isLast, int numberOfElements]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getAllCategoriesPage0Asc",
    "body": "{\n    page = 0;\n    CategoryDto expectedFirstCategory = getExpectedCategoryDto(false, null);\n    validateResponse(\"\", expectedFirstCategory, true, false, size);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getAllCategoriesPage0Desc",
    "body": "{\n    page = 0;\n    CategoryDto expectedFirstCategory = getExpectedCategoryDto(true, null);\n    validateResponse(\"D\", expectedFirstCategory, true, false, size);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getAllCategoriesPage3Asc",
    "body": "{\n    page = 3;\n    CategoryDto expectedFirstCategory = getExpectedCategoryDto(false, null);\n    validateResponse(\"\", expectedFirstCategory, false, true, getNumberLastElements());\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getAllCategoriesPage3Desc",
    "body": "{\n    page = 3;\n    CategoryDto expectedFirstCategory = getExpectedCategoryDto(true, null);\n    validateResponse(\"D\", expectedFirstCategory, false, true, getNumberLastElements());\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='The main method that runs the Spring Boot application.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='Command line arguments.'}]}', name=Optional[args]}]}",
    "name": "main",
    "body": "{\n    SpringApplication.run(WhataCookRecipesApplication.class, args);\n}",
    "parameters": "[String[] args]",
    "returnType": "void"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='PostConstruct method that initiates the analysis process.\nIt creates the output directory and file, then extracts method data from the Java source files.'}]}, blockTags=[]}",
    "name": "analyze",
    "body": "{\n    File projectDir = new File(OUTPUT_DIR);\n    if (!projectDir.exists() || !projectDir.isDirectory()) {\n        log.error(\"El directorio especificado no existe: {}\", OUTPUT_DIR);\n        return;\n    }\n    List<MethodInfo> extractedData = new ArrayList<>();\n    try {\n        // Crear el directorio de salida si no existe\n        Files.createDirectories(Paths.get(OUTPUT_DIR));\n        // Borrar el contenido existente del archivo\n        final Path pathTo_OUTPUT_FILE = Paths.get(OUTPUT_FILE);\n        Files.deleteIfExists(pathTo_OUTPUT_FILE);\n        extractData(projectDir, extractedData);\n        // Guardar los datos extraídos en un archivo JSON\n        List<Map<String, String>> jsonList = extractedData.stream().map(methodInfo -> {\n            Map<String, String> jsonObject = new HashMap<>();\n            jsonObject.put(\"name\", escapeJson(methodInfo.getName()));\n            jsonObject.put(\"returnType\", escapeJson(methodInfo.getReturnType()));\n            jsonObject.put(\"parameters\", escapeJson(methodInfo.getParameters()));\n            jsonObject.put(\"javadoc\", escapeJson(methodInfo.getJavadoc()));\n            jsonObject.put(\"body\", escapeJson(methodInfo.getBody()));\n            return jsonObject;\n        }).collect(Collectors.toList());\n        String jsonString = toJsonString(jsonList);\n        Files.write(pathTo_OUTPUT_FILE, jsonString.getBytes());\n    } catch (IOException e) {\n        log.error(\"Error while analyzing Java parser: {}\", e.getMessage(), e);\n    }\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Escapes special characters in a JSON string.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the input string'}]}', name=Optional[input]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the escaped string'}]}', name=Optional.empty}]}",
    "name": "escapeJson",
    "body": "{\n    if (input == null) {\n        return \"\";\n    }\n    return input.replace(\"\\\\\", \"\\\\\\\\\").replace(\"\\\"\", \"\\\\\\\"\").replace(\"\\n\", \"\\\\n\").replace(\"\\r\", \"\\\\r\").replace(\"\\t\", \"\\\\t\");\n}",
    "parameters": "[String input]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Converts a list of maps to a JSON string.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the list of maps'}]}', name=Optional[jsonList]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the JSON string'}]}', name=Optional.empty}]}",
    "name": "toJsonString",
    "body": "{\n    StringBuilder jsonString = new StringBuilder(\"[\\n\");\n    for (Map<String, String> jsonObject : jsonList) {\n        jsonString.append(\"  {\\n\");\n        for (Map.Entry<String, String> entry : jsonObject.entrySet()) {\n            jsonString.append(\"    \\\"\").append(entry.getKey()).append(\"\\\": \\\"\").append(entry.getValue()).append(\"\\\",\\n\");\n        }\n        // Remove last comma and newline, then add closing brace\n        jsonString.setLength(jsonString.length() - 2);\n        jsonString.append(\"\\n  },\\n\");\n    }\n    // Remove last comma and newline, then add closing bracket\n    if (!jsonList.isEmpty()) {\n        jsonString.setLength(jsonString.length() - 2);\n    }\n    jsonString.append(\"\\n]\");\n    return jsonString.toString();\n}",
    "parameters": "[List<Map<String, String>> jsonList]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Extracts method information from Java source files in the specified directory.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the project directory'}]}', name=Optional[projectDir]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the list to store extracted method information'}]}', name=Optional[extractedData]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if an I/O error occurs'}]}', name=Optional[IOException]}]}",
    "name": "extractData",
    "body": "{\n    JavaParser javaParser = new JavaParser();\n    try (Stream<java.nio.file.Path> paths = Files.walk(projectDir.toPath())) {\n        paths.filter(Files::isRegularFile).filter(path -> path.toString().endsWith(\".java\")).forEach(path -> {\n            try {\n                CompilationUnit cu = javaParser.parse(path).getResult().orElseThrow(IOException::new);\n                cu.accept(new MethodVisitor(), extractedData);\n            } catch (IOException e) {\n                log.error(\"Error while extractData() in JavaParserAnalyzer: {}\", e.getMessage(), e);\n            }\n        });\n    }\n}",
    "parameters": "[File projectDir, List<MethodInfo> extractedData]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "visit",
    "body": "{\n    super.visit(md, collector);\n    MethodInfo methodInfo = new MethodInfo();\n    methodInfo.setName(md.getNameAsString());\n    methodInfo.setReturnType(md.getTypeAsString());\n    methodInfo.setParameters(md.getParameters().toString());\n    methodInfo.setJavadoc(md.getJavadoc().map(Object::toString).orElse(\"\"));\n    methodInfo.setBody(md.getBody().map(Object::toString).orElse(\"\"));\n    collector.add(methodInfo);\n}",
    "parameters": "[MethodDeclaration md, List<MethodInfo> collector]",
    "returnType": "void"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Condition function to check if the environment is local.'}]}, blockTags=[]}",
    "name": "matches",
    "body": "{\n    String environment = System.getenv(\"WHATA_COOK_ENV\");\n    return \"local\".equals(environment);\n}",
    "parameters": "[ConditionContext context, AnnotatedTypeMetadata metadata]",
    "returnType": "boolean"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a '}, JavadocInlineTag{tagName='link', type=LINK, content=' MongoClient'}, JavadocSnippet{text=' bean to connect to MongoDB.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the '}, JavadocInlineTag{tagName='link', type=LINK, content=' MongoClient'}, JavadocSnippet{text=' instance.'}]}', name=Optional.empty}]}",
    "name": "mongoClient",
    "body": "{\n    return MongoClients.create(mongoUri);\n}",
    "parameters": "[]",
    "returnType": "MongoClient"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a '}, JavadocInlineTag{tagName='link', type=LINK, content=' ReactiveMongoDatabaseFactory'}, JavadocSnippet{text=' bean for reactive database operations.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the '}, JavadocInlineTag{tagName='link', type=LINK, content=' MongoClient'}, JavadocSnippet{text=' instance.'}]}', name=Optional[mongoClient]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the '}, JavadocInlineTag{tagName='link', type=LINK, content=' ReactiveMongoDatabaseFactory'}, JavadocSnippet{text=' instance.'}]}', name=Optional.empty}]}",
    "name": "reactiveMongoDatabaseFactory",
    "body": "{\n    return new SimpleReactiveMongoDatabaseFactory(mongoClient, DB_NAME);\n}",
    "parameters": "[MongoClient mongoClient]",
    "returnType": "ReactiveMongoDatabaseFactory"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a '}, JavadocInlineTag{tagName='link', type=LINK, content=' ReactiveMongoTemplate'}, JavadocSnippet{text=' bean for reactive database operations.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the '}, JavadocInlineTag{tagName='link', type=LINK, content=' ReactiveMongoDatabaseFactory'}, JavadocSnippet{text=' instance.'}]}', name=Optional[reactiveMongoDatabaseFactory]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the '}, JavadocInlineTag{tagName='link', type=LINK, content=' MappingMongoConverter'}, JavadocSnippet{text=' instance.'}]}', name=Optional[mappingMongoConverter]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the '}, JavadocInlineTag{tagName='link', type=LINK, content=' ReactiveMongoTemplate'}, JavadocSnippet{text=' instance.'}]}', name=Optional.empty}]}",
    "name": "reactiveMongoTemplate",
    "body": "{\n    return new ReactiveMongoTemplate(reactiveMongoDatabaseFactory, mappingMongoConverter);\n}",
    "parameters": "[ReactiveMongoDatabaseFactory reactiveMongoDatabaseFactory, MappingMongoConverter mappingMongoConverter]",
    "returnType": "ReactiveMongoTemplate"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a '}, JavadocInlineTag{tagName='link', type=LINK, content=' MappingMongoConverter'}, JavadocSnippet{text=' bean to handle MongoDB mappings.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the '}, JavadocInlineTag{tagName='link', type=LINK, content=' MongoMappingContext'}, JavadocSnippet{text=' instance.'}]}', name=Optional[mongoMappingContext]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the '}, JavadocInlineTag{tagName='link', type=LINK, content=' MappingMongoConverter'}, JavadocSnippet{text=' instance.'}]}', name=Optional.empty}]}",
    "name": "mappingMongoConverter",
    "body": "{\n    MappingMongoConverter converter = new MappingMongoConverter(NoOpDbRefResolver.INSTANCE, mongoMappingContext);\n    converter.setTypeMapper(new DefaultMongoTypeMapper(null));\n    return converter;\n}",
    "parameters": "[MongoMappingContext mongoMappingContext]",
    "returnType": "MappingMongoConverter"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Configures the resource handlers for the application.\n<p>\nThis method overrides the '}, JavadocInlineTag{tagName='code', type=CODE, content=' addResourceHandlers'}, JavadocSnippet{text=' method from the\n'}, JavadocInlineTag{tagName='code', type=CODE, content=' WebFluxConfigurer'}, JavadocSnippet{text=' interface to add a specific resource handler.\nThe resource handler configures the path to serve static files\nfrom the file system directory '}, JavadocInlineTag{tagName='code', type=CODE, content=' /app/javadoc'}, JavadocSnippet{text=' via the path\n'}, JavadocInlineTag{tagName='code', type=CODE, content=' /api/javadoc/**'}, JavadocSnippet{text='.\n</p>'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the resource handler registry to be used to add the handlers.'}]}', name=Optional[registry]}]}",
    "name": "addResourceHandlers",
    "body": "{\n    registry.addResourceHandler(\"/api/javadoc/**\").addResourceLocations(\"file:/app/javadoc/\");\n}",
    "parameters": "[ResourceHandlerRegistry registry]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getJavadoc",
    "body": "{\n    try {\n        Resource resource = new FileSystemResource(\"/app/javadoc/index.html\");\n        if (!resource.exists()) {\n            log.error(\"Javadoc file not found at /app/javadoc/index.html\");\n            return new ResponseEntity<>(HttpStatus.NOT_FOUND);\n        }\n        byte[] content = Files.readAllBytes(resource.getFile().toPath());\n        HttpHeaders headers = new HttpHeaders();\n        headers.add(\"Content-Type\", \"text/html\");\n        return new ResponseEntity<>(content, headers, HttpStatus.OK);\n    } catch (IOException e) {\n        log.error(\"Error reading Javadoc file: \", e);\n        return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n}",
    "parameters": "[]",
    "returnType": "ResponseEntity<byte[]>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves a measure by its ID.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ID of the measure to retrieve.'}]}', name=Optional[id]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting the '}, JavadocInlineTag{tagName='link', type=LINK, content=' MeasureDto'}, JavadocSnippet{text=' object, or an error if not found.'}]}', name=Optional.empty}]}",
    "name": "getMeasureById",
    "body": "{\n    return measureService.getMeasureById(id);\n}",
    "parameters": "[@PathVariable String id]",
    "returnType": "Mono<MeasureDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves a measure by its name, case insensitive.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The name of the measure to retrieve.'}]}', name=Optional[name]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting the '}, JavadocInlineTag{tagName='link', type=LINK, content=' MeasureDto'}, JavadocSnippet{text=' object, or an error if not found.'}]}', name=Optional.empty}]}",
    "name": "getMeasureByName",
    "body": "{\n    return measureService.getMeasureByNameIgnoreCase(name);\n}",
    "parameters": "[@PathVariable String name]",
    "returnType": "Mono<MeasureDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new measure.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The measure data to create.'}]}', name=Optional[categoryDto]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting the created '}, JavadocInlineTag{tagName='link', type=LINK, content=' MeasureDto'}, JavadocSnippet{text=' object.'}]}', name=Optional.empty}]}",
    "name": "createMeasure",
    "body": "{\n    return measureService.createMeasure(categoryDto);\n}",
    "parameters": "[@RequestBody MeasureDto categoryDto]",
    "returnType": "Mono<MeasureDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates multiple measures.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The flux of measures to create.'}]}', name=Optional[categories]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Flux'}, JavadocSnippet{text=' emitting the created '}, JavadocInlineTag{tagName='link', type=LINK, content=' MeasureDto'}, JavadocSnippet{text=' objects.'}]}', name=Optional.empty}]}",
    "name": "createMeasures",
    "body": "{\n    return measureService.createMeasures(categories);\n}",
    "parameters": "[@RequestBody Flux<MeasureDto> categories]",
    "returnType": "Flux<MeasureDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Deletes a measure by its ID.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ID of the measure to delete.'}]}', name=Optional[id]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting a message indicating the measure has been deleted, or an error if not found.'}]}', name=Optional.empty}]}",
    "name": "deleteMeasureById",
    "body": "{\n    return measureService.deleteMeasure(id);\n}",
    "parameters": "[@PathVariable String id]",
    "returnType": "Mono<String>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Deletes all measures.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' indicating completion of the deletion process.'}]}', name=Optional.empty}]}",
    "name": "deleteAllMeasures",
    "body": "{\n    return measureService.deleteAllMeasures();\n}",
    "parameters": "[]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves all categories with pagination.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The sorting mode.'}]}', name=Optional[mode]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The page number to retrieve.'}]}', name=Optional[page]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The number of items per page.'}]}', name=Optional[size]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting a '}, JavadocInlineTag{tagName='link', type=LINK, content=' Page'}, JavadocSnippet{text=' of '}, JavadocInlineTag{tagName='link', type=LINK, content=' CategoryDto'}, JavadocSnippet{text=' objects.'}]}', name=Optional.empty}]}",
    "name": "getAllCategories",
    "body": "{\n    return categoryService.getAllCategories(page, size, mode);\n}",
    "parameters": "[@RequestParam(required = false) String mode, @RequestParam int page, @RequestParam int size]",
    "returnType": "Mono<Page<CategoryDto>>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves categories by name containing a string with pagination.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The string to search for within category names.'}]}', name=Optional[name]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The sorting mode.'}]}', name=Optional[mode]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The page number to retrieve.'}]}', name=Optional[page]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The number of items per page.'}]}', name=Optional[size]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting a '}, JavadocInlineTag{tagName='link', type=LINK, content=' Page'}, JavadocSnippet{text=' of '}, JavadocInlineTag{tagName='link', type=LINK, content=' CategoryDto'}, JavadocSnippet{text=' objects.'}]}', name=Optional.empty}]}",
    "name": "getCategoriesByNameContaining",
    "body": "{\n    return categoryService.getCategoriesByNameContaining(name, page, size, mode);\n}",
    "parameters": "[@RequestParam String name, @RequestParam(required = false) String mode, @RequestParam int page, @RequestParam int size]",
    "returnType": "Mono<Page<CategoryDto>>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves a category by its ID.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ID of the category to retrieve.'}]}', name=Optional[id]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting the '}, JavadocInlineTag{tagName='link', type=LINK, content=' CategoryDto'}, JavadocSnippet{text=' object, or an error if not found.'}]}', name=Optional.empty}]}",
    "name": "getCategoryById",
    "body": "{\n    return categoryService.getCategoryById(id);\n}",
    "parameters": "[@PathVariable String id]",
    "returnType": "Mono<CategoryDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves a category by its name, case insensitive.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The name of the category to retrieve.'}]}', name=Optional[name]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting the '}, JavadocInlineTag{tagName='link', type=LINK, content=' CategoryDto'}, JavadocSnippet{text=' object, or an error if not found.'}]}', name=Optional.empty}]}",
    "name": "getCategoryByName",
    "body": "{\n    return categoryService.getCategoryByNameIgnoreCase(name);\n}",
    "parameters": "[@PathVariable String name]",
    "returnType": "Mono<CategoryDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new category.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The category data to create.'}]}', name=Optional[categoryDto]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting the created '}, JavadocInlineTag{tagName='link', type=LINK, content=' CategoryDto'}, JavadocSnippet{text=' object.'}]}', name=Optional.empty}]}",
    "name": "createCategory",
    "body": "{\n    return categoryService.createCategory(categoryDto);\n}",
    "parameters": "[@RequestBody CategoryDto categoryDto]",
    "returnType": "Mono<CategoryDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates multiple categories.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The flux of categories to create.'}]}', name=Optional[categories]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Flux'}, JavadocSnippet{text=' emitting the created '}, JavadocInlineTag{tagName='link', type=LINK, content=' CategoryDto'}, JavadocSnippet{text=' objects.'}]}', name=Optional.empty}]}",
    "name": "createCategories",
    "body": "{\n    return categoryService.createCategories(categories);\n}",
    "parameters": "[@RequestBody Flux<CategoryDto> categories]",
    "returnType": "Flux<CategoryDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Deletes a category by its ID.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ID of the category to delete.'}]}', name=Optional[id]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting a message indicating the category has been deleted, or an error if not found.'}]}', name=Optional.empty}]}",
    "name": "deleteCategoryById",
    "body": "{\n    return categoryService.deleteCategory(id);\n}",
    "parameters": "[@PathVariable String id]",
    "returnType": "Mono<String>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Deletes all categories.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' indicating completion of the deletion process.'}]}', name=Optional.empty}]}",
    "name": "deleteAllCategories",
    "body": "{\n    return categoryService.deleteAllCategories();\n}",
    "parameters": "[]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves all recipes with pagination.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The sorting mode.'}]}', name=Optional[mode]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The page number to retrieve.'}]}', name=Optional[page]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The number of items per page.'}]}', name=Optional[size]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting a '}, JavadocInlineTag{tagName='link', type=LINK, content=' Page'}, JavadocSnippet{text=' of '}, JavadocInlineTag{tagName='link', type=LINK, content=' RecipeDto'}, JavadocSnippet{text=' objects.'}]}', name=Optional.empty}]}",
    "name": "getAllRecipes",
    "body": "{\n    return recipeService.getAllRecipes(page, size, mode);\n}",
    "parameters": "[@RequestParam(required = false) String mode, @RequestParam int page, @RequestParam int size]",
    "returnType": "Mono<Page<RecipeDto>>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves recipes by name containing a string with pagination.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The string to search for within recipe names.'}]}', name=Optional[name]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The sorting mode.'}]}', name=Optional[mode]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The page number to retrieve.'}]}', name=Optional[page]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The number of items per page.'}]}', name=Optional[size]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting a '}, JavadocInlineTag{tagName='link', type=LINK, content=' Page'}, JavadocSnippet{text=' of '}, JavadocInlineTag{tagName='link', type=LINK, content=' RecipeDto'}, JavadocSnippet{text=' objects.'}]}', name=Optional.empty}]}",
    "name": "getRecipesByNameContaining",
    "body": "{\n    return recipeService.getRecipesByNameContaining(name, page, size, mode);\n}",
    "parameters": "[@RequestParam String name, @RequestParam(required = false) String mode, @RequestParam int page, @RequestParam int size]",
    "returnType": "Mono<Page<RecipeDto>>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves recipes containing any of the specified ingredients with pagination.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The list of ingredient names to search for within recipes.'}]}', name=Optional[ingredients]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The sorting mode.'}]}', name=Optional[mode]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The page number to retrieve.'}]}', name=Optional[page]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The number of items per page.'}]}', name=Optional[size]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting a '}, JavadocInlineTag{tagName='link', type=LINK, content=' Page'}, JavadocSnippet{text=' of '}, JavadocInlineTag{tagName='link', type=LINK, content=' RecipeDto'}, JavadocSnippet{text=' objects.'}]}', name=Optional.empty}]}",
    "name": "searchRecipesByIngredients",
    "body": "{\n    return recipeService.findRecipesByIngredients(ingredients, page, size, mode);\n}",
    "parameters": "[@RequestParam List<String> ingredients, @RequestParam(required = false) String mode, @RequestParam int page, @RequestParam int size]",
    "returnType": "Mono<Page<RecipeDto>>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves recipes containing all of the specified ingredients with pagination.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The list of ingredient names to search for within recipes.'}]}', name=Optional[ingredients]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The sorting mode.'}]}', name=Optional[mode]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The page number to retrieve.'}]}', name=Optional[page]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The number of items per page.'}]}', name=Optional[size]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting a '}, JavadocInlineTag{tagName='link', type=LINK, content=' Page'}, JavadocSnippet{text=' of '}, JavadocInlineTag{tagName='link', type=LINK, content=' RecipeDto'}, JavadocSnippet{text=' objects.'}]}', name=Optional.empty}]}",
    "name": "searchRecipesByAllIngredients",
    "body": "{\n    return recipeService.findRecipesByAllIngredients(ingredients, page, size, mode);\n}",
    "parameters": "[@RequestParam List<String> ingredients, @RequestParam(required = false) String mode, @RequestParam int page, @RequestParam int size]",
    "returnType": "Mono<Page<RecipeDto>>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves a recipe by its ID.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ID of the recipe to retrieve.'}]}', name=Optional[id]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting the '}, JavadocInlineTag{tagName='link', type=LINK, content=' RecipeDto'}, JavadocSnippet{text=' object, or an error if not found.'}]}', name=Optional.empty}]}",
    "name": "getRecipeById",
    "body": "{\n    return recipeService.getRecipeById(id);\n}",
    "parameters": "[@PathVariable String id]",
    "returnType": "Mono<RecipeDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves recipes by a list of IDs.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The list of IDs of the recipes to retrieve.'}]}', name=Optional[ids]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting a map containing found recipes and not found IDs.'}]}', name=Optional.empty}]}",
    "name": "getRecipesByIds",
    "body": "{\n    return recipeService.getRecipesByIds(ids);\n}",
    "parameters": "[@RequestBody List<String> ids]",
    "returnType": "Mono<Map<String,Object>>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves a recipe by its name, case insensitive.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The name of the recipe to retrieve.'}]}', name=Optional[name]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting the '}, JavadocInlineTag{tagName='link', type=LINK, content=' RecipeDto'}, JavadocSnippet{text=' object, or an error if not found.'}]}', name=Optional.empty}]}",
    "name": "getRecipeByName",
    "body": "{\n    return recipeService.getRecipeByName(name);\n}",
    "parameters": "[@PathVariable String name]",
    "returnType": "Mono<RecipeDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new recipe.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The recipe data to create.'}]}', name=Optional[recipeDto]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting the created '}, JavadocInlineTag{tagName='link', type=LINK, content=' RecipeDto'}, JavadocSnippet{text=' object.'}]}', name=Optional.empty}]}",
    "name": "createRecipe",
    "body": "{\n    return recipeService.createRecipe(recipeDto);\n}",
    "parameters": "[@RequestBody RecipeDto recipeDto]",
    "returnType": "Mono<RecipeDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates multiple recipes.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The flux of recipes to create.'}]}', name=Optional[recipes]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Flux'}, JavadocSnippet{text=' emitting the created '}, JavadocInlineTag{tagName='link', type=LINK, content=' RecipeDto'}, JavadocSnippet{text=' objects.'}]}', name=Optional.empty}]}",
    "name": "createRecipes",
    "body": "{\n    return recipeService.createRecipes(recipes);\n}",
    "parameters": "[@RequestBody Flux<RecipeDto> recipes]",
    "returnType": "Flux<RecipeDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Deletes a recipe by its ID.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ID of the recipe to delete.'}]}', name=Optional[id]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting a message indicating the recipe has been deleted, or an error if not found.'}]}', name=Optional.empty}]}",
    "name": "deleteRecipeById",
    "body": "{\n    return recipeService.deleteRecipe(id);\n}",
    "parameters": "[@PathVariable String id]",
    "returnType": "Mono<String>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Deletes all recipes.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' indicating completion of the deletion process.'}]}', name=Optional.empty}]}",
    "name": "deleteAllRecipes",
    "body": "{\n    return recipeService.deleteAllRecipes();\n}",
    "parameters": "[]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves all ingredients with pagination.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The sorting mode.'}]}', name=Optional[mode]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The page number to retrieve.'}]}', name=Optional[page]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The number of items per page.'}]}', name=Optional[size]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting a '}, JavadocInlineTag{tagName='link', type=LINK, content=' Page'}, JavadocSnippet{text=' of '}, JavadocInlineTag{tagName='link', type=LINK, content=' IngredientDto'}, JavadocSnippet{text=' objects.'}]}', name=Optional.empty}]}",
    "name": "getAllCategories",
    "body": "{\n    return ingredientService.getAllCategories(page, size, mode);\n}",
    "parameters": "[@RequestParam(required = false) String mode, @RequestParam int page, @RequestParam int size]",
    "returnType": "Mono<Page<IngredientDto>>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves ingredients by name containing a string with pagination.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The string to search for within ingredient names.'}]}', name=Optional[name]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The sorting mode.'}]}', name=Optional[mode]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The page number to retrieve.'}]}', name=Optional[page]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The number of items per page.'}]}', name=Optional[size]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting a '}, JavadocInlineTag{tagName='link', type=LINK, content=' Page'}, JavadocSnippet{text=' of '}, JavadocInlineTag{tagName='link', type=LINK, content=' IngredientDto'}, JavadocSnippet{text=' objects.'}]}', name=Optional.empty}]}",
    "name": "getCategoriesByNameContaining",
    "body": "{\n    return ingredientService.getCategoriesByNameContaining(name, page, size, mode);\n}",
    "parameters": "[@RequestParam String name, @RequestParam(required = false) String mode, @RequestParam int page, @RequestParam int size]",
    "returnType": "Mono<Page<IngredientDto>>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves an ingredient by its ID.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ID of the ingredient to retrieve.'}]}', name=Optional[id]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting the '}, JavadocInlineTag{tagName='link', type=LINK, content=' IngredientDto'}, JavadocSnippet{text=' object, or an error if not found.'}]}', name=Optional.empty}]}",
    "name": "getIngredientById",
    "body": "{\n    return ingredientService.getIngredientById(id);\n}",
    "parameters": "[@PathVariable String id]",
    "returnType": "Mono<IngredientDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves ingredients by a list of IDs.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The list of IDs of the ingredients to retrieve.'}]}', name=Optional[ids]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting a map containing found ingredients and not found IDs.'}]}', name=Optional.empty}]}",
    "name": "getIngredientsByIds",
    "body": "{\n    return ingredientService.getIngredientsByIds(ids);\n}",
    "parameters": "[@RequestBody List<String> ids]",
    "returnType": "Mono<Map<String,Object>>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves an ingredient by its name, case insensitive.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The name of the ingredient to retrieve.'}]}', name=Optional[name]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting the '}, JavadocInlineTag{tagName='link', type=LINK, content=' IngredientDto'}, JavadocSnippet{text=' object, or an error if not found.'}]}', name=Optional.empty}]}",
    "name": "getIngredientByName",
    "body": "{\n    return ingredientService.getIngredientByName(name);\n}",
    "parameters": "[@PathVariable String name]",
    "returnType": "Mono<IngredientDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new ingredient.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ingredient data to create.'}]}', name=Optional[ingredientDto]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting the created '}, JavadocInlineTag{tagName='link', type=LINK, content=' IngredientDto'}, JavadocSnippet{text=' object.'}]}', name=Optional.empty}]}",
    "name": "createIngredient",
    "body": "{\n    return ingredientService.createIngredient(ingredientDto);\n}",
    "parameters": "[@RequestBody IngredientDto ingredientDto]",
    "returnType": "Mono<IngredientDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates multiple ingredients.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The flux of ingredients to create.'}]}', name=Optional[ingredients]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Flux'}, JavadocSnippet{text=' emitting the created '}, JavadocInlineTag{tagName='link', type=LINK, content=' IngredientDto'}, JavadocSnippet{text=' objects.'}]}', name=Optional.empty}]}",
    "name": "createCategories",
    "body": "{\n    return ingredientService.createCategories(ingredients);\n}",
    "parameters": "[@RequestBody Flux<IngredientDto> ingredients]",
    "returnType": "Flux<IngredientDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Deletes an ingredient by its ID.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ID of the ingredient to delete.'}]}', name=Optional[id]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting a message indicating the ingredient has been deleted, or an error if not found.'}]}', name=Optional.empty}]}",
    "name": "deleteIngredientById",
    "body": "{\n    return ingredientService.deleteIngredient(id);\n}",
    "parameters": "[@PathVariable String id]",
    "returnType": "Mono<String>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Deletes all ingredients.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' indicating completion of the deletion process.'}]}', name=Optional.empty}]}",
    "name": "deleteAllCategories",
    "body": "{\n    return ingredientService.deleteAllCategories();\n}",
    "parameters": "[]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a '}, JavadocInlineTag{tagName='link', type=LINK, content=' Sort'}, JavadocSnippet{text=' object for sorting by name based on the mode.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The sorting mode.'}]}', name=Optional[mode]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Sort'}, JavadocSnippet{text=' object for sorting by name.'}]}', name=Optional.empty}]}",
    "name": "getSortByName",
    "body": "{\n    Sort.Direction direction = isNotNullAndStartWithD(mode) ? Sort.Direction.DESC : Sort.Direction.ASC;\n    return Sort.by(direction, \"name\");\n}",
    "parameters": "[String mode]",
    "returnType": "Sort"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Checks if the mode string is not null and starts with \"d\".'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The mode string to check.'}]}', name=Optional[mode]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if the mode is not null and starts with \"d\", false otherwise.'}]}', name=Optional.empty}]}",
    "name": "isNotNullAndStartWithD",
    "body": "{\n    return mode != null && mode.toLowerCase().startsWith(\"d\");\n}",
    "parameters": "[String mode]",
    "returnType": "boolean"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a paged result from a list of items.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The list of items to paginate.'}]}', name=Optional[items]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The page number to retrieve.'}]}', name=Optional[page]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The number of items per page.'}]}', name=Optional[size]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The sorting mode.'}]}', name=Optional[mode]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The type of items, extending '}, JavadocInlineTag{tagName='link', type=LINK, content=' NamedEntity'}, JavadocSnippet{text='.'}]}', name=Optional[<T>]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting a '}, JavadocInlineTag{tagName='link', type=LINK, content=' Page'}, JavadocSnippet{text=' of items.'}]}', name=Optional.empty}]}",
    "name": "createPagedResult",
    "body": "{\n    return Mono.just(items.stream().sorted(getComparator(mode)).skip((long) page * size).limit(size).collect(Collectors.collectingAndThen(Collectors.toList(), list -> new PageImpl<>(list, PageRequest.of(page, size, getSortByName(mode)), items.size()))));\n}",
    "parameters": "[List<T> items, int page, int size, String mode]",
    "returnType": "Mono<Page<T>>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a comparator for sorting items based on the mode.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The sorting mode.'}]}', name=Optional[mode]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The type of items, extending '}, JavadocInlineTag{tagName='link', type=LINK, content=' NamedEntity'}, JavadocSnippet{text='.'}]}', name=Optional[<T>]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A comparator for sorting items.'}]}', name=Optional.empty}]}",
    "name": "getComparator",
    "body": "{\n    Comparator<T> comparator = Comparator.comparing(NamedEntity::getName);\n    return isNotNullAndStartWithD(mode) ? comparator.reversed() : comparator;\n}",
    "parameters": "[String mode]",
    "returnType": "Comparator<T>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Finds a measure by name, case insensitive.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The name of the measure to search for.'}]}', name=Optional[name]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting the matching '}, JavadocInlineTag{tagName='link', type=LINK, content=' MeasureDto'}, JavadocSnippet{text=' entity, or empty if not found.'}]}', name=Optional.empty}]}",
    "name": "findByNameIgnoreCase",
    "body": "",
    "parameters": "[String name]",
    "returnType": "Mono<MeasureDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Finds recipes with names containing the specified string, case insensitive.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The string to search for within recipe names.'}]}', name=Optional[name]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Flux'}, JavadocSnippet{text=' emitting the matching '}, JavadocInlineTag{tagName='link', type=LINK, content=' RecipeDto'}, JavadocSnippet{text=' entities.'}]}', name=Optional.empty}]}",
    "name": "findByNameContainingIgnoreCase",
    "body": "",
    "parameters": "[String name]",
    "returnType": "Flux<RecipeDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Finds a recipe by name, case insensitive.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The name of the recipe to search for.'}]}', name=Optional[name]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting the matching '}, JavadocInlineTag{tagName='link', type=LINK, content=' RecipeDto'}, JavadocSnippet{text=' entity, or empty if not found.'}]}', name=Optional.empty}]}",
    "name": "findByNameIgnoreCase",
    "body": "",
    "parameters": "[String name]",
    "returnType": "Mono<RecipeDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Finds recipes containing any of the specified ingredient names.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='A list of ingredient names to search for within recipes.'}]}', name=Optional[ingredientNames]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Flux'}, JavadocSnippet{text=' emitting the matching '}, JavadocInlineTag{tagName='link', type=LINK, content=' RecipeDto'}, JavadocSnippet{text=' entities.'}]}', name=Optional.empty}]}",
    "name": "findByIngredientsNameIn",
    "body": "",
    "parameters": "[List<String> ingredientNames]",
    "returnType": "Flux<RecipeDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Finds recipes containing all of the specified ingredient names.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='A list of ingredient names to search for within recipes.'}]}', name=Optional[ingredientNames]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Flux'}, JavadocSnippet{text=' emitting the matching '}, JavadocInlineTag{tagName='link', type=LINK, content=' RecipeDto'}, JavadocSnippet{text=' entities.'}]}', name=Optional.empty}]}",
    "name": "findByAllIngredientsNameIn",
    "body": "",
    "parameters": "[List<String> ingredientNames]",
    "returnType": "Flux<RecipeDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Finds ingredients with names containing the specified string, case insensitive.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The string to search for within ingredient names.'}]}', name=Optional[name]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Flux'}, JavadocSnippet{text=' emitting the matching '}, JavadocInlineTag{tagName='link', type=LINK, content=' IngredientDto'}, JavadocSnippet{text=' entities.'}]}', name=Optional.empty}]}",
    "name": "findByNameContainingIgnoreCase",
    "body": "",
    "parameters": "[String name]",
    "returnType": "Flux<IngredientDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Finds an ingredient by name, case insensitive.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The name of the ingredient to search for.'}]}', name=Optional[name]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting the matching '}, JavadocInlineTag{tagName='link', type=LINK, content=' IngredientDto'}, JavadocSnippet{text=' entity, or empty if not found.'}]}', name=Optional.empty}]}",
    "name": "findByNameIgnoreCase",
    "body": "",
    "parameters": "[String name]",
    "returnType": "Mono<IngredientDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Finds categories with names containing the specified string, case insensitive.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The string to search for within category names.'}]}', name=Optional[name]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Flux'}, JavadocSnippet{text=' emitting the matching '}, JavadocInlineTag{tagName='link', type=LINK, content=' CategoryDto'}, JavadocSnippet{text=' entities.'}]}', name=Optional.empty}]}",
    "name": "findByNameContainingIgnoreCase",
    "body": "",
    "parameters": "[String name]",
    "returnType": "Flux<CategoryDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Finds a category by name, case insensitive.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The name of the category to search for.'}]}', name=Optional[name]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting the matching '}, JavadocInlineTag{tagName='link', type=LINK, content=' CategoryDto'}, JavadocSnippet{text=' entity, or empty if not found.'}]}', name=Optional.empty}]}",
    "name": "findByNameIgnoreCase",
    "body": "",
    "parameters": "[String name]",
    "returnType": "Mono<CategoryDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves all recipes with pagination.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The page number to retrieve.'}]}', name=Optional[page]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The number of items per page.'}]}', name=Optional[size]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The pagination mode.'}]}', name=Optional[mode]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting a '}, JavadocInlineTag{tagName='link', type=LINK, content=' Page'}, JavadocSnippet{text=' of '}, JavadocInlineTag{tagName='link', type=LINK, content=' RecipeDto'}, JavadocSnippet{text=' objects.'}]}', name=Optional.empty}]}",
    "name": "getAllRecipes",
    "body": "{\n    return recipeDao.findAll().collectList().flatMap(list -> PaginationUtil.createPagedResult(list, page, size, mode));\n}",
    "parameters": "[int page, int size, String mode]",
    "returnType": "Mono<Page<RecipeDto>>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves recipes by name containing a string with pagination.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The string to search for within recipe names.'}]}', name=Optional[name]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The page number to retrieve.'}]}', name=Optional[page]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The number of items per page.'}]}', name=Optional[size]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The pagination mode.'}]}', name=Optional[mode]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting a '}, JavadocInlineTag{tagName='link', type=LINK, content=' Page'}, JavadocSnippet{text=' of '}, JavadocInlineTag{tagName='link', type=LINK, content=' RecipeDto'}, JavadocSnippet{text=' objects.'}]}', name=Optional.empty}]}",
    "name": "getRecipesByNameContaining",
    "body": "{\n    return recipeDao.findByNameContainingIgnoreCase(name).collectList().flatMap(list -> PaginationUtil.createPagedResult(list, page, size, mode));\n}",
    "parameters": "[String name, int page, int size, String mode]",
    "returnType": "Mono<Page<RecipeDto>>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves recipes containing any of the specified ingredients with pagination.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The list of ingredient names to search for within recipes.'}]}', name=Optional[ingredientNames]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The page number to retrieve.'}]}', name=Optional[page]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The number of items per page.'}]}', name=Optional[size]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The pagination mode.'}]}', name=Optional[mode]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting a '}, JavadocInlineTag{tagName='link', type=LINK, content=' Page'}, JavadocSnippet{text=' of '}, JavadocInlineTag{tagName='link', type=LINK, content=' RecipeDto'}, JavadocSnippet{text=' objects.'}]}', name=Optional.empty}]}",
    "name": "findRecipesByIngredients",
    "body": "{\n    return recipeDao.findByIngredientsNameIn(ingredientNames).collectList().flatMap(list -> PaginationUtil.createPagedResult(list, page, size, mode));\n}",
    "parameters": "[List<String> ingredientNames, int page, int size, String mode]",
    "returnType": "Mono<Page<RecipeDto>>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves recipes containing all of the specified ingredients with pagination.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The list of ingredient names to search for within recipes.'}]}', name=Optional[ingredientNames]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The page number to retrieve.'}]}', name=Optional[page]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The number of items per page.'}]}', name=Optional[size]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The pagination mode.'}]}', name=Optional[mode]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting a '}, JavadocInlineTag{tagName='link', type=LINK, content=' Page'}, JavadocSnippet{text=' of '}, JavadocInlineTag{tagName='link', type=LINK, content=' RecipeDto'}, JavadocSnippet{text=' objects.'}]}', name=Optional.empty}]}",
    "name": "findRecipesByAllIngredients",
    "body": "{\n    return recipeDao.findByAllIngredientsNameIn(ingredientNames).collectList().flatMap(list -> PaginationUtil.createPagedResult(list, page, size, mode));\n}",
    "parameters": "[List<String> ingredientNames, int page, int size, String mode]",
    "returnType": "Mono<Page<RecipeDto>>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves a recipe by its ID.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ID of the recipe to retrieve.'}]}', name=Optional[id]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting the '}, JavadocInlineTag{tagName='link', type=LINK, content=' RecipeDto'}, JavadocSnippet{text=' object, or an error if not found.'}]}', name=Optional.empty}]}",
    "name": "getRecipeById",
    "body": "{\n    return recipeDao.findById(id).switchIfEmpty(Mono.error(new ResourceNotFoundException(\"Recipe not found with id=\" + id)));\n}",
    "parameters": "[String id]",
    "returnType": "Mono<RecipeDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves recipes by a list of IDs.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The list of IDs of the recipes to retrieve.'}]}', name=Optional[ids]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting a map containing found recipes and not found IDs.'}]}', name=Optional.empty}]}",
    "name": "getRecipesByIds",
    "body": "{\n    return recipeDao.findAllById(ids).collectList().flatMap(recipes -> {\n        List<String> foundIds = recipes.stream().map(RecipeDto::getId).toList();\n        List<String> notFoundIds = ids.stream().filter(id -> !foundIds.contains(id)).toList();\n        Map<String, Object> result = new HashMap<>();\n        result.put(\"found\", recipes);\n        result.put(\"notFound\", notFoundIds);\n        return Mono.just(result);\n    });\n}",
    "parameters": "[List<String> ids]",
    "returnType": "Mono<Map<String,Object>>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves a recipe by its name, case insensitive.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The name of the recipe to retrieve.'}]}', name=Optional[name]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting the '}, JavadocInlineTag{tagName='link', type=LINK, content=' RecipeDto'}, JavadocSnippet{text=' object, or an error if not found.'}]}', name=Optional.empty}]}",
    "name": "getRecipeByName",
    "body": "{\n    return recipeDao.findByNameIgnoreCase(name).switchIfEmpty(Mono.error(new ResourceNotFoundException(\"Recipe not found with name=\" + name)));\n}",
    "parameters": "[String name]",
    "returnType": "Mono<RecipeDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates multiple recipes.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The recipes to create.'}]}', name=Optional[recipes]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Flux'}, JavadocSnippet{text=' emitting the created '}, JavadocInlineTag{tagName='link', type=LINK, content=' RecipeDto'}, JavadocSnippet{text=' objects.'}]}', name=Optional.empty}]}",
    "name": "createRecipes",
    "body": "{\n    return createRecipesComponent.createRecipes(recipes);\n}",
    "parameters": "[Flux<RecipeDto> recipes]",
    "returnType": "Flux<RecipeDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new recipe.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The recipe data to create.'}]}', name=Optional[recipeDto]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting the created '}, JavadocInlineTag{tagName='link', type=LINK, content=' RecipeDto'}, JavadocSnippet{text=' object.'}]}', name=Optional.empty}]}",
    "name": "createRecipe",
    "body": "{\n    return createRecipesComponent.createRecipe(recipeDto);\n}",
    "parameters": "[RecipeDto recipeDto]",
    "returnType": "Mono<RecipeDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Deletes a recipe by its ID.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ID of the recipe to delete.'}]}', name=Optional[id]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting a message indicating the recipe has been deleted, or an error if not found.'}]}', name=Optional.empty}]}",
    "name": "deleteRecipe",
    "body": "{\n    return recipeDao.findById(id).flatMap(existingRecipe -> recipeDao.delete(existingRecipe).then(Mono.just(\"Recipe \" + existingRecipe.getName() + \" has been deleted.\"))).switchIfEmpty(Mono.error(new ResourceNotFoundException(\"Recipe not found with id=\" + id)));\n}",
    "parameters": "[String id]",
    "returnType": "Mono<String>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Deletes all recipes.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' indicating completion of the deletion process.'}]}', name=Optional.empty}]}",
    "name": "deleteAllRecipes",
    "body": "{\n    return recipeDao.deleteAll();\n}",
    "parameters": "[]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves a measure by its ID.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ID of the measure to retrieve.'}]}', name=Optional[id]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting the '}, JavadocInlineTag{tagName='link', type=LINK, content=' MeasureDto'}, JavadocSnippet{text=' object, or an error if not found.'}]}', name=Optional.empty}]}",
    "name": "getMeasureById",
    "body": "{\n    return measureDao.findById(id).switchIfEmpty(Mono.error(new ResourceNotFoundException(\"Measure not found with id=\" + id)));\n}",
    "parameters": "[String id]",
    "returnType": "Mono<MeasureDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves a measure by its name, case insensitive.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The name of the measure to retrieve.'}]}', name=Optional[name]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting the '}, JavadocInlineTag{tagName='link', type=LINK, content=' MeasureDto'}, JavadocSnippet{text=' object, or an error if not found.'}]}', name=Optional.empty}]}",
    "name": "getMeasureByNameIgnoreCase",
    "body": "{\n    return measureDao.findByNameIgnoreCase(name).switchIfEmpty(Mono.error(new ResourceNotFoundException(\"Measure not found with name=\" + name)));\n}",
    "parameters": "[String name]",
    "returnType": "Mono<MeasureDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new measure if it does not already exist.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The measure data to create.'}]}', name=Optional[measureDto]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting the created '}, JavadocInlineTag{tagName='link', type=LINK, content=' MeasureDto'}, JavadocSnippet{text=' object.'}]}', name=Optional.empty}]}",
    "name": "createMeasure",
    "body": "{\n    return measureDao.findByNameIgnoreCase(measureDto.getName()).switchIfEmpty(Mono.defer(() -> measureDao.save(measureDto)));\n}",
    "parameters": "[MeasureDto measureDto]",
    "returnType": "Mono<MeasureDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates multiple measures.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The measures to create.'}]}', name=Optional[measures]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Flux'}, JavadocSnippet{text=' emitting the created '}, JavadocInlineTag{tagName='link', type=LINK, content=' MeasureDto'}, JavadocSnippet{text=' objects.'}]}', name=Optional.empty}]}",
    "name": "createMeasures",
    "body": "{\n    return measures.flatMap(this::createMeasure);\n}",
    "parameters": "[Flux<MeasureDto> measures]",
    "returnType": "Flux<MeasureDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Deletes a measure by its ID.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ID of the measure to delete.'}]}', name=Optional[id]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting a message indicating the measure has been deleted, or an error if not found.'}]}', name=Optional.empty}]}",
    "name": "deleteMeasure",
    "body": "{\n    return measureDao.findById(id).flatMap(existingMeasure -> measureDao.delete(existingMeasure).then(Mono.just(\"Measure \" + existingMeasure.getName() + \" has been deleted.\"))).switchIfEmpty(Mono.error(new ResourceNotFoundException(\"Measure not found with id=\" + id)));\n}",
    "parameters": "[String id]",
    "returnType": "Mono<String>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Deletes all measures.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' indicating completion of the deletion process.'}]}', name=Optional.empty}]}",
    "name": "deleteAllMeasures",
    "body": "{\n    return measureDao.deleteAll();\n}",
    "parameters": "[]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates multiple recipes.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The flux of recipes to create.'}]}', name=Optional[recipes]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Flux'}, JavadocSnippet{text=' emitting the created '}, JavadocInlineTag{tagName='link', type=LINK, content=' RecipeDto'}, JavadocSnippet{text=' objects.'}]}', name=Optional.empty}]}",
    "name": "createRecipes",
    "body": "{\n    return recipes.concatMap(recipe -> Mono.just(recipe).// .delayElement(Duration.ofMillis(50)) // Introduce a delay of 50 ms between each recipe if necessary to avoid race conditions\n    flatMap(this::createRecipe).onErrorResume(e -> {\n        log.error(\"Error occurred while processing recipe '{}': {}\", recipe.getName(), e.getMessage(), e);\n        return Mono.empty();\n    })).onErrorResume(e -> {\n        log.error(\"Error occurred: {}\", e.getMessage(), e);\n        return Flux.empty();\n    });\n}",
    "parameters": "[Flux<RecipeDto> recipes]",
    "returnType": "Flux<RecipeDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a single recipe with retry logic for duplicate key errors.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The recipe data to create.'}]}', name=Optional[recipeDto]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting the created '}, JavadocInlineTag{tagName='link', type=LINK, content=' RecipeDto'}, JavadocSnippet{text=' object.'}]}', name=Optional.empty}]}",
    "name": "createRecipe",
    "body": "{\n    return recipeDao.findByNameIgnoreCase(recipeDto.getName()).switchIfEmpty(createIngredientsAndCategories(recipeDto).flatMap(saved -> recipeDao.save(recipeDto)).retryWhen(Retry.backoff(3, Duration.ofSeconds(1)).filter(this::isDuplicateKeyException).doBeforeRetry(retrySignal -> getWarned(recipeDto.getName(), retrySignal)))).flatMap(Mono::just).onErrorResume(MongoWriteException.class, e -> {\n        log.error(\"Duplicate key error for recipe '{}': {}\", recipeDto.getName(), e.getMessage(), e);\n        return recipeDao.findByNameIgnoreCase(recipeDto.getName());\n    });\n}",
    "parameters": "[RecipeDto recipeDto]",
    "returnType": "Mono<RecipeDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates or finds ingredients and categories for a recipe.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The recipe data to process.'}]}', name=Optional[recipeDto]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting the '}, JavadocInlineTag{tagName='link', type=LINK, content=' RecipeDto'}, JavadocSnippet{text=' object with saved ingredients and categories.'}]}', name=Optional.empty}]}",
    "name": "createIngredientsAndCategories",
    "body": "{\n    return Flux.fromIterable(recipeDto.getIngredients()).concatMap(this::createOrFindIngredient).collectList().flatMap(savedIngredients -> {\n        recipeDto.setIngredients(savedIngredients);\n        return Flux.fromIterable(recipeDto.getCategories()).concatMap(this::createOrFindCategory).collectList();\n    }).flatMap(savedCategories -> {\n        recipeDto.setCategories(savedCategories);\n        return Mono.just(recipeDto);\n    });\n}",
    "parameters": "[RecipeDto recipeDto]",
    "returnType": "Mono<RecipeDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates or finds a single ingredient.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ingredient data to process.'}]}', name=Optional[ingredientDto]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting the '}, JavadocInlineTag{tagName='link', type=LINK, content=' IngredientDto'}, JavadocSnippet{text=' object.'}]}', name=Optional.empty}]}",
    "name": "createOrFindIngredient",
    "body": "{\n    return ingredientDao.findByNameIgnoreCase(ingredientDto.getName()).switchIfEmpty(createOrFindMeasure(ingredientDto.getMeasure()).flatMap(measureSaved -> {\n        ingredientDto.setMeasure(measureSaved);\n        return ingredientDao.save(ingredientDto).retryWhen(Retry.backoff(3, Duration.ofSeconds(1)).filter(this::isDuplicateKeyException).doBeforeRetry(retrySignal -> getWarned(ingredientDto.getName(), retrySignal)));\n    })).flatMap(Mono::just).onErrorResume(MongoWriteException.class, e -> {\n        log.error(\"Duplicate key error for ingredient '{}': {}\", ingredientDto.getName(), e.getMessage(), e);\n        return ingredientDao.findByNameIgnoreCase(ingredientDto.getName());\n    });\n}",
    "parameters": "[IngredientDto ingredientDto]",
    "returnType": "Mono<IngredientDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates or finds a single measure.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The measure data to process.'}]}', name=Optional[measureDto]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting the '}, JavadocInlineTag{tagName='link', type=LINK, content=' MeasureDto'}, JavadocSnippet{text=' object.'}]}', name=Optional.empty}]}",
    "name": "createOrFindMeasure",
    "body": "{\n    return measureDao.findByNameIgnoreCase(measureDto.getName()).switchIfEmpty(measureDao.save(measureDto).retryWhen(Retry.backoff(3, Duration.ofSeconds(1)).filter(this::isDuplicateKeyException).doBeforeRetry(retrySignal -> getWarned(measureDto.getName(), retrySignal)))).flatMap(Mono::just).onErrorResume(MongoWriteException.class, e -> {\n        log.error(\"Duplicate key error for measure '{}': {}\", measureDto.getName(), e.getMessage(), e);\n        return measureDao.findByNameIgnoreCase(measureDto.getName());\n    });\n}",
    "parameters": "[MeasureDto measureDto]",
    "returnType": "Mono<MeasureDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates or finds a single category.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The category data to process.'}]}', name=Optional[categoryDto]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting the '}, JavadocInlineTag{tagName='link', type=LINK, content=' CategoryDto'}, JavadocSnippet{text=' object.'}]}', name=Optional.empty}]}",
    "name": "createOrFindCategory",
    "body": "{\n    return categoryDao.findByNameIgnoreCase(categoryDto.getName()).switchIfEmpty(categoryDao.save(categoryDto).retryWhen(Retry.backoff(3, Duration.ofSeconds(1)).filter(this::isDuplicateKeyException).doBeforeRetry(retrySignal -> getWarned(categoryDto.getName(), retrySignal)))).flatMap(Mono::just).onErrorResume(MongoWriteException.class, e -> {\n        log.error(\"Duplicate key error for category '{}': {}\", categoryDto.getName(), e.getMessage(), e);\n        return categoryDao.findByNameIgnoreCase(categoryDto.getName());\n    });\n}",
    "parameters": "[CategoryDto categoryDto]",
    "returnType": "Mono<CategoryDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Checks if the given throwable is a duplicate key error.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The throwable to check.'}]}', name=Optional[throwable]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if the throwable is a duplicate key error, false otherwise.'}]}', name=Optional.empty}]}",
    "name": "isDuplicateKeyException",
    "body": "{\n    return throwable instanceof MongoWriteException && ((MongoWriteException) throwable).getCode() == 11000;\n}",
    "parameters": "[Throwable throwable]",
    "returnType": "boolean"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Logs a warning message before retrying due to duplicate key error.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The name of the recipe being retried.'}]}', name=Optional[recipeDto]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The retry signal containing failure information.'}]}', name=Optional[retrySignal]}]}",
    "name": "getWarned",
    "body": "{\n    log.warn(RETRYING_DUE_TO_DUPLICATE_KEY_ERROR, recipeDto, retrySignal.failure().getMessage());\n}",
    "parameters": "[String recipeDto, Retry.RetrySignal retrySignal]",
    "returnType": "void"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates multiple ingredients.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The flux of ingredients to create.'}]}', name=Optional[ingredients]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Flux'}, JavadocSnippet{text=' emitting the created '}, JavadocInlineTag{tagName='link', type=LINK, content=' IngredientDto'}, JavadocSnippet{text=' objects.'}]}', name=Optional.empty}]}",
    "name": "createIngredients",
    "body": "{\n    return ingredients.concatMap(ingredient -> Mono.just(ingredient).// .delayElement(Duration.ofMillis(50)) // Introduce un retraso de 50 ms entre cada ingrediente si es necesario\n    flatMap(this::createIngredient).onErrorResume(e -> {\n        log.error(\"Error occurred while processing ingredient '{}': {}\", ingredient.getName(), e.getMessage(), e);\n        return Mono.empty();\n    })).onErrorResume(e -> {\n        log.error(\"Error occurred: {}\", e.getMessage(), e);\n        return Flux.empty();\n    });\n}",
    "parameters": "[Flux<IngredientDto> ingredients]",
    "returnType": "Flux<IngredientDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a single ingredient with retry logic for duplicate key errors.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ingredient data to create.'}]}', name=Optional[ingredientDto]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting the created '}, JavadocInlineTag{tagName='link', type=LINK, content=' IngredientDto'}, JavadocSnippet{text=' object.'}]}', name=Optional.empty}]}",
    "name": "createIngredient",
    "body": "{\n    return measureDao.findByNameIgnoreCase(ingredientDto.getMeasure().getName()).switchIfEmpty(Mono.defer(() -> measureDao.save(ingredientDto.getMeasure()))).flatMap(measureSaved -> {\n        ingredientDto.setMeasure(measureSaved);\n        return ingredientDao.findByNameIgnoreCase(ingredientDto.getName()).switchIfEmpty(Mono.defer(() -> ingredientDao.save(ingredientDto)).retryWhen(Retry.backoff(3, Duration.ofSeconds(1)).filter(this::isDuplicateKeyException).doBeforeRetry(retrySignal -> getWarned(ingredientDto.getName(), retrySignal))));\n    }).flatMap(Mono::just).onErrorResume(MongoWriteException.class, e -> {\n        log.error(\"Duplicate key error for ingredient '{}': {}\", ingredientDto.getName(), e.getMessage(), e);\n        return ingredientDao.findByNameIgnoreCase(ingredientDto.getName());\n    });\n}",
    "parameters": "[IngredientDto ingredientDto]",
    "returnType": "Mono<IngredientDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Checks if the given throwable is a duplicate key error.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The throwable to check.'}]}', name=Optional[throwable]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if the throwable is a duplicate key error, false otherwise.'}]}', name=Optional.empty}]}",
    "name": "isDuplicateKeyException",
    "body": "{\n    return throwable instanceof MongoWriteException && ((MongoWriteException) throwable).getCode() == 11000;\n}",
    "parameters": "[Throwable throwable]",
    "returnType": "boolean"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Logs a warning message before retrying due to duplicate key error.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The name of the ingredient being retried.'}]}', name=Optional[ingredientName]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The retry signal containing failure information.'}]}', name=Optional[retrySignal]}]}",
    "name": "getWarned",
    "body": "{\n    log.warn(RETRYING_DUE_TO_DUPLICATE_KEY_ERROR, ingredientName, retrySignal.failure().getMessage());\n}",
    "parameters": "[String ingredientName, Retry.RetrySignal retrySignal]",
    "returnType": "void"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves all ingredients with pagination.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The page number to retrieve.'}]}', name=Optional[page]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The number of items per page.'}]}', name=Optional[size]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The pagination mode.'}]}', name=Optional[mode]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting a '}, JavadocInlineTag{tagName='link', type=LINK, content=' Page'}, JavadocSnippet{text=' of '}, JavadocInlineTag{tagName='link', type=LINK, content=' IngredientDto'}, JavadocSnippet{text=' objects.'}]}', name=Optional.empty}]}",
    "name": "getAllCategories",
    "body": "{\n    return ingredientDao.findAll().collectList().flatMap(list -> PaginationUtil.createPagedResult(list, page, size, mode));\n}",
    "parameters": "[int page, int size, String mode]",
    "returnType": "Mono<Page<IngredientDto>>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves ingredients by name containing a string with pagination.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The string to search for within ingredient names.'}]}', name=Optional[name]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The page number to retrieve.'}]}', name=Optional[page]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The number of items per page.'}]}', name=Optional[size]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The pagination mode.'}]}', name=Optional[mode]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting a '}, JavadocInlineTag{tagName='link', type=LINK, content=' Page'}, JavadocSnippet{text=' of '}, JavadocInlineTag{tagName='link', type=LINK, content=' IngredientDto'}, JavadocSnippet{text=' objects.'}]}', name=Optional.empty}]}",
    "name": "getCategoriesByNameContaining",
    "body": "{\n    return ingredientDao.findByNameContainingIgnoreCase(name).collectList().flatMap(list -> PaginationUtil.createPagedResult(list, page, size, mode));\n}",
    "parameters": "[String name, int page, int size, String mode]",
    "returnType": "Mono<Page<IngredientDto>>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves an ingredient by its ID.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ID of the ingredient to retrieve.'}]}', name=Optional[id]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting the '}, JavadocInlineTag{tagName='link', type=LINK, content=' IngredientDto'}, JavadocSnippet{text=' object, or an error if not found.'}]}', name=Optional.empty}]}",
    "name": "getIngredientById",
    "body": "{\n    return ingredientDao.findById(id).switchIfEmpty(Mono.error(new ResourceNotFoundException(\"Ingredient not found with id=\" + id)));\n}",
    "parameters": "[String id]",
    "returnType": "Mono<IngredientDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves ingredients by a list of IDs.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The list of IDs of the ingredients to retrieve.'}]}', name=Optional[ids]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting a map containing found ingredients and not found IDs.'}]}', name=Optional.empty}]}",
    "name": "getIngredientsByIds",
    "body": "{\n    return ingredientDao.findAllById(ids).collectList().flatMap(ingredients -> {\n        List<String> foundIds = ingredients.stream().map(IngredientDto::getId).toList();\n        List<String> notFoundIds = ids.stream().filter(id -> !foundIds.contains(id)).toList();\n        Map<String, Object> result = new HashMap<>();\n        result.put(\"found\", ingredients);\n        result.put(\"notFound\", notFoundIds);\n        return Mono.just(result);\n    });\n}",
    "parameters": "[List<String> ids]",
    "returnType": "Mono<Map<String,Object>>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves an ingredient by its name, case insensitive.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The name of the ingredient to retrieve.'}]}', name=Optional[name]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting the '}, JavadocInlineTag{tagName='link', type=LINK, content=' IngredientDto'}, JavadocSnippet{text=' object, or an error if not found.'}]}', name=Optional.empty}]}",
    "name": "getIngredientByName",
    "body": "{\n    return ingredientDao.findByNameIgnoreCase(name).switchIfEmpty(Mono.error(new ResourceNotFoundException(\"Ingredient not found with name=\" + name)));\n}",
    "parameters": "[String name]",
    "returnType": "Mono<IngredientDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new ingredient.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ingredient data to create.'}]}', name=Optional[ingredientDto]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting the created '}, JavadocInlineTag{tagName='link', type=LINK, content=' IngredientDto'}, JavadocSnippet{text=' object.'}]}', name=Optional.empty}]}",
    "name": "createIngredient",
    "body": "{\n    return createIngredientsComponent.createIngredient(ingredientDto);\n}",
    "parameters": "[IngredientDto ingredientDto]",
    "returnType": "Mono<IngredientDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates multiple ingredients.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ingredients to create.'}]}', name=Optional[ingredients]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Flux'}, JavadocSnippet{text=' emitting the created '}, JavadocInlineTag{tagName='link', type=LINK, content=' IngredientDto'}, JavadocSnippet{text=' objects.'}]}', name=Optional.empty}]}",
    "name": "createCategories",
    "body": "{\n    return createIngredientsComponent.createIngredients(ingredients);\n}",
    "parameters": "[Flux<IngredientDto> ingredients]",
    "returnType": "Flux<IngredientDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Deletes an ingredient by its ID.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ID of the ingredient to delete.'}]}', name=Optional[id]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting a message indicating the ingredient has been deleted, or an error if not found.'}]}', name=Optional.empty}]}",
    "name": "deleteIngredient",
    "body": "{\n    return ingredientDao.findById(id).flatMap(existingIngredient -> ingredientDao.delete(existingIngredient).then(Mono.just(\"Ingredient \" + existingIngredient.getName() + \" has been deleted.\"))).switchIfEmpty(Mono.error(new ResourceNotFoundException(\"Ingredient not found with id=\" + id)));\n}",
    "parameters": "[String id]",
    "returnType": "Mono<String>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Deletes all ingredients.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' indicating completion of the deletion process.'}]}', name=Optional.empty}]}",
    "name": "deleteAllCategories",
    "body": "{\n    return ingredientDao.deleteAll();\n}",
    "parameters": "[]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves all categories with pagination.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The page number to retrieve.'}]}', name=Optional[page]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The number of items per page.'}]}', name=Optional[size]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The pagination mode.'}]}', name=Optional[mode]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting a '}, JavadocInlineTag{tagName='link', type=LINK, content=' Page'}, JavadocSnippet{text=' of '}, JavadocInlineTag{tagName='link', type=LINK, content=' CategoryDto'}, JavadocSnippet{text=' objects.'}]}', name=Optional.empty}]}",
    "name": "getAllCategories",
    "body": "{\n    return categoryDao.findAll().collectList().flatMap(list -> PaginationUtil.createPagedResult(list, page, size, mode));\n}",
    "parameters": "[int page, int size, String mode]",
    "returnType": "Mono<Page<CategoryDto>>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves categories by name containing a string with pagination.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The string to search for within category names.'}]}', name=Optional[name]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The page number to retrieve.'}]}', name=Optional[page]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The number of items per page.'}]}', name=Optional[size]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The pagination mode.'}]}', name=Optional[mode]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting a '}, JavadocInlineTag{tagName='link', type=LINK, content=' Page'}, JavadocSnippet{text=' of '}, JavadocInlineTag{tagName='link', type=LINK, content=' CategoryDto'}, JavadocSnippet{text=' objects.'}]}', name=Optional.empty}]}",
    "name": "getCategoriesByNameContaining",
    "body": "{\n    return categoryDao.findByNameContainingIgnoreCase(name).collectList().flatMap(list -> PaginationUtil.createPagedResult(list, page, size, mode));\n}",
    "parameters": "[String name, int page, int size, String mode]",
    "returnType": "Mono<Page<CategoryDto>>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves a category by its ID.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ID of the category to retrieve.'}]}', name=Optional[id]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting the '}, JavadocInlineTag{tagName='link', type=LINK, content=' CategoryDto'}, JavadocSnippet{text=' object, or an error if not found.'}]}', name=Optional.empty}]}",
    "name": "getCategoryById",
    "body": "{\n    return categoryDao.findById(id).switchIfEmpty(Mono.error(new ResourceNotFoundException(\"Category not found with id=\" + id)));\n}",
    "parameters": "[String id]",
    "returnType": "Mono<CategoryDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves a category by its name, case insensitive.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The name of the category to retrieve.'}]}', name=Optional[name]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting the '}, JavadocInlineTag{tagName='link', type=LINK, content=' CategoryDto'}, JavadocSnippet{text=' object, or an error if not found.'}]}', name=Optional.empty}]}",
    "name": "getCategoryByNameIgnoreCase",
    "body": "{\n    return categoryDao.findByNameIgnoreCase(name).switchIfEmpty(Mono.error(new ResourceNotFoundException(\"Category not found with name=\" + name)));\n}",
    "parameters": "[String name]",
    "returnType": "Mono<CategoryDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new category if it does not already exist.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The category data to create.'}]}', name=Optional[categoryDto]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting the created '}, JavadocInlineTag{tagName='link', type=LINK, content=' CategoryDto'}, JavadocSnippet{text=' object.'}]}', name=Optional.empty}]}",
    "name": "createCategory",
    "body": "{\n    return categoryDao.findByNameIgnoreCase(categoryDto.getName()).switchIfEmpty(Mono.defer(() -> categoryDao.save(categoryDto)));\n}",
    "parameters": "[CategoryDto categoryDto]",
    "returnType": "Mono<CategoryDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates multiple categories.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The categories to create.'}]}', name=Optional[categories]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Flux'}, JavadocSnippet{text=' emitting the created '}, JavadocInlineTag{tagName='link', type=LINK, content=' CategoryDto'}, JavadocSnippet{text=' objects.'}]}', name=Optional.empty}]}",
    "name": "createCategories",
    "body": "{\n    return categories.flatMap(this::createCategory);\n}",
    "parameters": "[Flux<CategoryDto> categories]",
    "returnType": "Flux<CategoryDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Deletes a category by its ID.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ID of the category to delete.'}]}', name=Optional[id]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' emitting a message indicating the category has been deleted, or an error if not found.'}]}', name=Optional.empty}]}",
    "name": "deleteCategory",
    "body": "{\n    return categoryDao.findById(id).flatMap(existingCategory -> categoryDao.delete(existingCategory).then(Mono.just(\"Category \" + existingCategory.getName() + \" has been deleted.\"))).switchIfEmpty(Mono.error(new ResourceNotFoundException(\"Category not found with id=\" + id)));\n}",
    "parameters": "[String id]",
    "returnType": "Mono<String>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Deletes all categories.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A '}, JavadocInlineTag{tagName='link', type=LINK, content=' Mono'}, JavadocSnippet{text=' indicating completion of the deletion process.'}]}', name=Optional.empty}]}",
    "name": "deleteAllCategories",
    "body": "{\n    return categoryDao.deleteAll();\n}",
    "parameters": "[]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "",
    "name": "reactiveMongoTemplate",
    "body": "{\n    return new ReactiveMongoTemplate(new SimpleReactiveMongoDatabaseFactory(MongoClients.create(mongoUri), \"cookers\"));\n}",
    "parameters": "[]",
    "returnType": "ReactiveMongoTemplate"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    userDTO = userDtoBasicOk();\n    favoriteDto = generateFavoriteDto();\n    favoriteDtoVerify = generateFavoriteDto();\n    // Crear un spy para favoriteDto\n    favoriteDto = Mockito.spy(favoriteDto);\n    when(userDao.findByEmail(EMAIL)).thenReturn(Mono.just(userDTO));\n    when(favoriteDao.findById(ID)).thenReturn(Mono.just(favoriteDto));\n    when(favoriteDao.save(any(FavoriteDto.class))).thenAnswer(invocation -> Mono.just(invocation.getArguments()[0]));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testGetFavoritesByID",
    "body": "{\n    when(userDao.findByEmail(EMAIL)).thenReturn(Mono.just(userDTO));\n    baseTestFavoritesOK(favoritesEndpoint, tokenUserOk(), requestFavorite(), USER_FAVORITES_RETRIEVED, favoriteDto);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testGetFavoritesByEmail",
    "body": "{\n    when(userDao.findByEmail(EMAIL)).thenReturn(Mono.just(userDTO));\n    baseTestFavoritesOK(favoritesEndpoint, tokenUserOk(), requestFavorite(), USER_FAVORITES_RETRIEVED, favoriteDto);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testAddFavoriteRecipeByID",
    "body": "{\n    favoriteDtoVerify.getRecipes().add(recipe);\n    pathVariable = favoritesEndpoint + addRecipeEndpoint;\n    baseTestFavoritesOK(pathVariable, tokenUserOk(), requestFavoriteRecipe(), RECIPE_SUCCESSFULLY_ADDED_TO_FAVORITES, favoriteDtoVerify);\n    // Verificar que el método addRecipe fue llamado\n    Mockito.verify(favoriteDto).addRecipe(recipe);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testAddFavoriteRecipeEmail",
    "body": "{\n    favoriteDtoVerify.getRecipes().add(recipe);\n    pathVariable = favoritesEndpoint + addRecipeEndpoint;\n    baseTestFavoritesOK(pathVariable, tokenUserOk(), requestFavoriteRecipe(), RECIPE_SUCCESSFULLY_ADDED_TO_FAVORITES, favoriteDtoVerify);\n    // Verificar que el método addRecipe fue llamado\n    Mockito.verify(favoriteDto).addRecipe(recipe);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testRemoveFavoriteRecipeByID",
    "body": "{\n    favoriteDto.getRecipes().add(recipe);\n    pathVariable = favoritesEndpoint + removeRecipeEndpoint;\n    baseTestFavoritesOK(pathVariable, tokenUserOk(), requestFavoriteRecipe(), RECIPE_SUCCESSFULLY_REMOVED_FROM_FAVORITES, favoriteDtoVerify);\n    // Verificar que el método removeRecipe fue llamado\n    Mockito.verify(favoriteDto).removeRecipe(recipe);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testRemoveFavoriteRecipeEmail",
    "body": "{\n    favoriteDto.getRecipes().add(recipe);\n    pathVariable = favoritesEndpoint + removeRecipeEndpoint;\n    baseTestFavoritesOK(pathVariable, tokenUserOk(), requestFavoriteRecipe(), RECIPE_SUCCESSFULLY_REMOVED_FROM_FAVORITES, favoriteDtoVerify);\n    // Verificar que el método removeRecipe fue llamado\n    Mockito.verify(favoriteDto).removeRecipe(recipe);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testAddFavoriteIngredientByID",
    "body": "{\n    favoriteDtoVerify.getIngredients().add(ingredient);\n    pathVariable = favoritesEndpoint + addIngredientEndpoint;\n    baseTestFavoritesOK(pathVariable, tokenUserOk(), requestFavoriteIngredient(), INGREDIENT_SUCCESSFULLY_ADDED_TO_FAVORITES, favoriteDtoVerify);\n    // Verificar que el método addIngredient fue llamado\n    Mockito.verify(favoriteDto).addIngredient(ingredient);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testAddFavoriteIngredientEmail",
    "body": "{\n    favoriteDtoVerify.getIngredients().add(ingredient);\n    pathVariable = favoritesEndpoint + addIngredientEndpoint;\n    baseTestFavoritesOK(pathVariable, tokenUserOk(), requestFavoriteIngredient(), INGREDIENT_SUCCESSFULLY_ADDED_TO_FAVORITES, favoriteDtoVerify);\n    // Verificar que el método addIngredient fue llamado\n    Mockito.verify(favoriteDto).addIngredient(ingredient);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testRemoveFavoriteIngredientByID",
    "body": "{\n    favoriteDto.getIngredients().add(ingredient);\n    pathVariable = favoritesEndpoint + removeIngredientEndpoint;\n    baseTestFavoritesOK(pathVariable, tokenUserOk(), requestFavoriteIngredient(), INGREDIENT_SUCCESSFULLY_REMOVED_FROM_FAVORITES, favoriteDtoVerify);\n    // Verificar que el método removeIngredient fue llamado\n    Mockito.verify(favoriteDto).removeIngredient(ingredient);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testRemoveFavoriteIngredientEmail",
    "body": "{\n    favoriteDto.getIngredients().add(ingredient);\n    pathVariable = favoritesEndpoint + removeIngredientEndpoint;\n    baseTestFavoritesOK(pathVariable, tokenUserOk(), requestFavoriteIngredient(), INGREDIENT_SUCCESSFULLY_REMOVED_FROM_FAVORITES, favoriteDtoVerify);\n    // Verificar que el método removeIngredient fue llamado\n    Mockito.verify(favoriteDto).removeIngredient(ingredient);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testFailGetFavoritesByID",
    "body": "{\n    String invalidId = \"invalid-id\";\n    userDTO.set_id(invalidId);\n    when(userDao.findBy_id(anyString())).thenReturn(Mono.just(userDTO));\n    baseTestFavoritesFail(favoritesEndpoint, tokenOtherUserOk(invalidId), requestFavorite());\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testFailGetFavoritesByEmail",
    "body": "{\n    String invalidEmail = \"invalid@email.com\";\n    String invalidId = \"invalid-id\";\n    userDTO.set_id(invalidId);\n    userDTO.setEmail(invalidEmail);\n    when(userDao.findByEmail(anyString())).thenReturn(Mono.just(userDTO));\n    baseTestFavoritesFail(favoritesEndpoint, tokenOtherUserOk(invalidEmail), requestFavorite());\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "baseTestFavoritesOK",
    "body": "{\n    webTestClient.post().uri(path).header(\"Authorization\", token).contentType(MediaType.APPLICATION_JSON).bodyValue(body).exchange().expectStatus().isOk().expectBody().consumeWith(response -> {\n        // Convert the response body to a string and print it\n        String receivedBody = new String(Objects.requireNonNull(response.getResponseBody()));\n        System.out.println(receivedBody);\n    }).jsonPath(\"$.success\").isEqualTo(true).jsonPath(\"$.message\").isEqualTo(msg).jsonPath(\"$.content.id\").isEqualTo(favoriteDto.getId()).jsonPath(\"$.content.recipes\").value(recipesList -> {\n        assertThat(recipesList).isInstanceOf(List.class);\n        List<String> recipes = (List<String>) recipesList;\n        assertThat(recipes).containsAll(favoriteDto.getRecipes());\n    }).jsonPath(\"$.content.ingredients\").value(ingredientsList -> {\n        assertThat(ingredientsList).isInstanceOf(List.class);\n        List<String> ingredients = (List<String>) ingredientsList;\n        assertThat(ingredients).containsAll(favoriteDto.getIngredients());\n    });\n}",
    "parameters": "[String path, String token, String body, String msg, FavoriteDto favoriteDto]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "baseTestFavoritesFail",
    "body": "{\n    webTestClient.post().uri(path).header(\"Authorization\", token).contentType(MediaType.APPLICATION_JSON).bodyValue(body).exchange().expectStatus().isUnauthorized().expectBody().consumeWith(response -> {\n        // Convert the response body to a string and print it\n        String receivedBody = new String(Objects.requireNonNull(response.getResponseBody()));\n        System.out.println(receivedBody);\n    }).jsonPath(\"$.success\").isEqualTo(false).jsonPath(\"$.message\").value(text -> Assertions.assertThat(text).asString().contains(BaseTestClass.UN_AUTH_MESSAGE));\n}",
    "parameters": "[String path, String token, String body]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "generateFavoriteDto",
    "body": "{\n    FavoriteDto favoriteDto = new FavoriteDto();\n    favoriteDto.setId(ID);\n    favoriteDto.setRecipes(recipes);\n    favoriteDto.setIngredients(ingredients);\n    return favoriteDto;\n}",
    "parameters": "[]",
    "returnType": "FavoriteDto"
  },
  {
    "javadoc": "",
    "name": "requestFavorite",
    "body": "{\n    return \"{ \\\"userId\\\": \\\"\" + ID + \"\\\" }\";\n}",
    "parameters": "[]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "requestFavoriteRecipe",
    "body": "{\n    return \"{ \\\"userId\\\": \\\"\" + ID + \"\\\", \" + \"\\\"recipeId\\\": \\\"\" + \"recipe-X\" + \"\\\" }\";\n}",
    "parameters": "[]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "requestFavoriteIngredient",
    "body": "{\n    return \"{ \\\"userId\\\": \\\"\" + ID + \"\\\", \" + \"\\\"ingredientId\\\": \\\"\" + \"ingredient-x\" + \"\\\" }\";\n}",
    "parameters": "[]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    argumentCaptor = ArgumentCaptor.forClass(UserDto.class);\n    Mockito.when(userDao.findByEmail(EMAIL)).thenReturn(Mono.just(userDtoBasicOk()));\n    Mockito.when(userDao.findBy_id(ID)).thenReturn(Mono.just(userDtoBasicOk()));\n    Mockito.when(userDao.save(Mockito.any(UserDto.class))).thenAnswer(invocation -> Mono.just(invocation.getArguments()[0]));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testUpdateUserWithValidData",
    "body": "{\n    final String message = \"User successfully UPDATED\";\n    webTestClient.put().uri(updateOneEndpoint).header(\"Authorization\", tokenUserOk()).contentType(MediaType.APPLICATION_JSON).bodyValue(requestBody).exchange().expectStatus().isOk().expectBody().jsonPath(\"$.success\").isEqualTo(true).jsonPath(\"$.message\").isEqualTo(message).jsonPath(\"$.content._id\").isEqualTo(ID).jsonPath(\"$.content.email\").isEqualTo(email).jsonPath(\"$.content.firstName\").isEqualTo(firstName).jsonPath(\"$.content.surNames\").isEqualTo(surNames).jsonPath(\"$.content.birthdate\").isEqualTo(birthdate).jsonPath(\"$.content.roleType\").isEqualTo(Role.BASIC.get()).jsonPath(\"$.content.accountStatus\").isEqualTo(OK.toString()).jsonPath(\"$.content.accountStatusMsg\").isEqualTo(OK.getDetails());\n    Mockito.verify(userDao).save(argumentCaptor.capture());\n    UserDto capturedUserDto = argumentCaptor.getValue();\n    final String[] dateParts = birthdate.split(\"-\");\n    final int year = Integer.parseInt(dateParts[0]);\n    final int month = Integer.parseInt(dateParts[1]);\n    final int day = Integer.parseInt(dateParts[2]);\n    assertAll(() -> assertEquals(email, capturedUserDto.getEmail()), () -> assertTrue(encryptMatches(password, capturedUserDto.getPassword())), () -> assertEquals(firstName, capturedUserDto.getFirstName()), () -> assertEquals(surNames, capturedUserDto.getSurNames()), () -> assertEquals(LocalDate.of(year, month, day), capturedUserDto.getBirthdate()));\n}",
    "parameters": "[String requestBody, String email, String password, String firstName, String surNames, String birthdate]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "provideVariablesForSuccessUpdates",
    "body": "{\n    String newEmail = \"test@test.com\";\n    String newPass = \"tesT321@\";\n    String newName = \"Fauno\";\n    String newSurname = \"Guazina\";\n    String newBirthdate = \"1999-09-09\";\n    final String reqBodyJustEmail = updateReqBody(newEmail, empty, empty, empty, empty);\n    final String reqBodyNewPass = updateReqBodyNewPass(newPass);\n    final String reqBodyJustFname = updateReqBody(empty, empty, newName, empty, empty);\n    final String reqBodyJustSname = updateReqBody(empty, empty, empty, newSurname, empty);\n    final String reqBodyJustBdate = updateReqBody(empty, empty, empty, empty, newBirthdate);\n    return Stream.of(Arguments.of(reqBodyJustEmail, newEmail, PASSWORD, FIRST_NAME, SUR_NAMES, BIRTHDATE_STR), Arguments.of(reqBodyNewPass, EMAIL, newPass, FIRST_NAME, SUR_NAMES, BIRTHDATE_STR), Arguments.of(reqBodyJustFname, EMAIL, PASSWORD, newName, SUR_NAMES, BIRTHDATE_STR), Arguments.of(reqBodyJustSname, EMAIL, PASSWORD, FIRST_NAME, newSurname, BIRTHDATE_STR), Arguments.of(reqBodyJustBdate, EMAIL, PASSWORD, FIRST_NAME, SUR_NAMES, newBirthdate));\n}",
    "parameters": "[]",
    "returnType": "Stream<Arguments>"
  },
  {
    "javadoc": "",
    "name": "testUpdateUserWithInvalidData",
    "body": "{\n    testPutEndpointWithTokenSuccessFalseMessageContains(updateOneEndpoint, tokenUserOk(), requestBody, httpStatus, message);\n}",
    "parameters": "[String requestBody, int httpStatus, String message]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "provideVariablesForFailUpdates",
    "body": "{\n    final String notUpdateMsg = \"No update required or data is invalid\";\n    final String unAuthMessage = \"No tienes permiso para acceder a esta información\";\n    final String invalidBody = \"Invalid request body or not present\";\n    final int httpOk = HttpStatus.OK.value();\n    final int httpBad = HttpStatus.BAD_REQUEST.value();\n    final int httpUnAuth = HttpStatus.UNAUTHORIZED.value();\n    final String reqBodyPassWithoutLowercaseLetter = updateReqBodyNewPass(\"1234!ABC\");\n    final String reqBodyPassWithoutUppercaseLetter = updateReqBodyNewPass(\"1234!abc\");\n    final String reqBodyPassWithoutDigit = updateReqBodyNewPass(\"Abcd!efg\");\n    final String reqBodyPassWithoutSpecialChar = updateReqBodyNewPass(\"Abcd1Efg\");\n    final String reqBodyPassShorterThan8Char = updateReqBodyNewPass(\"A1b!ef\");\n    return Stream.of(Arguments.of(updateReqBody(empty, empty, empty, empty, empty), httpOk, notUpdateMsg), Arguments.of(updateReqBody(blank, blank, blank, blank, blank), httpOk, notUpdateMsg), Arguments.of(updateReqBody(null, empty, empty, empty, empty), httpOk, notUpdateMsg), Arguments.of(updateReqBody(null, blank, blank, blank, blank), httpOk, notUpdateMsg), Arguments.of(updateReqBody(empty, null, empty, empty, empty), httpOk, notUpdateMsg), Arguments.of(updateReqBody(blank, null, blank, blank, blank), httpOk, notUpdateMsg), Arguments.of(reqBodyPassWithoutLowercaseLetter, httpOk, notUpdateMsg), Arguments.of(reqBodyPassWithoutUppercaseLetter, httpOk, notUpdateMsg), Arguments.of(reqBodyPassWithoutDigit, httpOk, notUpdateMsg), Arguments.of(reqBodyPassWithoutSpecialChar, httpOk, notUpdateMsg), Arguments.of(reqBodyPassShorterThan8Char, httpOk, notUpdateMsg), Arguments.of(updateReqBody(empty, empty, null, empty, empty), httpOk, notUpdateMsg), Arguments.of(updateReqBody(blank, blank, null, blank, blank), httpOk, notUpdateMsg), Arguments.of(updateReqBody(empty, empty, empty, null, empty), httpOk, notUpdateMsg), Arguments.of(updateReqBody(blank, blank, blank, null, blank), httpOk, notUpdateMsg), Arguments.of(updateReqBody(empty, empty, empty, empty, null), httpBad, invalidBody), Arguments.of(updateReqBody(blank, blank, blank, blank, null), httpBad, invalidBody), Arguments.of(updateReqBody(EMAIL, empty, empty, empty, empty), httpOk, notUpdateMsg), Arguments.of(updateReqBody(empty, PASSWORD, empty, empty, empty), httpOk, notUpdateMsg), Arguments.of(updateReqBody(empty, empty, FIRST_NAME, empty, empty), httpOk, notUpdateMsg), Arguments.of(updateReqBody(empty, empty, empty, SUR_NAMES, empty), httpOk, notUpdateMsg), Arguments.of(updateReqBody(empty, empty, empty, empty, BIRTHDATE_STR), httpOk, notUpdateMsg), Arguments.of(requestBodyFullWhitID(ID + \"a\", empty, empty, empty, empty, empty), httpUnAuth, unAuthMessage));\n}",
    "parameters": "[]",
    "returnType": "Stream<Arguments>"
  },
  {
    "javadoc": "",
    "name": "updateReqBody",
    "body": "{\n    return requestBodyFullWhitID(ID, email, password, firstName, surNames, birthdate);\n}",
    "parameters": "[String email, String password, String firstName, String surNames, String birthdate]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "updateReqBodyNewPass",
    "body": "{\n    return requestBodyFullWhitIdAndNewPassword(newPassword);\n}",
    "parameters": "[String newPassword]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "testLoginIsSuccessful",
    "body": "{\n    Mockito.when(userDao.findByEmail(Mockito.anyString())).thenReturn(userResponse);\n    Mockito.when(userDao.delete(Mockito.any(UserDto.class))).thenReturn(Mono.empty());\n    webTestClient.post().uri(loginEndpoint).contentType(MediaType.APPLICATION_JSON).bodyValue(requestBody).exchange().expectStatus().isOk().expectBody().jsonPath(\"$.success\").isEqualTo(true).jsonPath(\"$.message\").isEqualTo(\"TOKEN\").jsonPath(\"$.content\").value(token -> {\n        assertNotNull(token);\n        assertTrue(jwtUtil.isValidToken(jwtUtil.getPrefix() + token));\n    });\n}",
    "parameters": "[Mono<UserDto> userResponse]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "provideVariablesForSuccessLoginRequests",
    "body": "{\n    return Stream.of(Arguments.of(Mono.just(userDtoBasicOk())), Arguments.of(Mono.just(userDtoBasicAccountStatus(OFF))), Arguments.of(Mono.just(userDtoBasicAccountStatus(REQUEST_DELETE))));\n}",
    "parameters": "[]",
    "returnType": "Stream<Arguments>"
  },
  {
    "javadoc": "",
    "name": "testLoginFail",
    "body": "{\n    Mockito.when(userDao.findByEmail(Mockito.anyString())).thenReturn(userResponse);\n    Mockito.when(userDao.findBy_id(Mockito.anyString())).thenReturn(userResponse);\n    Mockito.when(userDao.delete(Mockito.any(UserDto.class))).thenReturn(Mono.empty());\n    Mockito.when(userDao.save(Mockito.any(UserDto.class))).thenAnswer(invocation -> Mono.just(invocation.getArguments()[0]));\n    webTestClient.post().uri(loginEndpoint).contentType(MediaType.APPLICATION_JSON).bodyValue(requestBody).exchange().expectStatus().isUnauthorized().expectBody().jsonPath(\"$.success\").isEqualTo(false).jsonPath(\"$.message\").value(message -> Assertions.assertThat(message).asString().contains(expectedMessagePart));\n}",
    "parameters": "[String expectedMessagePart, Mono<UserDto> userResponse]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "provideVariablesForNoSuccessLoginRequests",
    "body": "{\n    String deleteMsg = \"Your account has been terminated\";\n    return Stream.of(Arguments.of(\"USER NOT FOUND\", Mono.empty()), Arguments.of(PENDING.getDetails(), Mono.just(userDtoBasicPending())), Arguments.of(OUTDATED.getDetails(), Mono.just(userDtoBasicAccountStatus(OUTDATED))), Arguments.of(deleteMsg, Mono.just(userDtoBasicAccountStatus(MARKED_DELETE))));\n}",
    "parameters": "[]",
    "returnType": "Stream<Arguments>"
  },
  {
    "javadoc": "",
    "name": "testLoginIsBadRequest",
    "body": "{\n    testFailRequest_400(loginEndpoint, requestBody, success, message, key);\n}",
    "parameters": "[String requestBody, boolean success, String message, String key]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "provideVariablesForFailRequests",
    "body": "{\n    String reqBodyWithoutPass = \"{ \\\"username\\\": \\\"\" + EMAIL + \"\\\" }\";\n    String reqBodyWithoutUser = \"{ \\\"password\\\": \\\"\" + PASSWORD + \"\\\" }\";\n    String keyPass = \"password\";\n    String keyUser = \"username\";\n    String validationError = \"Validation error\";\n    String reqBodyBadJson = \"{ \\\"username\\\": \\\"\" + EMAIL + \"\\\",\\\"password\\\": }\";\n    String reqBodyError = \"Invalid request body or not present\";\n    String keyError = \"ERROR\";\n    return Stream.of(Arguments.of(reqBodyWithoutPass, false, validationError, keyPass), Arguments.of(reqBodyWithoutUser, false, validationError, keyUser), Arguments.of(\"{}\", false, validationError, keyPass), Arguments.of(\"{}\", false, validationError, keyUser), Arguments.of(reqBodyBadJson, false, reqBodyError, keyError), Arguments.of(empty, false, reqBodyError, keyError));\n}",
    "parameters": "[]",
    "returnType": "Stream<Arguments>"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    pathVariable = usersEndpoint + usersCheckEmailEndpoint;\n    Mockito.when(userDao.existsByEmail(Mockito.anyString())).thenReturn(Mono.just(false));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testExistsByEmail_OK",
    "body": "{\n    Mockito.when(userDao.existsByEmail(email)).thenReturn(Mono.just(exists));\n    webTestClient.post().uri(pathVariable).contentType(MediaType.APPLICATION_JSON).bodyValue(requestBodyOnlyMail(email)).exchange().expectStatus().isOk().expectBody().jsonPath(\"$.success\").isEqualTo(true).jsonPath(\"$.message\").isEqualTo(message).jsonPath(\"$.content\").isEqualTo(content);\n}",
    "parameters": "[String email, boolean exists, String message, boolean content]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testExistsByEmail_Fail",
    "body": "{\n    testFailRequest_400(pathVariable, requestBody, success, message, key);\n}",
    "parameters": "[String requestBody, boolean success, String message, String key]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "provideVariablesForFailRequests",
    "body": "{\n    String messageMail = \"Invalid or incorrect format\";\n    String messageBody = \"Invalid request body or not present\";\n    String badlyJson = \"{\\\"email\\\":}\";\n    String mailKey = \"email\";\n    String errorKey = \"ERROR\";\n    return Stream.of(Arguments.of(requestBodyOnlyMail(\"email@ro ot.com\"), false, messageMail, mailKey), Arguments.of(requestBodyOnlyMail(empty), false, messageMail, mailKey), Arguments.of(requestBodyOnlyMail(null), false, messageMail, mailKey), Arguments.of(badlyJson, false, messageBody, errorKey), Arguments.of(empty, false, messageBody, errorKey));\n}",
    "parameters": "[]",
    "returnType": "Stream<Arguments>"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    pathVariable = usersEndpoint + readOneEndpoint;\n    Mockito.when(userDao.findByEmail(EMAIL)).thenReturn(Mono.just(userDtoBasicOk()));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testReadUserByUser",
    "body": "{\n    baseTestReadUserByEmail_Ok(tokenUserOk());\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testReadUserByAdmin",
    "body": "{\n    String emailAdmin = \"admin@test.com\";\n    Mockito.when(userDao.findByEmail(emailAdmin)).thenReturn(Mono.just(userDtoAdminOk(emailAdmin)));\n    baseTestReadUserByEmail_Ok(tokenAdminOk(emailAdmin));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "baseTestReadUserByEmail_Ok",
    "body": "{\n    webTestClient.post().uri(pathVariable).header(\"Authorization\", token).contentType(MediaType.APPLICATION_JSON).bodyValue(requestBodyOnlyMail(EMAIL)).exchange().expectStatus().isOk().expectBody().jsonPath(\"$.success\").isEqualTo(true).jsonPath(\"$.message\").isEqualTo(\"User successfully read\").jsonPath(\"$.content._id\").isEqualTo(ID).jsonPath(\"$.content.email\").isEqualTo(EMAIL).jsonPath(\"$.content.firstName\").isEqualTo(FIRST_NAME).jsonPath(\"$.content.surNames\").isEqualTo(SUR_NAMES).jsonPath(\"$.content.birthdate\").isEqualTo(BIRTHDATE_STR).jsonPath(\"$.content.roleType\").isEqualTo(Role.BASIC.get()).jsonPath(\"$.content.accountStatus\").isEqualTo(AccountStatus.OK.toString()).jsonPath(\"$.content.accountStatusMsg\").isEqualTo(AccountStatus.OK.getDetails());\n}",
    "parameters": "[String token]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testReadUserByOtherUser",
    "body": "{\n    String emailTest = \"other@email.com\";\n    Mockito.when(userDao.findByEmail(emailTest)).thenReturn(Mono.just(userDtoOtherOk(emailTest)));\n    testPost401EndpointWithTokenSuccessFalseMessageContains(pathVariable, tokenOtherUserOk(emailTest), requestBodyOnlyMail(EMAIL), UN_AUTH_MESSAGE);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testReadUserByUserExpiredToken",
    "body": "{\n    final String unAuthMessage = \"Token expired. Please login again\";\n    testPost401EndpointWithTokenSuccessFalseMessageContains(pathVariable, tokenExpired(), requestBodyOnlyMail(EMAIL), unAuthMessage);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testReadUserByUserInvalidToken",
    "body": "{\n    final String unAuthMessage = \"Invalid token\";\n    testPost401EndpointWithTokenSuccessFalseMessageContains(pathVariable, \"a\" + tokenUserOk(), requestBodyOnlyMail(EMAIL), unAuthMessage);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    pathVariable = usersEndpoint + usersSetNewPasswordEndpoint;\n    userDTO = userDtoBasicOk();\n    resetDto = ResetDto.to(userDTO);\n    newPassword = \"teste!2PASWORD\";\n    body = \"{\\n\" + \"    \\\"_id\\\": \\\"\" + resetDto.getCode() + \"\\\",\\n\" + \"    \\\"newPassword\\\": \\\"\" + newPassword + \"\\\"\\n\" + \"}\";\n    Mockito.when(resetDao.findByCode(Mockito.anyString())).thenReturn(Mono.just(resetDto));\n    Mockito.when(userDao.findBy_id(Mockito.anyString())).thenReturn(Mono.just(userDTO));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testResetPassCodeNotFound",
    "body": "{\n    Mockito.when(resetDao.findByCode(Mockito.anyString())).thenReturn(Mono.empty());\n    htmlToTest = Htmls.FailSetNewPassword.get().replace(\"errorDescriptionValue\", \"Code Not Found\").replace(\"LOGO_WAC\", globalValues.getUrlWacLogoPngSmall()).replace(\"URL_FORGOT_PASS\", globalValues.getUrlForgotPassword()).replace(\"EMAIL_WAC\", globalValues.getMailToWac());\n    webTestClient.post().uri(uriBuilder -> uriBuilder.path(pathVariable).queryParam(\"codeToSet\", \"invalidCode\").build()).contentType(MediaType.APPLICATION_JSON).bodyValue(body).exchange().expectStatus().isBadRequest().expectBody(String.class).value(html -> assertEquals(htmlToTest, html));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testSetNewPassWithInvalidAccountStatus",
    "body": "{\n    userDTO.setAccountStatus(AccountStatus.OFF);\n    String errorMsg = \"Account Status Incorrect for this request: \" + userDTO.getAccountStatus().getDetails();\n    htmlToTest = Htmls.FailSetNewPassword.get().replace(\"errorDescriptionValue\", errorMsg).replace(\"LOGO_WAC\", globalValues.getUrlWacLogoPngSmall()).replace(\"URL_FORGOT_PASS\", globalValues.getUrlForgotPassword()).replace(\"EMAIL_WAC\", globalValues.getMailToWac());\n    webTestClient.post().uri(uriBuilder -> uriBuilder.path(pathVariable).queryParam(\"codeToSet\", resetDto.getCode()).build()).contentType(MediaType.APPLICATION_JSON).bodyValue(body).exchange().expectStatus().isBadRequest().expectBody(String.class).value(html -> assertEquals(htmlToTest, html));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testSetNewPassWithCodeExpired",
    "body": "{\n    resetDto.setExpiration(resetDto.getExpiration().minusDays(1));\n    htmlToTest = Htmls.FailSetNewPassword.get().replace(\"errorDescriptionValue\", \"This Code is Expired\").replace(\"LOGO_WAC\", globalValues.getUrlWacLogoPngSmall()).replace(\"URL_FORGOT_PASS\", globalValues.getUrlForgotPassword()).replace(\"EMAIL_WAC\", globalValues.getMailToWac());\n    webTestClient.post().uri(uriBuilder -> uriBuilder.path(pathVariable).queryParam(\"codeToSet\", resetDto.getCode()).build()).contentType(MediaType.APPLICATION_JSON).bodyValue(body).exchange().expectStatus().isOk().expectBody(String.class).value(html -> assertEquals(htmlToTest, html));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testSetNewPassWithInvalidCode",
    "body": "{\n    userDTO.setPassword(Util.encryptPassword(resetDto.getCode()));\n    htmlToTest = Htmls.FailSetNewPassword.get().replace(\"errorDescriptionValue\", \"Reset code is invalid\").replace(\"LOGO_WAC\", globalValues.getUrlWacLogoPngSmall()).replace(\"URL_FORGOT_PASS\", globalValues.getUrlForgotPassword()).replace(\"EMAIL_WAC\", globalValues.getMailToWac());\n    webTestClient.post().uri(uriBuilder -> uriBuilder.path(pathVariable).queryParam(\"codeToSet\", resetDto.getCode()).build()).contentType(MediaType.APPLICATION_JSON).bodyValue(body.replace(resetDto.getCode(), \"invalidCode\")).exchange().expectStatus().isOk().expectBody(String.class).value(html -> assertEquals(htmlToTest, html));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testSetNewPassWithInvalidPassword",
    "body": "{\n    userDTO.setPassword(Util.encryptPassword(resetDto.getCode()));\n    htmlToTest = Htmls.FailSetNewPassword.get().replace(\"errorDescriptionValue\", \"Reset code is invalid\").replace(\"LOGO_WAC\", globalValues.getUrlWacLogoPngSmall()).replace(\"URL_FORGOT_PASS\", globalValues.getUrlForgotPassword()).replace(\"EMAIL_WAC\", globalValues.getMailToWac());\n    webTestClient.post().uri(uriBuilder -> uriBuilder.path(pathVariable).queryParam(\"codeToSet\", resetDto.getCode()).build()).contentType(MediaType.APPLICATION_JSON).bodyValue(body.replace(\"teste!2PASWORD\", \"invalidPass\")).exchange().expectStatus().isOk().expectBody(String.class).value(html -> assertEquals(htmlToTest, html));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testSetNewPassOk",
    "body": "{\n    userDTO.setPassword(Util.encryptPassword(resetDto.getCode()));\n    htmlToTest = Htmls.SuccessSetNewPassword.get().replace(\"LOGO_WAC\", globalValues.getUrlWacLogoPngSmall()).replace(\"USER_NAME\", userDTO.getFirstName());\n    Mockito.when(userDao.save(Mockito.any(UserDto.class))).thenAnswer(invocation -> Mono.just(invocation.getArgument(0)));\n    ArgumentCaptor<UserDto> userDtoCaptor = ArgumentCaptor.forClass(UserDto.class);\n    Mockito.when(resetDao.deleteById(Mockito.anyString())).thenReturn(Mono.empty());\n    webTestClient.post().uri(uriBuilder -> uriBuilder.path(pathVariable).queryParam(\"codeToSet\", resetDto.getCode()).build()).contentType(MediaType.APPLICATION_JSON).bodyValue(body).exchange().expectStatus().isOk().expectBody(String.class).value(html -> assertEquals(htmlToTest, html));\n    Mockito.verify(userDao, Mockito.times(1)).save(userDtoCaptor.capture());\n    UserDto userDtoCaptured = userDtoCaptor.getValue();\n    Mockito.verify(resetDao, Mockito.times(1)).deleteById(Mockito.anyString());\n    assertTrue(Util.encryptMatches(newPassword, userDtoCaptured.getPassword()));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    pathVariable = usersEndpoint + usersResetPasswordEndpoint;\n    userDTO = userDtoBasicOk();\n    resetDto = ResetDto.to(userDTO);\n    Mockito.when(resetDao.findByCode(Mockito.anyString())).thenReturn(Mono.just(resetDto));\n    Mockito.when(userDao.findBy_id(Mockito.anyString())).thenReturn(Mono.just(userDTO));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testResetPassCodeNotFound",
    "body": "{\n    Mockito.when(resetDao.findByCode(Mockito.anyString())).thenReturn(Mono.empty());\n    htmlToTest = Htmls.FailReset.get().replace(\"errorDescriptionValue\", \"Code Not Found\").replace(\"LOGO_WAC\", globalValues.getUrlWacLogoPngSmall()).replace(\"EMAIL_WAC\", globalValues.getMailToWac());\n    webTestClient.get().uri(uriBuilder -> uriBuilder.path(pathVariable).queryParam(\"resetCode\", \"invalidCode\").build()).exchange().expectStatus().isBadRequest().expectBody(String.class).value(html -> assertEquals(htmlToTest, html));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testResetPassCodeInvalidAccountStatus",
    "body": "{\n    userDTO.setAccountStatus(AccountStatus.OFF);\n    String errorMsg = \"Account Status Incorrect for this request: \" + userDTO.getAccountStatus().getDetails();\n    htmlToTest = Htmls.FailReset.get().replace(\"errorDescriptionValue\", errorMsg).replace(\"LOGO_WAC\", globalValues.getUrlWacLogoPngSmall()).replace(\"EMAIL_WAC\", globalValues.getMailToWac());\n    webTestClient.get().uri(uriBuilder -> uriBuilder.path(pathVariable).queryParam(\"resetCode\", resetDto.getCode()).build()).exchange().expectStatus().isBadRequest().expectBody(String.class).value(html -> assertEquals(htmlToTest, html));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testResetPassCodeExpired",
    "body": "{\n    resetDto.setExpiration(resetDto.getExpiration().minusDays(1));\n    webTestClient.get().uri(uriBuilder -> uriBuilder.path(pathVariable).queryParam(\"resetCode\", resetDto.getCode()).build()).exchange().expectStatus().isBadRequest().expectBody().jsonPath(\"$.success\").isEqualTo(false).jsonPath(\"$.message\").isEqualTo(\"This Code is Expired\");\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testResetPassCodeOK",
    "body": "{\n    Mockito.when(resetDao.save(Mockito.any(ResetDto.class))).thenAnswer(invocation -> Mono.just(invocation.getArgument(0)));\n    Mockito.when(userDao.save(Mockito.any(UserDto.class))).thenAnswer(invocation -> Mono.just(invocation.getArgument(0)));\n    ArgumentCaptor<ResetDto> resetDtoCaptor = ArgumentCaptor.forClass(ResetDto.class);\n    AtomicReference<String> htmlResponse = new AtomicReference<>();\n    webTestClient.get().uri(uriBuilder -> uriBuilder.path(pathVariable).queryParam(\"resetCode\", resetDto.getCode()).build()).exchange().expectStatus().isOk().expectBody(String.class).value(htmlResponse::set);\n    Mockito.verify(resetDao, Mockito.times(1)).save(resetDtoCaptor.capture());\n    ResetDto resetDtoCaptured = resetDtoCaptor.getValue();\n    String endPoint = globalValues.getUrlSetNewPassword() + resetDtoCaptured.getCode();\n    htmlToTest = Htmls.FormToSendNewPassword.get().replace(\"LOGO_WAC\", globalValues.getUrlWacLogoPngSmall()).replace(\"RESET_CODE\", resetDtoCaptured.getCode()).replace(\"ENDPOINT_RESET_PASS\", endPoint);\n    assertEquals(htmlToTest, htmlResponse.get());\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    argumentCaptor = ArgumentCaptor.forClass(UserDto.class);\n    Mockito.when(userDao.findByEmail(EMAIL)).thenReturn(Mono.just(userDTO));\n    Mockito.when(userDao.findBy_id(ID)).thenReturn(Mono.just(userDTO));\n    Mockito.when(userDao.save(Mockito.any(UserDto.class))).thenAnswer(invocation -> Mono.just(invocation.getArguments()[0]));\n    Mockito.when(userDao.delete(Mockito.any(UserDto.class))).thenReturn(Mono.empty());\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testDeleteOkStatus",
    "body": "{\n    final String message = \"REQUEST_DELETE set, you have one year to revoke the deletion\";\n    baseTestDeleteOkAndRequestDeleteStatus(message, REQUEST_DELETE);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testDeleteRequestStatus",
    "body": "{\n    final String message = \"MARKED_DELETE set, your account has been invalidated you have one year to request your data\";\n    userDTO.setRequestDeleteDate(userDTO.getRequestDeleteDate().minusYears(1));\n    baseTestDeleteOkAndRequestDeleteStatus(message, MARKED_DELETE);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "baseTestDeleteOkAndRequestDeleteStatus",
    "body": "{\n    webTestClient.delete().uri(uriBuilder -> uriBuilder.path(deleteOneEndpoint).queryParam(\"id\", ID).build()).header(\"Authorization\", tokenUserOk()).exchange().expectStatus().isOk().expectBody().jsonPath(\"$.success\").isEqualTo(true).jsonPath(\"$.message\").isEqualTo(message).jsonPath(\"$.content.registration\").isNotEmpty().jsonPath(\"$.content.requestDeleteDate\").isNotEmpty().jsonPath(\"$.content._id\").isEqualTo(ID).jsonPath(\"$.content.email\").isEqualTo(EMAIL).jsonPath(\"$.content.firstName\").isEqualTo(FIRST_NAME).jsonPath(\"$.content.surNames\").isEqualTo(SUR_NAMES).jsonPath(\"$.content.birthdate\").isEqualTo(BIRTHDATE_STR).jsonPath(\"$.content.roleType\").isEqualTo(Role.BASIC.get()).jsonPath(\"$.content.accountStatus\").isEqualTo(status.toString()).jsonPath(\"$.content.accountStatusMsg\").isEqualTo(status.getDetails());\n    Mockito.verify(userDao).save(argumentCaptor.capture());\n    userDTO = argumentCaptor.getValue();\n}",
    "parameters": "[String message, AccountStatus status]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testDeleteMarkedStatus",
    "body": "{\n    final String message = \"Your account is set to be deleted, but you still have time to request your data\";\n    userDTO.setRequestDeleteDate(userDTO.getRequestDeleteDate().minusYears(1).plusDays(1));\n    baseTestDeleteMarkedDeleteAndDeleteStatus(message);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testDeleteDeleteStatus",
    "body": "{\n    final String message = \"Your account has been terminated\";\n    userDTO.setRequestDeleteDate(userDTO.getRequestDeleteDate().minusDays(1));\n    baseTestDeleteMarkedDeleteAndDeleteStatus(message);\n    Mockito.verify(userDao).delete(argumentCaptor.capture());\n    userDTO = argumentCaptor.getValue();\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "baseTestDeleteMarkedDeleteAndDeleteStatus",
    "body": "{\n    webTestClient.delete().uri(uriBuilder -> uriBuilder.path(deleteOneEndpoint).queryParam(\"id\", ID).build()).header(\"Authorization\", tokenUserOk()).exchange().expectStatus().isUnauthorized().expectBody().jsonPath(\"$.success\").isEqualTo(false).jsonPath(\"$.message\").isEqualTo(message);\n}",
    "parameters": "[String message]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    pathVariable = usersEndpoint + usersResendActivationEndpoint;\n    userDTO = userDtoBasicPending();\n    activationDto = ActivationDto.to(userDTO);\n    mimeMessageCaptor = ArgumentCaptor.forClass(MimeMessage.class);\n    activationCaptor = ArgumentCaptor.forClass(ActivationDto.class);\n    Mockito.when(userDao.findByEmail(userDTO.getEmail())).thenReturn(Mono.just(userDTO));\n    Mockito.when(userDao.findBy_id(userDTO.get_id())).thenReturn(Mono.just(userDTO));\n    Mockito.when(emailSender.createMimeMessage()).thenReturn(new MimeMessage((Session) null));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testResendActivationEmailNotFound",
    "body": "{\n    Mockito.when(userDao.findByEmail(Mockito.anyString())).thenReturn(Mono.empty());\n    webTestClient.get().uri(uriBuilder -> uriBuilder.path(pathVariable).queryParam(\"emailToResend\", \"invalidMail\").build()).exchange().expectStatus().isOk().expectBody().jsonPath(\"$.success\").isEqualTo(false).jsonPath(\"$.message\").isEqualTo(\"Email not found.\");\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testResendActivationOkWithCodeNotExpired",
    "body": "{\n    Mockito.when(activationDao.findById(userDTO.get_id())).thenReturn(Mono.just(activationDto));\n    webTestClientForTestResendActivationOk();\n    mokitoVerifyEmailSenderAndCompareActivationCodeAndmimeMsg(activationDto);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testResendActivationOkWithCodeExpired",
    "body": "{\n    activationDto.setExpiration(activationDto.getExpiration().minusDays(2));\n    Mockito.when(activationDao.findById(userDTO.get_id())).thenReturn(Mono.just(activationDto));\n    Mockito.when(activationDao.save(Mockito.any(ActivationDto.class))).thenAnswer(invocation -> Mono.just(invocation.getArgument(0)));\n    webTestClientForTestResendActivationOk();\n    ActivationDto capturedActivation = mokitoVerifyActvationDaoSaveAndAssertActivationCode(activationDto.getCode());\n    mokitoVerifyEmailSenderAndCompareActivationCodeAndmimeMsg(capturedActivation);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "webTestClientForTestResendActivationOk",
    "body": "{\n    webTestClient.get().uri(uriBuilder -> uriBuilder.path(pathVariable).queryParam(\"emailToResend\", userDTO.getEmail()).build()).exchange().expectStatus().isOk().expectBody().jsonPath(\"$.success\").isEqualTo(true).jsonPath(\"$.message\").isEqualTo(\"Activation mail successfully resented\").jsonPath(\"$.content.email\").isEqualTo(EMAIL).jsonPath(\"$.content.surNames\").isEqualTo(SUR_NAMES).jsonPath(\"$.content.birthdate\").isEqualTo(BIRTHDATE_STR).jsonPath(\"$.content.roleType\").isEqualTo(Role.BASIC.get()).jsonPath(\"$.content.accountStatus\").isEqualTo(userDTO.getAccountStatus().toString()).jsonPath(\"$.content.accountStatusMsg\").isEqualTo(userDTO.getAccountStatus().getDetails());\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "requestBodyOnlyMail",
    "body": "{\n    return \"{ \\\"email\\\": \\\"\" + email + \"\\\" }\";\n}",
    "parameters": "[String email]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "requestBodyFullWithoutID",
    "body": "{\n    return \"{\\n\" + \"    \\\"email\\\": \\\"\" + email + \"\\\",\\n\" + \"    \\\"password\\\": \\\"\" + password + \"\\\",\\n\" + \"    \\\"firstName\\\": \\\"\" + firstName + \"\\\",\\n\" + \"    \\\"surNames\\\": \\\"\" + surNames + \"\\\",\\n\" + \"    \\\"birthdate\\\": \\\"\" + birthdate + \"\\\"\\n\" + \"}\";\n}",
    "parameters": "[String email, String password, String firstName, String surNames, String birthdate]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "requestBodyFullWhitID",
    "body": "{\n    return \"{\\n\" + \"    \\\"_id\\\": \\\"\" + _id + \"\\\",\\n\" + \"    \\\"email\\\": \\\"\" + email + \"\\\",\\n\" + \"    \\\"password\\\": \\\"\" + password + \"\\\",\\n\" + \"    \\\"firstName\\\": \\\"\" + firstName + \"\\\",\\n\" + \"    \\\"surNames\\\": \\\"\" + surNames + \"\\\",\\n\" + \"    \\\"birthdate\\\": \\\"\" + birthdate + \"\\\"\\n\" + \"}\";\n}",
    "parameters": "[String _id, String email, String password, String firstName, String surNames, String birthdate]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "requestBodyFullWhitIdAndNewPassword",
    "body": "{\n    return \"{\\n\" + \"    \\\"_id\\\": \\\"\" + BaseTestClass.ID + \"\\\",\\n\" + \"    \\\"email\\\": \\\"\" + BaseTestClass.empty + \"\\\",\\n\" + \"    \\\"password\\\": \\\"\" + BaseTestClass.PASSWORD + \"\\\",\\n\" + \"    \\\"newPassword\\\": \\\"\" + newPassword + \"\\\",\\n\" + \"    \\\"firstName\\\": \\\"\" + BaseTestClass.empty + \"\\\",\\n\" + \"    \\\"surNames\\\": \\\"\" + BaseTestClass.empty + \"\\\",\\n\" + \"    \\\"birthdate\\\": \\\"\" + BaseTestClass.empty + \"\\\"\\n\" + \"}\";\n}",
    "parameters": "[String newPassword]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "requestBodyFullyFill",
    "body": "{\n    return requestBodyFullWithoutID(EMAIL, PASSWORD, FIRST_NAME, SUR_NAMES, BIRTHDATE_STR);\n}",
    "parameters": "[]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "userDtoBasicPending",
    "body": "{\n    UserDto userDTO = new UserDto();\n    userDTO.set_id(ID);\n    userDTO.setRegistration(LOCAL_DATE_TIME);\n    userDTO.setEmail(EMAIL);\n    userDTO.setPassword(PASSWORD_ENCRYPT);\n    userDTO.setFirstName(FIRST_NAME);\n    userDTO.setSurNames(SUR_NAMES);\n    userDTO.setBirthdate(BIRTHDATE);\n    userDTO.setRoleType(Role.BASIC);\n    userDTO.setAccountStatus(AccountStatus.PENDING);\n    return userDTO;\n}",
    "parameters": "[]",
    "returnType": "UserDto"
  },
  {
    "javadoc": "",
    "name": "userDtoBasicAccountStatus",
    "body": "{\n    UserDto userDTO = userDtoBasicPending();\n    userDTO.setAccountStatus(status);\n    userDTO.setRequestDeleteDate(LocalDateTime.now().minusYears(3));\n    return userDTO;\n}",
    "parameters": "[AccountStatus status]",
    "returnType": "UserDto"
  },
  {
    "javadoc": "",
    "name": "userDtoBasicOk",
    "body": "{\n    UserDto userDTO = userDtoBasicPending();\n    userDTO.setAccountStatus(AccountStatus.OK);\n    return userDTO;\n}",
    "parameters": "[]",
    "returnType": "UserDto"
  },
  {
    "javadoc": "",
    "name": "userDtoAdminOk",
    "body": "{\n    UserDto userDTO = userDtoBasicOk();\n    userDTO.setRoleType(Role.FULL);\n    userDTO.setEmail(email);\n    return userDTO;\n}",
    "parameters": "[String email]",
    "returnType": "UserDto"
  },
  {
    "javadoc": "",
    "name": "userDtoOtherOk",
    "body": "{\n    UserDto userDTO = userDtoBasicOk();\n    userDTO.setEmail(email);\n    return userDTO;\n}",
    "parameters": "[String email]",
    "returnType": "UserDto"
  },
  {
    "javadoc": "",
    "name": "tokenUserOk",
    "body": "{\n    return jwtUtil.getPrefix() + jwtUtil.doGenerateToken(tokenRole(Role.BASIC), EMAIL);\n}",
    "parameters": "[]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "tokenUserOk",
    "body": "{\n    return jwtUtil.getPrefix() + jwtUtil.doGenerateToken(tokenRole(Role.BASIC), username);\n}",
    "parameters": "[String username]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "tokenAdminOk",
    "body": "{\n    return jwtUtil.getPrefix() + jwtUtil.doGenerateToken(tokenRole(Role.CHIEF), email);\n}",
    "parameters": "[String email]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "tokenOtherUserOk",
    "body": "{\n    return jwtUtil.getPrefix() + jwtUtil.doGenerateToken(tokenRole(Role.BASIC), email);\n}",
    "parameters": "[String email]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "tokenExpired",
    "body": "{\n    return jwtUtil.getPrefix() + jwtUtil.generateExpiredTokenForTest(tokenRole(Role.BASIC), BaseTestClass.EMAIL);\n}",
    "parameters": "[]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "tokenRole",
    "body": "{\n    HashMap<String, Object> claims = new HashMap<>();\n    claims.put(\"roles\", List.of(\"ROLE_\" + role.get()));\n    return claims;\n}",
    "parameters": "[Role role]",
    "returnType": "HashMap<String,Object>"
  },
  {
    "javadoc": "",
    "name": "testFailRequest_400",
    "body": "{\n    webTestClient.post().uri(uri).contentType(MediaType.APPLICATION_JSON).bodyValue(requestBody).exchange().expectStatus().isBadRequest().expectBody().jsonPath(\"$.success\").isEqualTo(success).jsonPath(\"$.message\").value(text -> Assertions.assertThat(text).asString().contains(message)).jsonPath(\"$.content\").value(content -> assertThat(content).asInstanceOf(MAP).containsKeys(key));\n}",
    "parameters": "[String uri, String requestBody, boolean success, String message, String key]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testPost401EndpointWithTokenSuccessFalseMessageContains",
    "body": "{\n    webTestClient.post().uri(endpoint).header(\"Authorization\", token).contentType(MediaType.APPLICATION_JSON).bodyValue(requestBody).exchange().expectStatus().isUnauthorized().expectBody().jsonPath(\"$.success\").isEqualTo(false).jsonPath(\"$.message\").value(text -> Assertions.assertThat(text).asString().contains(message));\n}",
    "parameters": "[String endpoint, String token, String requestBody, String message]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testPutEndpointWithTokenSuccessFalseMessageContains",
    "body": "{\n    webTestClient.put().uri(endpoint).header(\"Authorization\", token).contentType(MediaType.APPLICATION_JSON).bodyValue(requestBody).exchange().expectStatus().isEqualTo(http).expectBody().jsonPath(\"$.success\").isEqualTo(false).jsonPath(\"$.message\").value(text -> Assertions.assertThat(text).asString().contains(message));\n}",
    "parameters": "[String endpoint, String token, String requestBody, int http, String message]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "mokitoVerifyActvationDaoSaveAndAssertActivationCode",
    "body": "{\n    Mockito.verify(activationDao).save(activationCaptor.capture());\n    ActivationDto capturedActivation = activationCaptor.getValue();\n    assertAll(() -> assertNotNull(capturedActivation.getCode()), () -> assertNotEquals(capturedActivation.getCode(), oldActivationCode), () -> assertTrue(ChronoUnit.HOURS.between(capturedActivation.getExpiration(), LocalDateTime.now()) <= 24), () -> assertEquals(capturedActivation.getId(), ID));\n    return capturedActivation;\n}",
    "parameters": "[String oldActivationCode]",
    "returnType": "ActivationDto"
  },
  {
    "javadoc": "",
    "name": "mokitoVerifyEmailSenderAndCompareActivationCodeAndmimeMsg",
    "body": "{\n    Mockito.verify(emailSender, Mockito.times(1)).send(mimeMessageCaptor.capture());\n    MimeMessage mimeMessage = mimeMessageCaptor.getValue();\n    String bodyMail = decodeMimeMsgFromQuotedPrintable(mimeMessage);\n    assertAll(() -> assertEquals(EMAIL, mimeMessage.getRecipients(Message.RecipientType.TO)[0].toString()), () -> assertEquals(\"WhataCook : Activación de cuenta\", mimeMessage.getSubject()), () -> assertEquals(springMailConfig.getSpringMailUser(), mimeMessage.getFrom()[0].toString()), () -> assertInstanceOf(MimeMultipart.class, mimeMessage.getContent()), () -> assertNotNull(bodyMail, \"No se encontró contenido HTML en el mensaje.\"), () -> assertTrue(bodyMail.contains(globalValues.getUrlWacLogoPngSmall()), \"El mensaje no contiene el logo esperado.\"), () -> assertTrue(bodyMail.contains(\", \" + FIRST_NAME + \"!\"), \"El mensaje no contiene el saludo esperado.\"), () -> assertTrue(bodyMail.contains(globalValues.getUrlActivationAccount() + activationDto.getCode()), \"El mensaje no contiene el CODIGO esperado.\"));\n}",
    "parameters": "[ActivationDto activationDto]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "decodeMimeMsgFromQuotedPrintable",
    "body": "{\n    ByteArrayOutputStream output = new ByteArrayOutputStream();\n    StringWriter writer = new StringWriter();\n    try {\n        mimeMessage.writeTo(output);\n        // Decodificar el contenido Quoted-Printable\n        String encodedContent = output.toString(StandardCharsets.UTF_8);\n        ByteArrayInputStream encodedStream = new ByteArrayInputStream(encodedContent.getBytes(StandardCharsets.UTF_8));\n        InputStream decodedStream = MimeUtility.decode(encodedStream, \"quoted-printable\");\n        // Convertir el contenido decodificado a una cadena\n        IOUtils.copy(decodedStream, writer, StandardCharsets.UTF_8);\n    } catch (IOException | MessagingException e) {\n        log.warn(e.getMessage());\n    }\n    return writer.toString();\n}",
    "parameters": "[MimeMessage mimeMessage]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    pathVariable = usersEndpoint + usersActivateEndpoint;\n    userCaptor = ArgumentCaptor.forClass(UserDto.class);\n    activationDto = ActivationDto.to(userDtoBasicPending());\n    Mockito.when(activationDao.findByCode(Mockito.eq(activationDto.getCode()))).thenReturn(Mono.just(activationDto));\n    Mockito.when(userDao.findBy_id(ID)).thenReturn(Mono.just(userDtoBasicPending()));\n    Mockito.when(userDao.save(Mockito.any(UserDto.class))).thenAnswer(invocation -> Mono.just(invocation.getArgument(0)));\n    Mockito.when(activationDao.deleteById(ID)).thenReturn(Mono.empty());\n    failHtmlToTest = Htmls.FailActivation.get().replace(\"LOGO_WAC\", globalValues.getUrlWacLogoPngSmall()).replace(\"PATH_TO_RESEND\", globalValues.getPathToResendActvationMail()).replace(\"EMAIL_WAC\", globalValues.getMailToWac());\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testActivationIsSuccess",
    "body": "{\n    String htmlToTest = Htmls.SuccessActivation.get().replace(\"LOGO_WAC\", globalValues.getUrlWacLogoPngSmall()).replace(\"USER_NAME\", FIRST_NAME);\n    webTestClient.get().uri(uriBuilder -> uriBuilder.path(pathVariable).queryParam(\"activationCode\", activationDto.getCode()).build()).exchange().expectStatus().isOk().expectBody(String.class).value(html -> assertEquals(htmlToTest, html));\n    // 1. Verificar que se llamó al método deleteById con el ID correcto\n    Mockito.verify(activationDao, Mockito.times(1)).deleteById(activationDto.getId());\n    // 2. Verificar que se llamó al método save del userDao\n    Mockito.verify(userDao, Mockito.times(1)).save(userCaptor.capture());\n    // 3. Verificar que el UserDTO guardado tenía el AccountStatus.OK\n    UserDto savedUser = userCaptor.getValue();\n    assertEquals(AccountStatus.OK, savedUser.getAccountStatus());\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testActivationCodeExpired",
    "body": "{\n    activationDto.setExpiration(LocalDateTime.now().minusDays(2));\n    webTestClient.get().uri(uriBuilder -> uriBuilder.path(pathVariable).queryParam(\"activationCode\", activationDto.getCode()).build()).exchange().expectStatus().isOk().expectBody(String.class).value(html -> assertEquals(failHtmlToTest, html));\n    // Verificación adicional para asegurarse de que no se intenta borrar ni actualizar nada\n    Mockito.verify(activationDao, Mockito.never()).deleteById(Mockito.anyString());\n    Mockito.verify(userDao, Mockito.never()).save(Mockito.any(UserDto.class));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testInvalidActivationCode",
    "body": "{\n    // Configuración para que findByCode devuelva un Mono vacío, simulando un código no encontrado\n    Mockito.when(activationDao.findByCode(\"invalidCode\")).thenReturn(Mono.empty());\n    // Ejecución del test endpoint con un código de activación no válido\n    webTestClient.get().uri(uriBuilder -> uriBuilder.path(pathVariable).queryParam(\"activationCode\", \"invalidCode\").build()).exchange().expectStatus().isBadRequest().expectBody(String.class).value(html -> assertEquals(failHtmlToTest, html));\n    // Verificación adicional para asegurarse de que no se intenta borrar ni actualizar nada\n    Mockito.verify(activationDao, Mockito.never()).deleteById(Mockito.anyString());\n    Mockito.verify(userDao, Mockito.never()).save(Mockito.any(UserDto.class));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    pathVariable = authEndpoint + usersRegisterEndpoint;\n    activationCaptor = ArgumentCaptor.forClass(ActivationDto.class);\n    mimeMessageCaptor = ArgumentCaptor.forClass(MimeMessage.class);\n    Mockito.when(userDao.existsByEmail(Mockito.anyString())).thenReturn(Mono.just(false));\n    Mockito.when(userDao.save(Mockito.any(UserDto.class))).thenReturn(Mono.just(userDtoBasicPending()));\n    Mockito.when(activationDao.save(Mockito.any(ActivationDto.class))).thenAnswer(invocation -> Mono.just(invocation.getArgument(0)));\n    Mockito.when(emailSender.createMimeMessage()).thenReturn(new MimeMessage((Session) null));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testRegisterIsCreated",
    "body": "{\n    webTestClient.post().uri(pathVariable).contentType(MediaType.APPLICATION_JSON).bodyValue(requestBodyFullyFill()).exchange().expectStatus().isCreated().expectBody().jsonPath(\"$.success\").isEqualTo(true).jsonPath(\"$.message\").isEqualTo(\"User successfully created\").jsonPath(\"$.content.registration\").isNotEmpty().jsonPath(\"$.content.email\").isEqualTo(EMAIL).jsonPath(\"$.content.firstName\").isEqualTo(FIRST_NAME).jsonPath(\"$.content.surNames\").isEqualTo(SUR_NAMES).jsonPath(\"$.content.birthdate\").isEqualTo(BIRTHDATE_STR).jsonPath(\"$.content.roleType\").isEqualTo(Role.BASIC.get()).jsonPath(\"$.content.accountStatus\").isEqualTo(AccountStatus.PENDING.toString()).jsonPath(\"$.content.accountStatusMsg\").isEqualTo(AccountStatus.PENDING.getDetails());\n    ActivationDto capturedActivation = mokitoVerifyActvationDaoSaveAndAssertActivationCode(\"\");\n    mokitoVerifyEmailSenderAndCompareActivationCodeAndmimeMsg(capturedActivation);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testRegisterIsBadRequest",
    "body": "{\n    testFailRequest_400(pathVariable, requestBody, success, message, key);\n}",
    "parameters": "[String requestBody, boolean success, String message, String key]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "provideVariablesForFailRequests",
    "body": "{\n    final String bodyWithoutEmail = requestBodyFullWithoutID(empty, PASSWORD, FIRST_NAME, SUR_NAMES, BIRTHDATE_STR);\n    final String bodyWithoutPass = requestBodyFullWithoutID(EMAIL, empty, FIRST_NAME, SUR_NAMES, BIRTHDATE_STR);\n    final String bodyWithoutFname = requestBodyFullWithoutID(EMAIL, PASSWORD, empty, SUR_NAMES, BIRTHDATE_STR);\n    final String bodyWithoutSname = requestBodyFullWithoutID(EMAIL, PASSWORD, FIRST_NAME, empty, BIRTHDATE_STR);\n    final String bodyWithoutBdate = requestBodyFullWithoutID(EMAIL, PASSWORD, FIRST_NAME, SUR_NAMES, empty);\n    final String bodyWithEmailBlanc = requestBodyFullWithoutID(blank, PASSWORD, FIRST_NAME, SUR_NAMES, BIRTHDATE_STR);\n    final String bodyWithPassBlanc = requestBodyFullWithoutID(EMAIL, blank, FIRST_NAME, SUR_NAMES, BIRTHDATE_STR);\n    final String bodyWithFnameBlanc = requestBodyFullWithoutID(EMAIL, PASSWORD, blank, SUR_NAMES, BIRTHDATE_STR);\n    final String bodyWithSnameBlanc = requestBodyFullWithoutID(EMAIL, PASSWORD, FIRST_NAME, blank, BIRTHDATE_STR);\n    final String bodyWithBdateBlanc = requestBodyFullWithoutID(EMAIL, PASSWORD, FIRST_NAME, SUR_NAMES, blank);\n    final String reqBodyPassWithoutLowercaseLetter = registerReqBoRdyNewPass(\"1234!ABC\");\n    final String reqBodyPassWithoutUppercaseLetter = registerReqBoRdyNewPass(\"1234!abc\");\n    final String reqBodyPassWithoutDigit = registerReqBoRdyNewPass(\"Abcd!efg\");\n    final String reqBodyPassWithoutSpecialChar = registerReqBoRdyNewPass(\"Abcd1Efg\");\n    final String reqBodyPassShorterThan8Char = registerReqBoRdyNewPass(\"A1b!ef\");\n    final String messageError = \"Invalid or incorrect format\";\n    return Stream.of(Arguments.of(bodyWithoutEmail, false, messageError, \"email\"), Arguments.of(bodyWithoutPass, false, messageError, \"password\"), Arguments.of(bodyWithoutFname, false, messageError, \"firstName\"), Arguments.of(bodyWithoutSname, false, messageError, \"surNames\"), Arguments.of(bodyWithoutBdate, false, messageError, \"birthdate\"), Arguments.of(bodyWithEmailBlanc, false, messageError, \"email\"), Arguments.of(bodyWithPassBlanc, false, messageError, \"password\"), Arguments.of(bodyWithFnameBlanc, false, messageError, \"firstName\"), Arguments.of(bodyWithSnameBlanc, false, messageError, \"surNames\"), Arguments.of(bodyWithBdateBlanc, false, messageError, \"birthdate\"), Arguments.of(reqBodyPassWithoutLowercaseLetter, false, messageError, \"password\"), Arguments.of(reqBodyPassWithoutUppercaseLetter, false, messageError, \"password\"), Arguments.of(reqBodyPassWithoutDigit, false, messageError, \"password\"), Arguments.of(reqBodyPassWithoutSpecialChar, false, messageError, \"password\"), Arguments.of(reqBodyPassShorterThan8Char, false, messageError, \"password\"), Arguments.of(empty, false, \"Invalid request body or not present\", \"ERROR\"));\n}",
    "parameters": "[]",
    "returnType": "Stream<Arguments>"
  },
  {
    "javadoc": "",
    "name": "registerReqBoRdyNewPass",
    "body": "{\n    return requestBodyFullWithoutID(EMAIL, newPassword, FIRST_NAME, SUR_NAMES, BIRTHDATE_STR);\n}",
    "parameters": "[String newPassword]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "setUp",
    "body": "{\n    Mockito.when(userDao.findByEmail(Mockito.anyString())).thenReturn(Mono.just(userDtoBasicOk()));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testForgotPasswordFailByIncorrectInformation",
    "body": "{\n    webTestClient.post().uri(forgotPasswordEndpoint).contentType(MediaType.APPLICATION_JSON).bodyValue(requestBody.replace(BIRTHDATE_STR, \"1985-07-19\")).exchange().expectStatus().isUnauthorized().expectBody().jsonPath(\"$.success\").isEqualTo(false).jsonPath(\"$.message\").isEqualTo(\"Incorrect information\");\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testForgotPasswordFailByUnregisteredEmail",
    "body": "{\n    Mockito.when(userDao.findByEmail(Mockito.anyString())).thenReturn(Mono.empty());\n    webTestClient.post().uri(forgotPasswordEndpoint).contentType(MediaType.APPLICATION_JSON).bodyValue(requestBody.replace(EMAIL, \"bad@email.com\")).exchange().expectStatus().isOk().expectBody().jsonPath(\"$.success\").isEqualTo(false).jsonPath(\"$.message\").isEqualTo(\"Unregistered email\");\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "testForgotPasswordOk",
    "body": "{\n    Mockito.when(resetDao.save(Mockito.any(ResetDto.class))).thenAnswer(invocation -> Mono.just(invocation.getArgument(0)));\n    Mockito.when(emailSender.createMimeMessage()).thenReturn(new MimeMessage((Session) null));\n    mimeMessageCaptor = ArgumentCaptor.forClass(MimeMessage.class);\n    resetCaptor = ArgumentCaptor.forClass(ResetDto.class);\n    webTestClient.post().uri(forgotPasswordEndpoint).contentType(MediaType.APPLICATION_JSON).bodyValue(requestBody).exchange().expectStatus().isOk().expectBody().jsonPath(\"$.success\").isEqualTo(true).jsonPath(\"$.message\").isEqualTo(\"Email sent with reset code\").jsonPath(\"$.content.registration\").value(registration -> Assertions.assertThat(registration).asString().contains(LOCAL_DATE_TIME.toString())).jsonPath(\"$.content.email\").isEqualTo(EMAIL).jsonPath(\"$.content.firstName\").isEqualTo(FIRST_NAME).jsonPath(\"$.content.surNames\").isEqualTo(SUR_NAMES).jsonPath(\"$.content.birthdate\").isEqualTo(BIRTHDATE_STR).jsonPath(\"$.content.roleType\").isEqualTo(Role.BASIC.get()).jsonPath(\"$.content.accountStatus\").isEqualTo(OK.toString()).jsonPath(\"$.content.accountStatusMsg\").isEqualTo(OK.getDetails());\n    Mockito.verify(resetDao).save(resetCaptor.capture());\n    ResetDto capturedReset = resetCaptor.getValue();\n    assertAll(() -> assertNotNull(capturedReset.getCode()), () -> assertTrue(ChronoUnit.HOURS.between(capturedReset.getExpiration(), LocalDateTime.now()) <= 24), () -> assertEquals(capturedReset.getId(), ID));\n    Mockito.verify(emailSender, Mockito.times(1)).send(mimeMessageCaptor.capture());\n    MimeMessage mimeMessage = mimeMessageCaptor.getValue();\n    String bodyMail = decodeMimeMsgFromQuotedPrintable(mimeMessage);\n    assertAll(() -> assertEquals(EMAIL, mimeMessage.getRecipients(Message.RecipientType.TO)[0].toString()), () -> assertEquals(\"WhataCook : reset contraseña\", mimeMessage.getSubject()), () -> assertEquals(springMailConfig.getSpringMailUser(), mimeMessage.getFrom()[0].toString()), () -> assertInstanceOf(MimeMultipart.class, mimeMessage.getContent()), () -> assertNotNull(bodyMail, \"No se encontró contenido HTML en el mensaje.\"), () -> assertTrue(bodyMail.contains(globalValues.getUrlWacLogoPngSmall()), \"El mensaje no contiene el logo esperado.\"), () -> assertTrue(bodyMail.contains(\", \" + FIRST_NAME + \"!\"), \"El mensaje no contiene el saludo esperado.\"), () -> assertTrue(bodyMail.contains(globalValues.getUrlResetPassword() + capturedReset.getCode()), \"El mensaje no contiene el CODIGO esperado.\"));\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "contextLoads",
    "body": "{\n    assertThat(context).isNotNull();\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "getSecretKey",
    "body": "{\n    return Keys.hmacShaKeyFor(this.secret.getBytes());\n}",
    "parameters": "[]",
    "returnType": "SecretKey"
  },
  {
    "javadoc": "",
    "name": "getUsernameFromToken",
    "body": "{\n    return getClaimFromToken(token, Claims::getSubject);\n}",
    "parameters": "[String token]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "getExpirationDateFromToken",
    "body": "{\n    return getClaimFromToken(token, Claims::getExpiration);\n}",
    "parameters": "[String token]",
    "returnType": "Date"
  },
  {
    "javadoc": "",
    "name": "getClaimFromToken",
    "body": "{\n    final Claims claims = getAllClaimsFromToken(token);\n    return claimsResolver.apply(claims);\n}",
    "parameters": "[String token, Function<Claims, T> claimsResolver]",
    "returnType": "T"
  },
  {
    "javadoc": "",
    "name": "getAllClaimsFromToken",
    "body": "{\n    return Jwts.parser().verifyWith(getSecretKey()).build().parseSignedClaims(token.replace(prefix, \"\")).getPayload();\n}",
    "parameters": "[String token]",
    "returnType": "Claims"
  },
  {
    "javadoc": "",
    "name": "isExpired",
    "body": "{\n    final Date expiration = getExpirationDateFromToken(token);\n    return expiration.before(new Date());\n}",
    "parameters": "[String token]",
    "returnType": "Boolean"
  },
  {
    "javadoc": "",
    "name": "generateToken",
    "body": "{\n    Map<String, Object> claims = new HashMap<>();\n    return doGenerateToken(claims, authRequestDto.getUsername());\n}",
    "parameters": "[AuthRequestDto authRequestDto]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "doGenerateToken",
    "body": "{\n    return Jwts.builder().claims(claims).subject(subject).audience().add(audience).and().issuer(issuer).issuedAt(new Date(System.currentTimeMillis())).expiration(new Date(System.currentTimeMillis() + expiration)).signWith(getSecretKey()).compact();\n}",
    "parameters": "[Map<String, Object> claims, String subject]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "generateExpiredTokenForTest",
    "body": "{\n    long nowMillis = System.currentTimeMillis();\n    Date now = new Date(nowMillis - expiration * 2);\n    Date expiredDate = new Date(nowMillis - expiration);\n    return Jwts.builder().claims(claims).subject(subject).audience().add(audience).and().issuer(issuer).issuedAt(now).expiration(expiredDate).signWith(getSecretKey()).compact();\n}",
    "parameters": "[Map<String, Object> claims, String subject]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "hasToken",
    "body": "{\n    return StringUtils.hasText(token);\n}",
    "parameters": "[String token]",
    "returnType": "boolean"
  },
  {
    "javadoc": "",
    "name": "extractPrefix",
    "body": "{\n    return token.substring(7);\n}",
    "parameters": "[String token]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "isValidToken",
    "body": "{\n    if (!token.startsWith(prefix))\n        throw new JwtException(\"This Token is not Bearer\");\n    else if (token.split(\"\\\\.\").length != 3)\n        throw new JwtException(\"This Token is not ours\");\n    else if (isExpired(token))\n        throw new JwtException(\"This Token has Expired\");\n    else\n        return true;\n}",
    "parameters": "[String token]",
    "returnType": "Boolean"
  },
  {
    "javadoc": "",
    "name": "executeIfAuthorized",
    "body": "{\n    return getAuthentication().flatMap(authentication -> isAuthorized(userJson, authentication).flatMap(isAuthorized -> isAuthorized ? action.apply(userJson, (UserDetails) authentication.getPrincipal()) : UserServiceException.mono(\"No tienes permiso para acceder a esta información.\")));\n}",
    "parameters": "[UserJson userJson, BiFunction<UserJson, UserDetails, Mono<Response>> action]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "",
    "name": "getAuthentication",
    "body": "{\n    return ReactiveSecurityContextHolder.getContext().map(SecurityContext::getAuthentication);\n}",
    "parameters": "[]",
    "returnType": "Mono<Authentication>"
  },
  {
    "javadoc": "",
    "name": "isAuthorized",
    "body": "{\n    return Mono.just(isAdmin(authentication) || isOwnUser(userJson, getUserDetails(authentication)));\n}",
    "parameters": "[UserJson userJson, Authentication authentication]",
    "returnType": "Mono<Boolean>"
  },
  {
    "javadoc": "",
    "name": "isAdmin",
    "body": "{\n    return authentication.getAuthorities().stream().anyMatch(grantedAuthority -> grantedAuthority.getAuthority().equals(\"ROLE_ADMIN\"));\n}",
    "parameters": "[Authentication authentication]",
    "returnType": "boolean"
  },
  {
    "javadoc": "",
    "name": "isOwnUser",
    "body": "{\n    String username = userDetails.getUsername();\n    return (userJson.get_id() == null) ? username.contains(userJson.getEmail()) : username.contains(userJson.get_id());\n}",
    "parameters": "[UserJson userJson, UserDetails userDetails]",
    "returnType": "boolean"
  },
  {
    "javadoc": "",
    "name": "getUserDetails",
    "body": "{\n    return (UserDetails) authentication.getPrincipal();\n}",
    "parameters": "[Authentication authentication]",
    "returnType": "UserDetails"
  },
  {
    "javadoc": "",
    "name": "isSelfOrAdmin",
    "body": "{\n    CustomUserDetails userDetails = (CustomUserDetails) authentication.getPrincipal();\n    return (userDetails.getId().equals(userId)) || (userDetails.getEmail().equals(email)) || authentication.getAuthorities().stream().anyMatch(grantedAuthority -> grantedAuthority.getAuthority().equals(\"ROLE_ADMIN\"));\n}",
    "parameters": "[Authentication authentication, String userId, String email]",
    "returnType": "boolean"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Configures the security filter chain.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ServerHttpSecurity instance.'}]}', name=Optional[httpSecurity]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The custom request filter.'}]}', name=Optional[anyRequestFilter]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The reactive authentication manager.'}]}', name=Optional[reactiveAuthenticationManager]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The configured SecurityWebFilterChain.'}]}', name=Optional.empty}]}",
    "name": "filterChain",
    "body": "{\n    return httpSecurity.csrf(ServerHttpSecurity.CsrfSpec::disable).httpBasic(ServerHttpSecurity.HttpBasicSpec::disable).formLogin(ServerHttpSecurity.FormLoginSpec::disable).authenticationManager(reactiveAuthenticationManager).securityContextRepository(NoOpServerSecurityContextRepository.getInstance()).authorizeExchange(authorizeExchangeSpec -> authorizeExchangeSpec.pathMatchers(globalValues.getPathToCheckIfEmailAlreadyExists()).permitAll().pathMatchers(globalValues.getPathToJavaDoc()).permitAll().pathMatchers(globalValues.getPathToDirectoryJavadoc()).permitAll().pathMatchers(jwtUtil.getLoginUrl()).permitAll().pathMatchers(jwtUtil.getSignInUrl()).permitAll().pathMatchers(jwtUtil.getForgotPass()).permitAll().anyExchange().authenticated()).addFilterAt(anyRequestFilter, SecurityWebFiltersOrder.AUTHENTICATION).build();\n}",
    "parameters": "[ServerHttpSecurity httpSecurity, AnyRequestFilter anyRequestFilter, ReactiveAuthenticationManager reactiveAuthenticationManager]",
    "returnType": "SecurityWebFilterChain"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Provides a PasswordEncoder bean for encoding passwords.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The BCryptPasswordEncoder instance.'}]}', name=Optional.empty}]}",
    "name": "passwordEncoder",
    "body": "{\n    return new BCryptPasswordEncoder();\n}",
    "parameters": "[]",
    "returnType": "PasswordEncoder"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Configures the ReactiveAuthenticationManager.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ReactiveUserDetailsService instance.'}]}', name=Optional[userDetailsService]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The PasswordEncoder instance.'}]}', name=Optional[passwordEncoder]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The configured ReactiveAuthenticationManager.'}]}', name=Optional.empty}]}",
    "name": "reactiveAuthenticationManager",
    "body": "{\n    var authenticationManager = new UserDetailsRepositoryReactiveAuthenticationManager(userDetailsService);\n    authenticationManager.setPasswordEncoder(passwordEncoder);\n    return authenticationManager;\n}",
    "parameters": "[ReactiveUserDetailsService userDetailsService, PasswordEncoder passwordEncoder]",
    "returnType": "ReactiveAuthenticationManager"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Configures the resource handlers for the application.\n<p>\nThis method overrides the '}, JavadocInlineTag{tagName='code', type=CODE, content=' addResourceHandlers'}, JavadocSnippet{text=' method from the\n'}, JavadocInlineTag{tagName='code', type=CODE, content=' WebFluxConfigurer'}, JavadocSnippet{text=' interface to add a specific resource handler.\nThe resource handler configures the path to serve static files\nfrom the file system directory '}, JavadocInlineTag{tagName='code', type=CODE, content=' /app/javadoc'}, JavadocSnippet{text=' via the path\n'}, JavadocInlineTag{tagName='code', type=CODE, content=' /api/javadoc/**'}, JavadocSnippet{text='.\n</p>'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the resource handler registry to be used to add the handlers.'}]}', name=Optional[registry]}]}",
    "name": "addResourceHandlers",
    "body": "{\n    registry.addResourceHandler(\"/api/javadoc/**\").addResourceLocations(\"file:/app/javadoc/\");\n}",
    "parameters": "[ResourceHandlerRegistry registry]",
    "returnType": "void"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Initializes the MongoDB URI by reading Docker secrets.\nSets the system property for the MongoDB URI.'}]}, blockTags=[]}",
    "name": "init",
    "body": "{\n    try {\n        String URI = \"MONGO_URI_WHATACOOK_USERS\";\n        String mongoUri = DockerConfig.readSecret(URI);\n        if (StringUtils.hasText(mongoUri))\n            System.setProperty(URI, mongoUri.trim());\n        log.warn(\"Mongo URI : {}\", StringUtils.hasText(mongoUri));\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='PostConstruct method that initiates the analysis process.\nIt creates the output directory and file, then extracts method data from the Java source files.'}]}, blockTags=[]}",
    "name": "analyze",
    "body": "{\n    File projectDir = new File(OUTPUT_DIR);\n    if (!projectDir.exists() || !projectDir.isDirectory()) {\n        log.error(\"El directorio especificado no existe: {}\", OUTPUT_DIR);\n        return;\n    }\n    List<MethodInfo> extractedData = new ArrayList<>();\n    try {\n        // Crear el directorio de salida si no existe\n        Files.createDirectories(Paths.get(OUTPUT_DIR));\n        // Borrar el contenido existente del archivo\n        final Path pathTo_OUTPUT_FILE = Paths.get(OUTPUT_FILE);\n        Files.deleteIfExists(pathTo_OUTPUT_FILE);\n        extractData(projectDir, extractedData);\n        // Guardar los datos extraídos en un archivo JSON\n        List<Map<String, String>> jsonList = extractedData.stream().map(methodInfo -> {\n            Map<String, String> jsonObject = new HashMap<>();\n            jsonObject.put(\"name\", escapeJson(methodInfo.getName()));\n            jsonObject.put(\"returnType\", escapeJson(methodInfo.getReturnType()));\n            jsonObject.put(\"parameters\", escapeJson(methodInfo.getParameters()));\n            jsonObject.put(\"javadoc\", escapeJson(methodInfo.getJavadoc()));\n            jsonObject.put(\"body\", escapeJson(methodInfo.getBody()));\n            return jsonObject;\n        }).collect(Collectors.toList());\n        String jsonString = toJsonString(jsonList);\n        Files.write(pathTo_OUTPUT_FILE, jsonString.getBytes());\n    } catch (IOException e) {\n        log.error(\"Error while analyzing Java parser: {}\", e.getMessage(), e);\n    }\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Escapes special characters in a JSON string.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the input string'}]}', name=Optional[input]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the escaped string'}]}', name=Optional.empty}]}",
    "name": "escapeJson",
    "body": "{\n    if (input == null) {\n        return \"\";\n    }\n    return input.replace(\"\\\\\", \"\\\\\\\\\").replace(\"\\\"\", \"\\\\\\\"\").replace(\"\\n\", \"\\\\n\").replace(\"\\r\", \"\\\\r\").replace(\"\\t\", \"\\\\t\");\n}",
    "parameters": "[String input]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Converts a list of maps to a JSON string.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the list of maps'}]}', name=Optional[jsonList]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the JSON string'}]}', name=Optional.empty}]}",
    "name": "toJsonString",
    "body": "{\n    StringBuilder jsonString = new StringBuilder(\"[\\n\");\n    for (Map<String, String> jsonObject : jsonList) {\n        jsonString.append(\"  {\\n\");\n        for (Map.Entry<String, String> entry : jsonObject.entrySet()) {\n            jsonString.append(\"    \\\"\").append(entry.getKey()).append(\"\\\": \\\"\").append(entry.getValue()).append(\"\\\",\\n\");\n        }\n        // Remove last comma and newline, then add closing brace\n        jsonString.setLength(jsonString.length() - 2);\n        jsonString.append(\"\\n  },\\n\");\n    }\n    // Remove last comma and newline, then add closing bracket\n    if (!jsonList.isEmpty()) {\n        jsonString.setLength(jsonString.length() - 2);\n    }\n    jsonString.append(\"\\n]\");\n    return jsonString.toString();\n}",
    "parameters": "[List<Map<String, String>> jsonList]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Extracts method information from Java source files in the specified directory.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the project directory'}]}', name=Optional[projectDir]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the list to store extracted method information'}]}', name=Optional[extractedData]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if an I/O error occurs'}]}', name=Optional[IOException]}]}",
    "name": "extractData",
    "body": "{\n    JavaParser javaParser = new JavaParser();\n    try (Stream<java.nio.file.Path> paths = Files.walk(projectDir.toPath())) {\n        paths.filter(Files::isRegularFile).filter(path -> path.toString().endsWith(\".java\")).forEach(path -> {\n            try {\n                CompilationUnit cu = javaParser.parse(path).getResult().orElseThrow(IOException::new);\n                cu.accept(new MethodVisitor(), extractedData);\n            } catch (IOException e) {\n                log.error(\"Error while extractData() in JavaParserAnalyzer: {}\", e.getMessage(), e);\n            }\n        });\n    }\n}",
    "parameters": "[File projectDir, List<MethodInfo> extractedData]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "visit",
    "body": "{\n    super.visit(md, collector);\n    MethodInfo methodInfo = new MethodInfo();\n    methodInfo.setName(md.getNameAsString());\n    methodInfo.setReturnType(md.getTypeAsString());\n    methodInfo.setParameters(md.getParameters().toString());\n    methodInfo.setJavadoc(md.getJavadoc().map(Object::toString).orElse(\"\"));\n    methodInfo.setBody(md.getBody().map(Object::toString).orElse(\"\"));\n    collector.add(methodInfo);\n}",
    "parameters": "[MethodDeclaration md, List<MethodInfo> collector]",
    "returnType": "void"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Condition function to check if the environment is local.'}]}, blockTags=[]}",
    "name": "matches",
    "body": "{\n    String environment = System.getenv(\"WHATA_COOK_ENV\");\n    return \"local\".equals(environment);\n}",
    "parameters": "[ConditionContext context, AnnotatedTypeMetadata metadata]",
    "returnType": "boolean"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Reads the secret value from the specified path or environment variable.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The name of the secret.'}]}', name=Optional[secret]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The secret value as a string.'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='If an I/O error occurs.'}]}', name=Optional[IOException]}]}",
    "name": "readSecret",
    "body": "{\n    try {\n        return new String(Files.readAllBytes(Paths.get(rootPath + secret))).trim();\n    } catch (IOException e) {\n        return System.getenv(secret);\n    }\n}",
    "parameters": "[String secret]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "handle",
    "body": "",
    "parameters": "[String requestToken, ServerWebExchange exchange, WebFilterChain chain]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "",
    "name": "setAuthenticated",
    "body": "",
    "parameters": "[String userEmailOrId, String token, ServerWebExchange exchange, WebFilterChain chain]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "",
    "name": "handle",
    "body": "",
    "parameters": "[String emailToResend, ServerWebExchange exchange, WebFilterChain chain]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "",
    "name": "handle",
    "body": "",
    "parameters": "[String resetCode, ServerWebExchange exchange, WebFilterChain chain]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "",
    "name": "handle",
    "body": "",
    "parameters": "[String codeToSet, ServerWebExchange exchange, WebFilterChain chain]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "",
    "name": "handle",
    "body": "",
    "parameters": "[String activationCode, ServerWebExchange exchange, WebFilterChain chain]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "",
    "name": "handle",
    "body": "{\n    return Mono.just(Objects.requireNonNull(emailToResend)).filter(Util::isValidEmail).flatMap(DAO::findByEmail).flatMap(userDTO -> activationService.findById(userDTO.get_id())).flatMap(activationDto -> authenticationManager.setAuthenticated(activationDto.getId(), null, exchange, chain)).switchIfEmpty(Mono.defer(() -> respondWithJson(exchange, error(\"Email not found.\"))));\n}",
    "parameters": "[String emailToResend, ServerWebExchange exchange, WebFilterChain chain]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "",
    "name": "respondWithJson",
    "body": "{\n    if (!exchange.getResponse().isCommitted()) {\n        exchange.getResponse().setStatusCode(HttpStatus.OK);\n        exchange.getResponse().getHeaders().setContentType(MediaType.APPLICATION_JSON);\n        byte[] jsonBytes = convertToJsonAsBytes(response);\n        DataBuffer dataBuffer = exchange.getResponse().bufferFactory().wrap(jsonBytes);\n        return exchange.getResponse().writeWith(Mono.just(dataBuffer));\n    } else {\n        return Mono.empty();\n    }\n}",
    "parameters": "[ServerWebExchange exchange, Object response]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "",
    "name": "send",
    "body": "{\n    if (!exchange.getResponse().isCommitted()) {\n        exchange.getResponse().setStatusCode(HttpStatus.BAD_REQUEST);\n        exchange.getResponse().getHeaders().setContentType(MediaType.TEXT_HTML);\n        DataBuffer dataBuffer = exchange.getResponse().bufferFactory().wrap(htmlContent.getBytes(StandardCharsets.UTF_8));\n        return exchange.getResponse().writeWith(Mono.just(dataBuffer));\n    } else {\n        return Mono.empty();\n    }\n}",
    "parameters": "[ServerWebExchange exchange, String htmlContent]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "",
    "name": "setAuthenticated",
    "body": "{\n    return userService.findByUsername(userEmailOrId).map(user -> new UsernamePasswordAuthenticationToken(user, token, user.getAuthorities())).cast(Authentication.class).flatMap(authentication -> chain.filter(exchange).contextWrite(ReactiveSecurityContextHolder.withAuthentication(authentication))).then();\n}",
    "parameters": "[String userEmailOrId, String token, ServerWebExchange exchange, WebFilterChain chain]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "",
    "name": "handle",
    "body": "{\n    String FAIL_HTML_FOR_ACTIVATION = Htmls.FailActivation.get().replace(\"LOGO_WAC\", globalValues.getUrlWacLogoPngSmall()).replace(\"PATH_TO_RESEND\", globalValues.getPathToResendActvationMail()).replace(\"EMAIL_WAC\", globalValues.getMailToWac());\n    return activationService.findByCode(activationCode).flatMap(activationDto -> authenticationManager.setAuthenticated(activationDto.getId(), null, exchange, chain)).switchIfEmpty(Mono.defer(() -> responseErrorHtml.send(exchange, FAIL_HTML_FOR_ACTIVATION)));\n}",
    "parameters": "[String activationCode, ServerWebExchange exchange, WebFilterChain chain]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "",
    "name": "handle",
    "body": "{\n    String FAIL_HTML_FOR_RESET = Htmls.FailReset.get().replace(\"LOGO_WAC\", globalValues.getUrlWacLogoPngSmall()).replace(\"EMAIL_WAC\", globalValues.getMailToWac());\n    return resetService.findByCode(resetCode).flatMap(resetDto -> authenticationManager.setAuthenticated(resetDto.getId(), null, exchange, chain)).switchIfEmpty(Mono.defer(() -> responseErrorHtml.send(exchange, FAIL_HTML_FOR_RESET.replace(\"errorDescriptionValue\", \"Code Not Found\")))).onErrorResume(throwable -> Mono.defer(() -> responseErrorHtml.send(exchange, FAIL_HTML_FOR_RESET.replace(\"errorDescriptionValue\", throwable.getMessage()))));\n}",
    "parameters": "[String resetCode, ServerWebExchange exchange, WebFilterChain chain]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "",
    "name": "handle",
    "body": "{\n    String FAIL_HTML_FOR_RESET = Htmls.FailSetNewPassword.get().replace(\"LOGO_WAC\", globalValues.getUrlWacLogoPngSmall()).replace(\"URL_FORGOT_PASS\", globalValues.getUrlForgotPassword()).replace(\"EMAIL_WAC\", globalValues.getMailToWac());\n    return resetService.findByCode(codeToSet).flatMap(resetDto -> authenticationManager.setAuthenticated(resetDto.getId(), null, exchange, chain)).switchIfEmpty(Mono.defer(() -> responseErrorHtml.send(exchange, FAIL_HTML_FOR_RESET.replace(\"errorDescriptionValue\", \"Code Not Found\")))).onErrorResume(throwable -> Mono.defer(() -> responseErrorHtml.send(exchange, FAIL_HTML_FOR_RESET.replace(\"errorDescriptionValue\", throwable.getMessage()))));\n}",
    "parameters": "[String codeToSet, ServerWebExchange exchange, WebFilterChain chain]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "",
    "name": "handle",
    "body": "{\n    return Mono.justOrEmpty(requestToken).filter(token -> jwtUtil.hasToken(token) && jwtUtil.isValidToken(token)).flatMap(token -> {\n        String tokenWithoutPrefix = jwtUtil.extractPrefix(token);\n        String username = jwtUtil.getUsernameFromToken(tokenWithoutPrefix);\n        return authenticationManager.setAuthenticated(username, tokenWithoutPrefix, exchange, chain);\n    }).onErrorResume(// Handle error globally\n    e -> handleError(e, exchange));\n}",
    "parameters": "[String requestToken, ServerWebExchange exchange, WebFilterChain chain]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "",
    "name": "handleError",
    "body": "{\n    if (!exchange.getResponse().isCommitted()) {\n        String errorMessage;\n        if (e instanceof ExpiredJwtException)\n            errorMessage = \"Token expired. Please login again.\";\n        else if (e instanceof JwtException)\n            errorMessage = \"Invalid token.\";\n        else\n            errorMessage = e.getMessage();\n        return sendUnauthorizedResponse(exchange, errorMessage);\n    } else {\n        return Mono.empty();\n    }\n}",
    "parameters": "[Throwable e, ServerWebExchange exchange]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "",
    "name": "sendUnauthorizedResponse",
    "body": "{\n    HttpStatus status = HttpStatus.UNAUTHORIZED;\n    ServerHttpResponse response = exchange.getResponse();\n    response.setStatusCode(status);\n    response.getHeaders().setContentType(MediaType.APPLICATION_JSON);\n    Response errorResponse = error(errorMessage);\n    byte[] bytes = convertToJsonAsBytes(errorResponse);\n    DataBuffer buffer = response.bufferFactory().wrap(bytes);\n    return response.writeWith(Mono.just(buffer));\n}",
    "parameters": "[ServerWebExchange exchange, String errorMessage]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "",
    "name": "send",
    "body": "",
    "parameters": "[ServerWebExchange exchange, String htmlContent]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a request handler that processes requests based on the specified handler function and JWT key.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The function to handle the request.'}]}', name=Optional[handlerFunction]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The JWT key used to identify the request.'}]}', name=Optional[jwtKey]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A RequestHandler that processes the request.'}]}', name=Optional.empty}]}",
    "name": "createHandler",
    "body": "{\n    return (exchange, chain) -> {\n        String paramValue = getHeaderOrParamValue(exchange, jwtKey);\n        return handlerFunction.apply(paramValue, exchange, chain);\n    };\n}",
    "parameters": "[TriFunction<String, ServerWebExchange, WebFilterChain, Mono<Void>> handlerFunction, String jwtKey]",
    "returnType": "RequestHandler"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Filters the web exchange and delegates to the appropriate handler based on the presence of specific headers or query parameters.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The current server web exchange.'}]}', name=Optional[exchange]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The web filter chain.'}]}', name=Optional[chain]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Mono<Void> that indicates when request processing is complete.'}]}', name=Optional.empty}]}",
    "name": "filter",
    "body": "{\n    return handlers.entrySet().stream().filter(entry -> requestContainsKey(exchange, entry.getKey())).findFirst().map(entry -> entry.getValue().handle(exchange, chain)).orElseGet(() -> chain.filter(exchange));\n}",
    "parameters": "[@NotNull ServerWebExchange exchange, @NotNull WebFilterChain chain]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Checks if the request contains the specified key in headers or query parameters.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The current server web exchange.'}]}', name=Optional[exchange]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The key to check in the request.'}]}', name=Optional[key]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='True if the request contains the specified key, false otherwise.'}]}', name=Optional.empty}]}",
    "name": "requestContainsKey",
    "body": "{\n    return exchange.getRequest().getHeaders().containsKey(key) || exchange.getRequest().getQueryParams().containsKey(key);\n}",
    "parameters": "[ServerWebExchange exchange, String key]",
    "returnType": "boolean"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves the value of the specified key from the request headers or query parameters.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The current server web exchange.'}]}', name=Optional[exchange]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The key to retrieve the value for.'}]}', name=Optional[key]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The value of the specified key, or null if not found.'}]}', name=Optional.empty}]}",
    "name": "getHeaderOrParamValue",
    "body": "{\n    return Optional.ofNullable(exchange.getRequest().getHeaders().getFirst(key)).orElse(exchange.getRequest().getQueryParams().getFirst(key));\n}",
    "parameters": "[ServerWebExchange exchange, String key]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "handle",
    "body": "",
    "parameters": "[ServerWebExchange exchange, WebFilterChain chain]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "",
    "name": "apply",
    "body": "",
    "parameters": "[T t, U u, V v]",
    "returnType": "R"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Initializes the email credentials by reading Docker secrets.\nSets the system properties for email user and password.'}]}, blockTags=[]}",
    "name": "init",
    "body": "{\n    try {\n        String USER = \"SPRING_MAIL_VALIDATION\";\n        String APP_PASS = \"GMAIL_APP_PASSWORD\";\n        springMailUser = DockerConfig.readSecret(USER);\n        gMailAppPass = DockerConfig.readSecret(APP_PASS);\n        if (StringUtils.hasText(springMailUser))\n            System.setProperty(USER, springMailUser.trim());\n        log.warn(\"springMailUser : {}\", StringUtils.hasText(springMailUser));\n        if (StringUtils.hasText(gMailAppPass))\n            System.setProperty(APP_PASS, gMailAppPass.trim());\n        log.warn(\"springMailPass : {}\", StringUtils.hasText(gMailAppPass));\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Configures and returns a JavaMailSender instance.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The configured JavaMailSender instance.'}]}', name=Optional.empty}]}",
    "name": "getJavaMailSender",
    "body": "{\n    JavaMailSenderImpl mailSender = new JavaMailSenderImpl();\n    mailSender.setHost(\"smtp.gmail.com\");\n    mailSender.setPort(587);\n    mailSender.setUsername(springMailUser);\n    mailSender.setPassword(gMailAppPass);\n    Properties props = mailSender.getJavaMailProperties();\n    props.put(\"mail.transport.protocol\", \"smtp\");\n    props.put(\"mail.smtp.auth\", \"true\");\n    props.put(\"mail.smtp.starttls.enable\", \"true\");\n    // props.put(\"mail.debug\", \"true\");\n    return mailSender;\n}",
    "parameters": "[]",
    "returnType": "JavaMailSender"
  },
  {
    "javadoc": "",
    "name": "getJavadoc",
    "body": "{\n    try {\n        Resource resource = new FileSystemResource(\"/app/javadoc/index.html\");\n        if (!resource.exists()) {\n            log.error(\"Javadoc file not found at /app/javadoc/index.html\");\n            return new ResponseEntity<>(HttpStatus.NOT_FOUND);\n        }\n        byte[] content = Files.readAllBytes(resource.getFile().toPath());\n        HttpHeaders headers = new HttpHeaders();\n        headers.add(\"Content-Type\", \"text/html\");\n        return new ResponseEntity<>(content, headers, HttpStatus.OK);\n    } catch (IOException e) {\n        log.error(\"Error reading Javadoc file: \", e);\n        return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n}",
    "parameters": "[]",
    "returnType": "ResponseEntity<byte[]>"
  },
  {
    "javadoc": "",
    "name": "register",
    "body": "{\n    return auth.registerNewUser(userJson);\n}",
    "parameters": "[@Valid @RequestBody UserJustToSave userJson]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "",
    "name": "createAuthenticationTokenByLogin",
    "body": "{\n    return auth.authenticationByLogin(AuthRequestDto);\n}",
    "parameters": "[@RequestBody AuthRequestDto AuthRequestDto]",
    "returnType": "Mono<ResponseEntity<Response>>"
  },
  {
    "javadoc": "",
    "name": "forgotPassword",
    "body": "{\n    return auth.sendEmailCodeToResetPassword(userJson);\n}",
    "parameters": "[@RequestBody UserJson userJson]",
    "returnType": "Mono<ResponseEntity<Response>>"
  },
  {
    "javadoc": "",
    "name": "getFavorites",
    "body": "{\n    return AuthorizationUtil.executeIfAuthorized(favoriteRequest, (json, userDetails) -> favoriteService.getFavorites(favoriteRequest));\n}",
    "parameters": "[@RequestBody @Nonnull FavoriteRequest favoriteRequest]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "",
    "name": "addFavoriteRecipe",
    "body": "{\n    return AuthorizationUtil.executeIfAuthorized(favoriteRequest, (json, userDetails) -> favoriteService.addFavoriteRecipe(favoriteRequest));\n}",
    "parameters": "[@RequestBody @Nonnull FavoriteRequest favoriteRequest]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "",
    "name": "addFavoriteIngredient",
    "body": "{\n    return AuthorizationUtil.executeIfAuthorized(favoriteRequest, (json, userDetails) -> favoriteService.addFavoriteIngredient(favoriteRequest));\n}",
    "parameters": "[@RequestBody @Nonnull FavoriteRequest favoriteRequest]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "",
    "name": "removeFavoriteRecipe",
    "body": "{\n    return AuthorizationUtil.executeIfAuthorized(favoriteRequest, (json, userDetails) -> favoriteService.removeFavoriteRecipe(favoriteRequest));\n}",
    "parameters": "[@RequestBody @Nonnull FavoriteRequest favoriteRequest]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "",
    "name": "removeFavoriteIngredient",
    "body": "{\n    return AuthorizationUtil.executeIfAuthorized(favoriteRequest, (json, userDetails) -> favoriteService.removeFavoriteIngredient(favoriteRequest));\n}",
    "parameters": "[@RequestBody @Nonnull FavoriteRequest favoriteRequest]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "",
    "name": "handleValidationExceptions",
    "body": "{\n    Map<String, String> errorMsg = ex.getBindingResult().getFieldErrors().stream().collect(Collectors.groupingBy(FieldError::getField, Collectors.mapping(FieldError::getDefaultMessage, Collectors.joining(\"; \"))));\n    return createErrorResponse(HttpStatus.BAD_REQUEST, \"Invalid or incorrect format!!!\", errorMsg);\n}",
    "parameters": "[MethodArgumentNotValidException ex]",
    "returnType": "Response"
  },
  {
    "javadoc": "",
    "name": "handleValidationExceptions",
    "body": "{\n    @SuppressWarnings(\"DataFlowIssue\")\n    Map<String, String> errors = ex.getFieldErrors().stream().collect(Collectors.toMap(FieldError::getField, FieldError::getDefaultMessage, (existing, replacement) -> existing));\n    return createErrorResponse(HttpStatus.BAD_REQUEST, \"Invalid or incorrect format!!!\", errors);\n}",
    "parameters": "[WebExchangeBindException ex]",
    "returnType": "Response"
  },
  {
    "javadoc": "",
    "name": "handleConstraintViolationException",
    "body": "{\n    var errors = ex.getConstraintViolations().stream().collect(Collectors.toMap(violation -> {\n        String path = violation.getPropertyPath().toString();\n        // Retorna solo el nombre del campo\n        return path.substring(path.lastIndexOf('.') + 1);\n    }, // El mensaje de error para esa violación\n    ConstraintViolation::getMessage, // En caso de campos duplicados, mantiene el primer mensaje de error encontrado\n    (existingValue, newValue) -> existingValue));\n    return createErrorResponse(HttpStatus.BAD_REQUEST, \"Validation error\", errors);\n}",
    "parameters": "[ConstraintViolationException ex]",
    "returnType": "Response"
  },
  {
    "javadoc": "",
    "name": "handleValidationExceptions",
    "body": "{\n    String errorMessage = \"Invalid request body or not present: A valid request body is required.\";\n    return createErrorResponse(HttpStatus.BAD_REQUEST, errorMessage, ex);\n}",
    "parameters": "[DecodingException ex]",
    "returnType": "Response"
  },
  {
    "javadoc": "",
    "name": "handleInvalidRequest",
    "body": "{\n    return createErrorResponse(HttpStatus.BAD_REQUEST, \"Invalid or incorrect requisition!!!\", ex);\n}",
    "parameters": "[Exception ex]",
    "returnType": "Response"
  },
  {
    "javadoc": "",
    "name": "handleCantFoundWhatYouWant",
    "body": "{\n    return createErrorResponse(HttpStatus.INTERNAL_SERVER_ERROR, \"Couldn't find what you want\", ex);\n}",
    "parameters": "[Exception ex]",
    "returnType": "Response"
  },
  {
    "javadoc": "",
    "name": "handleRequestNotFound",
    "body": "{\n    return createErrorResponse(HttpStatus.NOT_FOUND, \"SORRY BABY, the fault is ours!!!\", ex);\n}",
    "parameters": "[Exception ex]",
    "returnType": "Response"
  },
  {
    "javadoc": "",
    "name": "handleJwtException",
    "body": "{\n    return createErrorResponse(HttpStatus.UNAUTHORIZED, \"Please, Log in again!!!\", ex);\n}",
    "parameters": "[Exception ex]",
    "returnType": "Response"
  },
  {
    "javadoc": "",
    "name": "createErrorResponse",
    "body": "{\n    return Response.error(httpMessageError(status, customMessage), Map.of(\"ERROR\", ex.getMessage().split(\":\")[0]));\n}",
    "parameters": "[HttpStatus status, String customMessage, Exception ex]",
    "returnType": "Response"
  },
  {
    "javadoc": "",
    "name": "createErrorResponse",
    "body": "{\n    return Response.error(httpMessageError(status, customMessage), map);\n}",
    "parameters": "[HttpStatus status, String customMessage, Map map]",
    "returnType": "Response"
  },
  {
    "javadoc": "",
    "name": "httpMessageError",
    "body": "{\n    return String.format(\"[%s - %d] 8==> %s\", status.getReasonPhrase().toUpperCase(), status.value(), msg);\n}",
    "parameters": "[HttpStatus status, String msg]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "existsByEmail",
    "body": "{\n    return service.existsByEmail(userJson);\n}",
    "parameters": "[@Valid @RequestBody UserJson userJson]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "",
    "name": "readOne",
    "body": "{\n    return AuthorizationUtil.executeIfAuthorized(userJson, (json, userDetails) -> service.readOne(json));\n}",
    "parameters": "[@Valid @RequestBody UserJson userJson]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "",
    "name": "update",
    "body": "{\n    return AuthorizationUtil.executeIfAuthorized(userJson, (json, userDetails) -> service.updateOne(json));\n}",
    "parameters": "[@RequestBody UserJson userJson]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "",
    "name": "deleteOne",
    "body": "{\n    return AuthorizationUtil.executeIfAuthorized(new UserJson(id), (json, userDetails) -> service.deleteOne(json));\n}",
    "parameters": "[@RequestParam(\"id\") String id]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "",
    "name": "activate",
    "body": "{\n    return service.activateAccount(activationCode);\n}",
    "parameters": "[@RequestParam(\"activationCode\") String activationCode]",
    "returnType": "Mono<ResponseEntity<String>>"
  },
  {
    "javadoc": "",
    "name": "resendActivation",
    "body": "{\n    return service.resendActivateCode(emailToResend);\n}",
    "parameters": "[@ValidEmail @RequestParam(\"emailToResend\") String emailToResend]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "",
    "name": "resetPassword",
    "body": "{\n    return service.resetPasswordByCode(resetCode);\n}",
    "parameters": "[@RequestParam(\"resetCode\") String resetCode]",
    "returnType": "Mono<ResponseEntity<String>>"
  },
  {
    "javadoc": "",
    "name": "setNewPassword",
    "body": "{\n    return service.setNewPasswordByCode(userJson);\n}",
    "parameters": "[@RequestBody UserJson userJson]",
    "returnType": "Mono<ResponseEntity<String>>"
  },
  {
    "javadoc": "",
    "name": "isValidBirthdate",
    "body": "{\n    return birthdate != null && !birthdate.isAfter(LocalDate.now().minusYears(7));\n}",
    "parameters": "[LocalDate birthdate]",
    "returnType": "boolean"
  },
  {
    "javadoc": "",
    "name": "notValidBirthdate",
    "body": "{\n    return birthdate == null || birthdate.isAfter(LocalDate.now().minusYears(7));\n}",
    "parameters": "[LocalDate birthdate]",
    "returnType": "boolean"
  },
  {
    "javadoc": "",
    "name": "isNullOrEmpty",
    "body": "{\n    return !StringUtils.hasText(something);\n}",
    "parameters": "[String something]",
    "returnType": "boolean"
  },
  {
    "javadoc": "",
    "name": "isNullOrEmptyOrLiteralNull",
    "body": "{\n    return isNullOrEmpty(something) || \"null\".equalsIgnoreCase(something.trim());\n}",
    "parameters": "[String something]",
    "returnType": "boolean"
  },
  {
    "javadoc": "",
    "name": "notNullOrEmpty",
    "body": "{\n    return StringUtils.hasText(something) && !\"null\".equalsIgnoreCase(something.trim());\n}",
    "parameters": "[String something]",
    "returnType": "boolean"
  },
  {
    "javadoc": "",
    "name": "TitleCase",
    "body": "{\n    return isNullOrEmptyOrLiteralNull(toConvert) ? null : TitleCase.all(toConvert);\n}",
    "parameters": "[String toConvert]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "encryptPassword",
    "body": "{\n    return BCrypt.encode(toEncrypt);\n}",
    "parameters": "[String toEncrypt]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "encryptMatches",
    "body": "{\n    return notNullOrEmpty(rawPassword) && BCrypt.matches(rawPassword, encodedPassword);\n}",
    "parameters": "[String rawPassword, String encodedPassword]",
    "returnType": "boolean"
  },
  {
    "javadoc": "",
    "name": "encryptNotMatches",
    "body": "{\n    return !encryptMatches(rawPassword, encodedPassword);\n}",
    "parameters": "[String rawPassword, String encodedPassword]",
    "returnType": "boolean"
  },
  {
    "javadoc": "",
    "name": "isValidEmail",
    "body": "{\n    return notNullOrEmpty(email) && email.matches(buildEmailRegex());\n}",
    "parameters": "[String email]",
    "returnType": "boolean"
  },
  {
    "javadoc": "",
    "name": "notValidEmail",
    "body": "{\n    return isNullOrEmpty(email) || !email.matches(buildEmailRegex());\n}",
    "parameters": "[String email]",
    "returnType": "boolean"
  },
  {
    "javadoc": "",
    "name": "buildEmailRegex",
    "body": "{\n    String front = \"[\\\\p{L}\\\\p{N}!#$%&'*+/=?^_`{|}~-]+\";\n    String back = \"[\\\\p{L}\\\\p{N}](?:[a-z0-9-]*[\\\\p{L}\\\\p{N}]\";\n    String domain = String.format(\"(?:%s)?.)+%s)?\", back, back);\n    return String.format(\"%s(?:.%s)*@%s\", front, front, domain);\n}",
    "parameters": "[]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "isValidPassword",
    "body": "{\n    return notNullOrEmpty(password) && password.matches(buildPassRegex());\n}",
    "parameters": "[String password]",
    "returnType": "boolean"
  },
  {
    "javadoc": "",
    "name": "notValidPassword",
    "body": "{\n    return isNullOrEmpty(password) || !password.matches(buildPassRegex());\n}",
    "parameters": "[String password]",
    "returnType": "boolean"
  },
  {
    "javadoc": "",
    "name": "buildPassRegex",
    "body": "{\n    // String characters = \"!¡|'´`¨\\\\^*+@·#$%&/{}()=\\\\-_:.;,<>?¿\";\n    String charactersUnicode = \"\\\\u0021\\\\u00A1\\\\u007C\\\\u0027\\\\u00B4\\\\u0060\\\\u00A8\\\\u005E\\\\u002A\\\\u002B\\\\u0040\\\\u00B7\\\\u0023\\\\u0024\\\\u0025\\\\u0026\\\\u002F\\\\u007B\\\\u007D\\\\u0028\\\\u0029\\\\u003D\\\\u005C\\\\u002D\\\\u005F\\\\u003A\\\\u002E\\\\u003B\\\\u002C\\\\u003C\\\\u003E\\\\u003F\\\\u00BF\";\n    String regex = \"^(?=.*[\\\\p{Ll}])(?=.*[\\\\p{Lu}])(?=.*\\\\p{N})(?=.*[%s])[\\\\p{L}\\\\p{N}%s]{8,}$\";\n    return String.format(regex, charactersUnicode, charactersUnicode);\n}",
    "parameters": "[]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "convertToJsonAsString",
    "body": "{\n    try {\n        return new ObjectMapper().writeValueAsString(obj);\n    } catch (JsonProcessingException e) {\n        return \"{\\\"error\\\": \\\"Error converting to JSON.\\\"}\";\n    }\n}",
    "parameters": "[Object obj]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "convertToJsonAsBytes",
    "body": "{\n    try {\n        return new ObjectMapper().writeValueAsBytes(obj);\n    } catch (JsonProcessingException e) {\n        return \"{\\\"error\\\": \\\"Error converting to JSON.\\\"}\".getBytes();\n    }\n}",
    "parameters": "[Object obj]",
    "returnType": "byte[]"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Public static method that processes the string to be converted: eliminates\nany space characters that may be at the beginning and at the end, then\nremoves any double-spacing, after all, proceed with the conversion into Title\nCase.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string sentence that will be converted.'}]}', name=Optional[toConvert]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The same string sentence converted to a Title Case.'}]}', name=Optional.empty}]}",
    "name": "all",
    "body": "{\n    setExceptions();\n    setCapitalWord(false);\n    return toTitleSentence(toConvert);\n}",
    "parameters": "[String toConvert]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Public static method that processes the string to be converted: eliminates\nany space characters that may be at the beginning and at the end, then\nremoves any double-spacing, if you have any exceptions set to be ignored, after\nall, send everything to conversion.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string sentence that will be converted.'}]}', name=Optional[toConvert]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='array of strings with all words that will be ignored when\n                  converting OR words strings separated by a comma: \"word1\",\n                  \"word2\", \"word3\"...'}]}', name=Optional[exceptions]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the same string sentence converted to a Title Case.'}]}', name=Optional.empty}]}",
    "name": "withExceptions",
    "body": "{\n    setExceptions(exceptions);\n    setCapitalWord(false);\n    return toTitleSentence(toConvert);\n}",
    "parameters": "[String toConvert, String... exceptions]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Public static method that processes the string to be converted: eliminates\nany space characters that may be at the beginning and at the end, then\nremoves any double-spacing, if you have any exceptions set to be ignored, after\nall, send everything to conversion. This method ignores any word that is fully\ncapitalized if the whole sentence is not all in upper case, in this case it\nis necessary to configure the exceptions that will be ignored.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string sentence that will be converted.'}]}', name=Optional[toConvert]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='array of all words that will be ignored when converting\n                  OR words strings separated by a comma: \"word1\", \"word2\",\n                  \"word3\"...'}]}', name=Optional[exceptions]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the same string sentence converted to a Title Case.'}]}', name=Optional.empty}]}",
    "name": "withCAPITAL",
    "body": "{\n    setExceptions(exceptions);\n    setCapitalWord(!toConvert.matches(UPPER_SENTENCE));\n    return toTitleSentence(toConvert);\n}",
    "parameters": "[String toConvert, String... exceptions]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Public instance method that processes the string to be converted: eliminates\nany space characters that may be at the beginning and at the end, then\nremoves any double-spacing, use instance global exceptions to set the words\nto be ignored, after all, send everything to conversion.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string sentence that will be converted.'}]}', name=Optional[toConvert]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the same string sentence converted to a Title Case.'}]}', name=Optional.empty}]}",
    "name": "titleCase",
    "body": "{\n    setCapitalWord(false);\n    return toTitleSentence(toConvert);\n}",
    "parameters": "[String toConvert]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Public instance method that processes the string to be converted: eliminates\nany space characters that may be at the beginning and at the end, then\nremoves any double-spacing, use global instance exceptions to set the words\nto be ignored, after all, send everything to conversion. This method ignores\nany word that is fully capitalized if the whole sentence is not all in upper\ncase, in this case it is necessary to configure the exceptions that will be\nignored.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string sentence that will be converted.'}]}', name=Optional[toConvert]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the same string sentence converted to a Title Case.'}]}', name=Optional.empty}]}",
    "name": "titleCAPITAL",
    "body": "{\n    setCapitalWord(!toConvert.matches(UPPER_SENTENCE));\n    return toTitleSentence(toConvert);\n}",
    "parameters": "[String toConvert]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Private method that processes the string sentence to be converted: first\neliminates any space characters that may be at the beginning and at the end,\nthen removes any double-spacing, then split the string from its spaces in an\narray of words. For each one of them proceeds with the verification of your\nspecific case, then if '}, JavadocInlineTag{tagName='code', type=CODE, content=' capitalWord'}, JavadocSnippet{text=' is true will check if every word\nmatches with a fully capitalized word, if so it does not convert into a Title\nCase.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string sentence that will be converted.'}]}', name=Optional[toConvert]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the same string sentence converted to a Title Case.'}]}', name=Optional.empty}]}",
    "name": "toTitleSentence",
    "body": "{\n    setTheInput(toConvert);\n    setArrayOfConvertedWords();\n    if (hasExceptions())\n        rateFirstWordOfArray();\n    return String.join(\" \", arrayWords);\n}",
    "parameters": "[String toConvert]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Private auxiliary method that prepares the string that will be converted.\nFirst eliminate spaces that may exist at the beginning and at the end\n(TRIM), then replace any multiple space with single spaces.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to be converted'}]}', name=Optional[input]}]}",
    "name": "setTheInput",
    "body": "{\n    TitleCase.theInput = input.trim().replaceAll(\"( )+\", \" \");\n}",
    "parameters": "[String input]",
    "returnType": "void"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Private auxiliary method that break theInput to be converted into an array by\nsplit in spaces, then put that into a stream, then map to convert and collect\na new array. If there are exceptions, the first word may be one and thus\nensures that it is in title case'}]}, blockTags=[]}",
    "name": "setArrayOfConvertedWords",
    "body": "{\n    TitleCase.arrayWords = Arrays.stream(theInput.split(\" \")).map(TitleCase::rateWords).toArray(String[]::new);\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Private auxiliary method that checks whether the word fits the exception rule\nor whether it should be converted to TitleCase, depending on the case invokes\nrelevant auxiliary methods'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string each word in an array'}]}', name=Optional[word]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='string treated word (converted if is the case)'}]}', name=Optional.empty}]}",
    "name": "rateWords",
    "body": "{\n    return isExceptions(word) ? rateExceptions(word) : toTitleCase(word);\n}",
    "parameters": "[String word]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Private auxiliary method that checks whether the word is an exception or not.\nCompare the word with the list of exceptions ignoring the Case, or if\ncapitalWord is true, check if the word is capitalized'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string each word in an array'}]}', name=Optional[word]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='boolean false if it doesn't match any type of exception or true if it\nmatches'}]}', name=Optional.empty}]}",
    "name": "isExceptions",
    "body": "{\n    boolean isException = Arrays.stream(exceptions.split(\" \")).parallel().anyMatch(w -> w.equalsIgnoreCase(word));\n    boolean isCapitalWord = capitalWord && word.matches(CAPITAL_WORD);\n    return isException || isCapitalWord;\n}",
    "parameters": "[String word]",
    "returnType": "boolean"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Private auxiliary method that checks if the word exists identically among the\nexceptions, if negative it returns all lower cases.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string each word in an array'}]}', name=Optional[word]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='returns the same string if it is an exception with Case variation or\nreturns all lower case if it is a word that needs to be ignored when\nconverting.'}]}', name=Optional.empty}]}",
    "name": "rateExceptions",
    "body": "{\n    boolean isException = Arrays.stream(exceptions.split(\" \")).parallel().anyMatch(w -> w.equals(word));\n    return capitalWord || isException ? word : word.toLowerCase();\n}",
    "parameters": "[String word]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Private auxiliary method that checks if there are exceptions, simply to\nimprove readability'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='boolean true if there are and false if not.'}]}', name=Optional.empty}]}",
    "name": "hasExceptions",
    "body": "{\n    return !TitleCase.exceptions.isEmpty();\n}",
    "parameters": "[]",
    "returnType": "boolean"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Private auxiliary method that converts the first word of the array to a title\ncase if necessary.'}]}, blockTags=[]}",
    "name": "rateFirstWordOfArray",
    "body": "{\n    boolean isFirstWordNonCapital = capitalWord && !arrayWords[0].matches(CAPITAL_WORD);\n    if (!capitalWord || isFirstWordNonCapital) {\n        arrayWords[0] = toTitleCase(arrayWords[0]);\n    }\n}",
    "parameters": "[]",
    "returnType": "void"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Private method that really does the heavy lifting of this utility class, it\nchecks if the word is made up of letters only or has special characters, for\neach case proceeds with the conversion in a different way.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string word itself that will be converted'}]}', name=Optional[word]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string word converted to a Title Case'}]}', name=Optional.empty}]}",
    "name": "toTitleCase",
    "body": "{\n    return (word.matches(JUST_LETTERS)) ? titleJustLetters(word) : titleWithPunts(word);\n}",
    "parameters": "[String word]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Private auxiliary method, if the word is only letters proceed with the\nsimplest conversion using substring.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string word itself that will be converted'}]}', name=Optional[word]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string word converted to a Title Case'}]}', name=Optional.empty}]}",
    "name": "titleJustLetters",
    "body": "{\n    return word.substring(0, 1).toUpperCase().concat(word.substring(1).toLowerCase());\n}",
    "parameters": "[String word]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Private auxiliary method that create a new Builder instance and add each\nconverted character then return it as a string'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string word itself that will be converted'}]}', name=Optional[word]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string word converted to a Title Case'}]}', name=Optional.empty}]}",
    "name": "titleWithPunts",
    "body": "{\n    builder = new StringBuilder();\n    Arrays.stream(word.split(\"\")).forEach(TitleCase::append);\n    return builder.toString();\n}",
    "parameters": "[String word]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Private auxiliary method which adds to the Builder each character converted\nfrom the word'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the character to be appended in builder'}]}', name=Optional[letter]}]}",
    "name": "append",
    "body": "{\n    builder.append(lowOrUp(letter));\n}",
    "parameters": "[String letter]",
    "returnType": "void"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Private auxiliary method, which evaluates each letter, needs to be capitalized\nor not.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the character in question that is being analyzed'}]}', name=Optional[letter]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the same character in upper or lower case'}]}', name=Optional.empty}]}",
    "name": "lowOrUp",
    "body": "{\n    return conditionToUpper() ? letter.toUpperCase() : letter.toLowerCase();\n}",
    "parameters": "[String letter]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Private auxiliary method, verify if is the first letter of the word, if there\nwas a space before or if there were any of these chars before:\n!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='boolean true if it is the first letter of the word or if it has a\nspecial char, false if not.'}]}', name=Optional.empty}]}",
    "name": "conditionToUpper",
    "body": "{\n    if (builder.isEmpty())\n        return true;\n    String lastCharOnBuilder = String.valueOf(builder.charAt(builder.length() - 1));\n    return lastCharOnBuilder.matches(\"\\\\p{Punct}|\\\\s\");\n}",
    "parameters": "[]",
    "returnType": "boolean"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='method that configures whether the conversion will ignore capitalized words\nor convert them too'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='boolean true to ignore words capitalized on conversion and\n                   false to convert them too'}]}', name=Optional[capitalWord]}]}",
    "name": "setCapitalWord",
    "body": "{\n    TitleCase.capitalWord = capitalWord;\n}",
    "parameters": "[boolean capitalWord]",
    "returnType": "void"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Method that configures exceptions, that is, the words that will be ignored\nwhen converting to TitleCase. This method has Varargs as a parameter, and\ntherefore the way of passing multiple words is in the form of strings\nseparated by a comma or an array of strings.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='Varargs with de words to be ignored'}]}', name=Optional[words]}]}",
    "name": "setExceptions",
    "body": "{\n    TitleCase.exceptions = Arrays.stream(words).parallel().map(TitleCase::concatAllVariations).collect(Collectors.joining(\" \"));\n}",
    "parameters": "[String... words]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "concatAllVariations",
    "body": "{\n    return word.concat(withSymbols(word)).concat(withWraps(word));\n}",
    "parameters": "[String word]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "withSymbols",
    "body": "{\n    return Arrays.stream(SYMBOLS.split(\"\")).parallel().map(s -> String.format(\" %s%s %s%s%s %s%s\", s, word, s, word, s, word, s)).collect(Collectors.joining());\n}",
    "parameters": "[String word]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "withWraps",
    "body": "{\n    builder = new StringBuilder();\n    for (int i = 0; i < RIGHT_WRAPS.length; i++) {\n        builder.append(String.format(\" %s%s%s\", RIGHT_WRAPS[i], word, LEFT_WRAPS[i]));\n    }\n    return builder.toString();\n}",
    "parameters": "[String word]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Converts a UserDto to an ActivationDto.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The user to convert.'}]}', name=Optional[user]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The corresponding ActivationDto.'}]}', name=Optional.empty}]}",
    "name": "to",
    "body": "{\n    ActivationDto activationDto = new ActivationDto();\n    activationDto.setId(user.get_id());\n    return activationDto;\n}",
    "parameters": "[UserDto user]",
    "returnType": "ActivationDto"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Generates a secure random activation code.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The generated activation code.'}]}', name=Optional.empty}]}",
    "name": "generateCode",
    "body": "{\n    SecureRandom random = new SecureRandom();\n    byte[] bytes = new byte[24];\n    random.nextBytes(bytes);\n    return Base64.getUrlEncoder().withoutPadding().encodeToString(bytes);\n}",
    "parameters": "[]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Converts a UserDto to a ResetDto.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The user to convert.'}]}', name=Optional[user]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The corresponding ResetDto.'}]}', name=Optional.empty}]}",
    "name": "to",
    "body": "{\n    var resetDto = new ResetDto();\n    resetDto.setId(user.get_id());\n    return resetDto;\n}",
    "parameters": "[UserDto user]",
    "returnType": "ResetDto"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Generates a secure random reset code.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The generated reset code.'}]}', name=Optional.empty}]}",
    "name": "generateCode",
    "body": "{\n    SecureRandom random = new SecureRandom();\n    byte[] bytes = new byte[64];\n    random.nextBytes(bytes);\n    return Base64.getUrlEncoder().withoutPadding().encodeToString(bytes);\n}",
    "parameters": "[]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the message associated with the status.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The status message.'}]}', name=Optional.empty}]}",
    "name": "getDetails",
    "body": "{\n    return message;\n}",
    "parameters": "[]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "get",
    "body": "{\n    return code;\n}",
    "parameters": "[]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the role string associated with the role.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The role string.'}]}', name=Optional.empty}]}",
    "name": "get",
    "body": "{\n    return role;\n}",
    "parameters": "[]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Adds a recipe to the list of favorite recipes if not already present.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ID of the recipe to add.'}]}', name=Optional[recipeId]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Mono emitting this FavoriteDto.'}]}', name=Optional.empty}]}",
    "name": "addRecipe",
    "body": "{\n    return Mono.just(recipeId).filterWhen(this::notContainsRecipe).doOnNext(recipes::add).thenReturn(this);\n}",
    "parameters": "[String recipeId]",
    "returnType": "Mono<FavoriteDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Removes a recipe from the list of favorite recipes.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ID of the recipe to remove.'}]}', name=Optional[recipeId]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Mono emitting this FavoriteDto.'}]}', name=Optional.empty}]}",
    "name": "removeRecipe",
    "body": "{\n    return Mono.just(recipeId).doOnNext(recipes::remove).thenReturn(this);\n}",
    "parameters": "[String recipeId]",
    "returnType": "Mono<FavoriteDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Checks if a recipe is in the list of favorite recipes.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ID of the recipe to check.'}]}', name=Optional[recipeId]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Mono emitting true if the recipe is in the list, otherwise false.'}]}', name=Optional.empty}]}",
    "name": "containsRecipe",
    "body": "{\n    return Mono.just(recipes.contains(recipeId));\n}",
    "parameters": "[String recipeId]",
    "returnType": "Mono<Boolean>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Checks if a recipe is not in the list of favorite recipes.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ID of the recipe to check.'}]}', name=Optional[recipeId]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Mono emitting true if the recipe is not in the list, otherwise false.'}]}', name=Optional.empty}]}",
    "name": "notContainsRecipe",
    "body": "{\n    return containsRecipe(recipeId).map(exists -> !exists);\n}",
    "parameters": "[String recipeId]",
    "returnType": "Mono<Boolean>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Adds an ingredient to the list of favorite ingredients if not already present.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ID of the ingredient to add.'}]}', name=Optional[ingredientId]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Mono emitting this FavoriteDto.'}]}', name=Optional.empty}]}",
    "name": "addIngredient",
    "body": "{\n    return Mono.just(ingredientId).filterWhen(this::notContainsFavoriteIngredient).doOnNext(ingredients::add).thenReturn(this);\n}",
    "parameters": "[String ingredientId]",
    "returnType": "Mono<FavoriteDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Removes an ingredient from the list of favorite ingredients.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ID of the ingredient to remove.'}]}', name=Optional[ingredientId]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Mono emitting this FavoriteDto.'}]}', name=Optional.empty}]}",
    "name": "removeIngredient",
    "body": "{\n    return Mono.just(ingredientId).doOnNext(ingredients::remove).thenReturn(this);\n}",
    "parameters": "[String ingredientId]",
    "returnType": "Mono<FavoriteDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Checks if an ingredient is in the list of favorite ingredients.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ID of the ingredient to check.'}]}', name=Optional[ingredientId]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Mono emitting true if the ingredient is in the list, otherwise false.'}]}', name=Optional.empty}]}",
    "name": "containsFavoriteIngredient",
    "body": "{\n    return Mono.just(ingredients.contains(ingredientId));\n}",
    "parameters": "[String ingredientId]",
    "returnType": "Mono<Boolean>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Checks if an ingredient is not in the list of favorite ingredients.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The ID of the ingredient to check.'}]}', name=Optional[ingredientId]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Mono emitting true if the ingredient is not in the list, otherwise false.'}]}', name=Optional.empty}]}",
    "name": "notContainsFavoriteIngredient",
    "body": "{\n    return containsFavoriteIngredient(ingredientId).map(exists -> !exists);\n}",
    "parameters": "[String ingredientId]",
    "returnType": "Mono<Boolean>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Gets the user ID.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The user ID.'}]}', name=Optional.empty}]}",
    "name": "get_id",
    "body": "{\n    return userId;\n}",
    "parameters": "[]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates an error response with a message.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The error message.'}]}', name=Optional[message]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Response object indicating an error.'}]}', name=Optional.empty}]}",
    "name": "error",
    "body": "{\n    Response response = new Response();\n    response.put(SUCCESS, false);\n    response.put(MESSAGE, setMessage(message));\n    return response;\n}",
    "parameters": "[String message]",
    "returnType": "Response"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a Mono wrapping an error response with a message.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The error message.'}]}', name=Optional[message]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Mono wrapping a Response object indicating an error.'}]}', name=Optional.empty}]}",
    "name": "monoError",
    "body": "{\n    return Mono.just(error(message));\n}",
    "parameters": "[String message]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a Mono wrapping an error response from an exception.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The exception.'}]}', name=Optional[e]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Mono wrapping a Response object indicating an error.'}]}', name=Optional.empty}]}",
    "name": "monoError",
    "body": "{\n    return monoError(e.getMessage());\n}",
    "parameters": "[Exception e]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a Mono wrapping an error response from a throwable.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The throwable.'}]}', name=Optional[e]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Mono wrapping a Response object indicating an error.'}]}', name=Optional.empty}]}",
    "name": "monoError",
    "body": "{\n    return monoError(e.getMessage());\n}",
    "parameters": "[Throwable e]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates an error response with a message and additional content.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The error message.'}]}', name=Optional[message]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The additional content.'}]}', name=Optional[content]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Response object indicating an error.'}]}', name=Optional.empty}]}",
    "name": "error",
    "body": "{\n    Response response = error(message);\n    if (content != null)\n        response.put(CONTENT, content);\n    return response;\n}",
    "parameters": "[String message, @Nullable Object content]",
    "returnType": "Response"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a Mono wrapping an error response with a message and additional content.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The error message.'}]}', name=Optional[message]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The additional content.'}]}', name=Optional[content]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Mono wrapping a Response object indicating an error.'}]}', name=Optional.empty}]}",
    "name": "monoError",
    "body": "{\n    return Mono.just(error(message, content));\n}",
    "parameters": "[String message, @Nullable Object content]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a Mono wrapping an error response from a UserServiceException.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The UserServiceException.'}]}', name=Optional[e]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Mono wrapping a Response object indicating an error.'}]}', name=Optional.empty}]}",
    "name": "monoError",
    "body": "{\n    return monoError(e.getMessage(), e.getErrors());\n}",
    "parameters": "[UserServiceException e]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a success response with a message and additional content.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The success message.'}]}', name=Optional[message]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The additional content.'}]}', name=Optional[content]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Response object indicating success.'}]}', name=Optional.empty}]}",
    "name": "success",
    "body": "{\n    Response response = new Response();\n    response.put(SUCCESS, true);\n    response.put(MESSAGE, setMessage(message));\n    if (content != null)\n        response.put(CONTENT, content);\n    return response;\n}",
    "parameters": "[String message, @Nullable Object content]",
    "returnType": "Response"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Sets the message if it's not null or empty.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The message to set.'}]}', name=Optional[message]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The message if not null or empty, otherwise a default error message.'}]}', name=Optional.empty}]}",
    "name": "setMessage",
    "body": "{\n    return (notNullOrEmpty(message)) ? message : MESSAGE_ERROR;\n}",
    "parameters": "[String message]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Gets the message from the response.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The message from the response.'}]}', name=Optional.empty}]}",
    "name": "getMessage",
    "body": "{\n    return (get(MESSAGE) == null) ? MESSAGE_ERROR : (String) get(MESSAGE);\n}",
    "parameters": "[]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Checks if the response indicates success.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='True if the response indicates success, otherwise false.'}]}', name=Optional.empty}]}",
    "name": "isSuccess",
    "body": "{\n    return (boolean) get(SUCCESS);\n}",
    "parameters": "[]",
    "returnType": "boolean"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Gets the content from the response.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The content from the response.'}]}', name=Optional.empty}]}",
    "name": "getContent",
    "body": "{\n    return map.containsKey(CONTENT) ? map.get(CONTENT) : map.remove(CONTENT);\n}",
    "parameters": "[]",
    "returnType": "Object"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Adds a message to the response.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The message to add.'}]}', name=Optional[message]}]}",
    "name": "addMessage",
    "body": "{\n    if (notNullOrEmpty(message))\n        this.put(MESSAGE, this.get(MESSAGE) + message);\n}",
    "parameters": "[String message]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "toString",
    "body": "{\n    return this.map.toString();\n}",
    "parameters": "[]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "put",
    "body": "{\n    map.put(key, value);\n}",
    "parameters": "[String key, Object value]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "get",
    "body": "{\n    return map.get(key);\n}",
    "parameters": "[String key]",
    "returnType": "Object"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a Mono that emits this exception with the specified message.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The detail message.'}]}', name=Optional[message]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The type parameter.'}]}', name=Optional[<T>]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Mono that emits this exception.'}]}', name=Optional.empty}]}",
    "name": "mono",
    "body": "{\n    return Mono.error(new UserServiceException(message));\n}",
    "parameters": "[String message]",
    "returnType": "Mono<T>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a Mono that emits this exception with the specified message and errors.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The detail message.'}]}', name=Optional[message]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The errors map.'}]}', name=Optional[errors]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The type parameter.'}]}', name=Optional[<T>]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Mono that emits this exception.'}]}', name=Optional.empty}]}",
    "name": "mono",
    "body": "{\n    return Mono.error(new UserServiceException(message, errors));\n}",
    "parameters": "[String message, Map<String, Object> errors]",
    "returnType": "Mono<T>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a Mono that emits this exception based on another throwable.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The throwable to base the exception on.'}]}', name=Optional[e]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The type parameter.'}]}', name=Optional[<T>]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A Mono that emits this exception.'}]}', name=Optional.empty}]}",
    "name": "mono",
    "body": "{\n    return Mono.error(new UserServiceException(e.getMessage()));\n}",
    "parameters": "[Throwable e]",
    "returnType": "Mono<T>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Throws this exception based on another throwable.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The throwable to base the exception on.'}]}', name=Optional[throwable]}]}",
    "name": "doOnErrorMap",
    "body": "{\n    throw new UserServiceException(throwable.getMessage());\n}",
    "parameters": "[Throwable throwable]",
    "returnType": "void"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns this exception based on another throwable.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The throwable to base the exception on.'}]}', name=Optional[throwable]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='This exception.'}]}', name=Optional.empty}]}",
    "name": "onErrorMap",
    "body": "{\n    return new UserServiceException(throwable.getMessage());\n}",
    "parameters": "[Throwable throwable]",
    "returnType": "Throwable"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a new instance of this exception indicating a password mismatch.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A new UserServiceException indicating a password mismatch.'}]}', name=Optional.empty}]}",
    "name": "passNotMatch",
    "body": "{\n    return new UserServiceException(\"Password doesn't match!\");\n}",
    "parameters": "[]",
    "returnType": "UserServiceException"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Converts this UserJustToSave to a UserDto object.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A UserDto object representing this UserJustToSave.'}]}', name=Optional.empty}]}",
    "name": "toUserDTO",
    "body": "{\n    UserDto userDTO = new UserDto();\n    userDTO.setEmail(email);\n    userDTO.setPassword(encryptPassword(password));\n    userDTO.setFirstName(firstName);\n    userDTO.setSurNames(surNames);\n    userDTO.setBirthdate(birthdate);\n    return userDTO;\n}",
    "parameters": "[]",
    "returnType": "UserDto"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a UserJson object from a UserDto object.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The UserDto object to convert.'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A UserJson object.'}]}', name=Optional.empty}]}",
    "name": "from",
    "body": "{\n    return new UserJson(userDTO);\n}",
    "parameters": "[UserDto userDTO]",
    "returnType": "UserJson"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Converts this UserDto to a UserJson object.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A UserJson object representing this UserDto.'}]}', name=Optional.empty}]}",
    "name": "toJson",
    "body": "{\n    return UserJson.from(this);\n}",
    "parameters": "[]",
    "returnType": "UserJson"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Converts this UserDto to a UserJson object without the ID.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A UserJson object representing this UserDto without the ID.'}]}', name=Optional.empty}]}",
    "name": "toJsonWithoutId",
    "body": "{\n    this.set_id(null);\n    return UserJson.from(this);\n}",
    "parameters": "[]",
    "returnType": "UserJson"
  },
  {
    "javadoc": "",
    "name": "main",
    "body": "{\n    SpringApplication.run(WhataCookUsersApplication.class, args);\n}",
    "parameters": "[String[] args]",
    "returnType": "void"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Checks if a user exists by email.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userJson]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a response indicating whether the user exists'}]}', name=Optional.empty}]}",
    "name": "existsByEmail",
    "body": "{\n    return read.checkIfExistsByEmail(userJson).map(alreadyExists -> alreadyExists ? success(\"User already exists\", true) : success(\"User does not exist yet\", false)).onErrorResume(UserServiceException.class, Response::monoError).onErrorResume(Exception.class, Response::monoError);\n}",
    "parameters": "[UserJson userJson]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Activates a user account using an activation code.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the activation code'}]}', name=Optional[activationCode]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a response entity indicating the result of the activation'}]}', name=Optional.empty}]}",
    "name": "activateAccount",
    "body": "{\n    return activate.byActivationCodeSentByEmail(activationCode).map(ResponseEntity::ok).onErrorResume(UserServiceException.class, uEx -> Mono.just(ResponseEntity.badRequest().body(error(uEx.getMessage(), uEx.getErrors()).toString()))).onErrorResume(Exception.class, ex -> Mono.just(ResponseEntity.badRequest().body(error(ex.getMessage()).toString())));\n}",
    "parameters": "[String activationCode]",
    "returnType": "Mono<ResponseEntity<String>>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Resends the activation code to a user's email.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user's email'}]}', name=Optional[email]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a response indicating whether the activation code was resent successfully'}]}', name=Optional.empty}]}",
    "name": "resendActivateCode",
    "body": "{\n    return activate.resendActivationCode(email).map(resended -> success(\"Activation mail successfully resented\", resended)).onErrorResume(UserServiceException.class, Response::monoError).onErrorResume(Exception.class, Response::monoError);\n}",
    "parameters": "[String email]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Resets a user's password using a reset code.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the reset code'}]}', name=Optional[resetCode]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a response entity indicating the result of the password reset'}]}', name=Optional.empty}]}",
    "name": "resetPasswordByCode",
    "body": "{\n    return resetComponent.resetPasswordByCodeAndReturnNewPassForm(resetCode).map(ResponseEntity::ok).onErrorResume(UserServiceException.class, uEx -> Mono.just(ResponseEntity.badRequest().body(convertToJsonAsString(error(uEx.getMessage(), uEx.getErrors()))))).onErrorResume(Exception.class, ex -> Mono.just(ResponseEntity.badRequest().body(convertToJsonAsString(error(ex.getMessage())))));\n}",
    "parameters": "[String resetCode]",
    "returnType": "Mono<ResponseEntity<String>>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Sets a new password for a user using a reset code.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userJson]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a response entity indicating the result of setting the new password'}]}', name=Optional.empty}]}",
    "name": "setNewPasswordByCode",
    "body": "{\n    return resetComponent.setNewPasswordByCode(userJson).map(ResponseEntity::ok).onErrorResume(UserServiceException.class, uEx -> Mono.just(ResponseEntity.badRequest().body(convertToJsonAsString(error(uEx.getMessage(), uEx.getErrors()))))).onErrorResume(Exception.class, ex -> Mono.just(ResponseEntity.badRequest().body(convertToJsonAsString(error(ex.getMessage())))));\n}",
    "parameters": "[UserJson userJson]",
    "returnType": "Mono<ResponseEntity<String>>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Reads a user's information.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userJson]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a response containing the user's information'}]}', name=Optional.empty}]}",
    "name": "readOne",
    "body": "{\n    return read.findUserByEmail(userJson).map(found -> success(\"User successfully read\", found)).onErrorResume(UserServiceException.class, Response::monoError).onErrorResume(Exception.class, Response::monoError);\n}",
    "parameters": "[UserJson userJson]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Updates a user's information.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userJson]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a response indicating the result of the update'}]}', name=Optional.empty}]}",
    "name": "updateOne",
    "body": "{\n    return update.updateUser(userJson).map(updated -> success(\"User successfully UPDATED\", updated)).onErrorResume(UserServiceException.class, Response::monoError).onErrorResume(Exception.class, Response::monoError);\n}",
    "parameters": "[UserJson userJson]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Deletes a user's information.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userJson]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a response indicating the result of the deletion'}]}', name=Optional.empty}]}",
    "name": "deleteOne",
    "body": "{\n    return delete.proceedIfApplicable(userJson).onErrorResume(UserServiceException.class, Response::monoError).onErrorResume(Exception.class, Response::monoError);\n}",
    "parameters": "[UserJson userJson]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Finds a user by username (email or ID).'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user's email or ID'}]}', name=Optional[userEmailOrId]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the user is not found'}]}', name=Optional[UsernameNotFoundException]}]}",
    "name": "findByUsername",
    "body": "{\n    try {\n        return login.validSpringUserToLogin(userEmailOrId);\n    } catch (Exception e) {\n        throw new UsernameNotFoundException(userEmailOrId);\n    }\n}",
    "parameters": "[String userEmailOrId]",
    "returnType": "Mono<UserDetails>"
  },
  {
    "javadoc": "",
    "name": "findByCode",
    "body": "",
    "parameters": "[String code]",
    "returnType": "Mono<ResetDto>"
  },
  {
    "javadoc": "",
    "name": "existsByEmail",
    "body": "",
    "parameters": "[UserJson userJson]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "",
    "name": "readOne",
    "body": "",
    "parameters": "[UserJson userJson]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "",
    "name": "updateOne",
    "body": "",
    "parameters": "[UserJson userJson]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "",
    "name": "deleteOne",
    "body": "",
    "parameters": "[UserJson userJson]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "",
    "name": "findByCode",
    "body": "",
    "parameters": "[String code]",
    "returnType": "Mono<ActivationDto>"
  },
  {
    "javadoc": "",
    "name": "findByEmail",
    "body": "",
    "parameters": "[String email]",
    "returnType": "Mono<UserDto>"
  },
  {
    "javadoc": "",
    "name": "findBy_id",
    "body": "",
    "parameters": "[String _id]",
    "returnType": "Mono<UserDto>"
  },
  {
    "javadoc": "",
    "name": "existsByEmail",
    "body": "",
    "parameters": "[String email]",
    "returnType": "Mono<Boolean>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Validates and retrieves a Spring Security user.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user email or ID'}]}', name=Optional[userEmailOrId]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono of UserDetails'}]}', name=Optional.empty}]}",
    "name": "validSpringUserToLogin",
    "body": "{\n    return Mono.just(userEmailOrId).flatMap(info -> {\n        if (Util.isValidEmail(info))\n            return findUserByEmail(info);\n        else\n            return findUserById(info);\n    });\n}",
    "parameters": "[String userEmailOrId]",
    "returnType": "Mono<UserDetails>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Finds a user by email.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user email'}]}', name=Optional[email]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono of UserDetails'}]}', name=Optional.empty}]}",
    "name": "findUserByEmail",
    "body": "{\n    return DAO.findByEmail(email).switchIfEmpty(UserServiceException.mono(\"USER NOT FOUND!\")).flatMap(this::verifyAccountStatusByEmail).map(this::newValidUserByEmail);\n}",
    "parameters": "[String email]",
    "returnType": "Mono<UserDetails>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Verifies the account status by email.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono of UserDto'}]}', name=Optional.empty}]}",
    "name": "verifyAccountStatusByEmail",
    "body": "{\n    final AccountStatus accountStatus = userDTO.getAccountStatus();\n    if (EnumSet.of(OK, OFF, REQUEST_DELETE).contains(accountStatus))\n        return Mono.just(userDTO);\n    else if (MARKED_DELETE.equals(accountStatus))\n        return deleteComponent.proceedIfApplicable(userDTO.toJson()).flatMap(response -> UserServiceException.mono(response.getMessage()));\n    else\n        return UserServiceException.mono(accountStatus.getDetails());\n}",
    "parameters": "[UserDto userDTO]",
    "returnType": "Mono<UserDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a valid UserDetails object by email.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the UserDetails object'}]}', name=Optional.empty}]}",
    "name": "newValidUserByEmail",
    "body": "{\n    Set<GrantedAuthority> authorities = listAuthorities(userDTO);\n    authorities.add(new SimpleGrantedAuthority(\"ROLE_SELF\"));\n    return new CustomUserDetails(userDTO.getEmail() + userDTO.get_id(), userDTO.getPassword(), authorities, userDTO.getEmail(), userDTO.get_id());\n}",
    "parameters": "[UserDto userDTO]",
    "returnType": "UserDetails"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Lists the authorities for a user.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a set of GrantedAuthority'}]}', name=Optional.empty}]}",
    "name": "listAuthorities",
    "body": "{\n    return Arrays.stream(userDTO.getRoleType().get().split(\",\")).map(String::trim).map(role -> new SimpleGrantedAuthority(\"ROLE_\" + role)).collect(Collectors.toSet());\n}",
    "parameters": "[UserDto userDTO]",
    "returnType": "Set<GrantedAuthority>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Finds a user by ID.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user ID'}]}', name=Optional[id]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono of UserDetails'}]}', name=Optional.empty}]}",
    "name": "findUserById",
    "body": "{\n    return DAO.findBy_id(id).switchIfEmpty(UserServiceException.mono(\"USER NOT FOUND!\")).flatMap(this::verifyAccountStatusById).map(this::newValidUserById);\n}",
    "parameters": "[String id]",
    "returnType": "Mono<UserDetails>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Verifies the account status by ID.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono of UserDto'}]}', name=Optional.empty}]}",
    "name": "verifyAccountStatusById",
    "body": "{\n    String errorMsg = \"Account Status Incorrect for this request: \" + userDTO.getAccountStatus().getDetails();\n    if (EnumSet.of(AccountStatus.OK, AccountStatus.PENDING, AccountStatus.OUTDATED).contains(userDTO.getAccountStatus())) {\n        return Mono.just(userDTO);\n    } else {\n        return UserServiceException.mono(errorMsg);\n    }\n}",
    "parameters": "[UserDto userDTO]",
    "returnType": "Mono<UserDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a valid UserDetails object by ID.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the UserDetails object'}]}', name=Optional.empty}]}",
    "name": "newValidUserById",
    "body": "{\n    Set<GrantedAuthority> authorities = listAuthorities(userDTO);\n    authorities.add(new SimpleGrantedAuthority(\"ROLE_SELF\"));\n    return new CustomUserDetails(userDTO.get_id(), userDTO.getPassword(), authorities, userDTO.getEmail(), userDTO.get_id());\n}",
    "parameters": "[UserDto userDTO]",
    "returnType": "UserDetails"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Updates user information.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details to update'}]}', name=Optional[userJson]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the updated user details as UserJson'}]}', name=Optional.empty}]}",
    "name": "updateUser",
    "body": "{\n    return DAO.findBy_id(userJson.get_id()).switchIfEmpty(UserServiceException.mono(\"User not found with this ID\", Map.of(\"_id\", userJson.get_id()))).flatMap(oldUser -> updatePlayerIfNecessary(oldUser, userJson)).flatMap(this::updateUserByDtoReturnJson);\n}",
    "parameters": "[UserJson userJson]",
    "returnType": "Mono<UserJson>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Updates user attributes if necessary.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the current user details'}]}', name=Optional[oldUser]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the new user details'}]}', name=Optional[updateInfo]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the updated user details as UserDto'}]}', name=Optional.empty}]}",
    "name": "updatePlayerIfNecessary",
    "body": "{\n    AtomicBoolean updated = new AtomicBoolean(false);\n    return Mono.just(oldUser).flatMap(user -> {\n        updateFirstName(user, updateInfo, updated);\n        updateSurnames(user, updateInfo, updated);\n        updateEmail(user, updateInfo, updated);\n        updateBirthdate(user, updateInfo, updated);\n        updatePassword(user, updateInfo, updated);\n        updateAccountStatus(user, updateInfo, updated);\n        if (!updated.get()) {\n            return UserServiceException.mono(\"No update required or data is invalid.\");\n        }\n        return Mono.just(user);\n    });\n}",
    "parameters": "[UserDto oldUser, UserJson updateInfo]",
    "returnType": "Mono<UserDto>"
  },
  {
    "javadoc": "",
    "name": "updateFirstName",
    "body": "{\n    boolean isFirstNameUpdated = updateAttribute(user::getFirstName, () -> verifyNames(updateInfo.getFirstName()), user::setFirstName);\n    updated.set(isFirstNameUpdated || updated.get());\n}",
    "parameters": "[UserDto user, UserJson updateInfo, AtomicBoolean updated]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "updateSurnames",
    "body": "{\n    boolean isSurnamesUpdated = updateAttribute(user::getSurNames, () -> verifyNames(updateInfo.getSurNames()), user::setSurNames);\n    updated.set(isSurnamesUpdated || updated.get());\n}",
    "parameters": "[UserDto user, UserJson updateInfo, AtomicBoolean updated]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "updateEmail",
    "body": "{\n    boolean isEmailUpdated = updateAttribute(user::getEmail, () -> verifyEmail(updateInfo.getEmail()), user::setEmail);\n    updated.set(isEmailUpdated || updated.get());\n}",
    "parameters": "[UserDto user, UserJson updateInfo, AtomicBoolean updated]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "updateBirthdate",
    "body": "{\n    boolean isBirthdateUpdated = updateAttribute(user::getBirthdate, () -> verifyBirthdate(updateInfo.getBirthdate()), user::setBirthdate);\n    updated.set(isBirthdateUpdated || updated.get());\n}",
    "parameters": "[UserDto user, UserJson updateInfo, AtomicBoolean updated]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "updatePassword",
    "body": "{\n    if (updateInfo.getNewPassword() != null) {\n        Optional.ofNullable(updateInfo.getPassword()).filter(pwd -> Util.encryptMatches(pwd, user.getPassword())).orElseThrow(UserServiceException::passNotMatch);\n        Optional.ofNullable(updateInfo.getNewPassword()).filter(Util::isValidPassword).ifPresent(newPwd -> {\n            user.setPassword(Util.encryptPassword(newPwd));\n            updated.set(true);\n        });\n    }\n}",
    "parameters": "[UserDto user, UserJson updateInfo, AtomicBoolean updated]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "updateAccountStatus",
    "body": "{\n    if (updateInfo.getAccountStatus() != null) {\n        boolean isCurrentStatusEligibleForUpdate = EnumSet.of(AccountStatus.OK, AccountStatus.OFF, AccountStatus.OUTDATED, AccountStatus.REQUEST_DELETE).contains(user.getAccountStatus());\n        AccountStatus toUpdate = AccountStatus.valueOf(updateInfo.getAccountStatus());\n        boolean isNewStatusValid = !AccountStatus.MARKED_DELETE.equals(toUpdate);\n        if (isCurrentStatusEligibleForUpdate && isNewStatusValid) {\n            boolean isAccountStatusUpdated = updateAttribute(user::getAccountStatus, () -> toUpdate, user::setAccountStatus);\n            updated.set(isAccountStatusUpdated || updated.get());\n        }\n    }\n}",
    "parameters": "[UserDto user, UserJson updateInfo, AtomicBoolean updated]",
    "returnType": "void"
  },
  {
    "javadoc": "",
    "name": "updateUserByDtoReturnJson",
    "body": "{\n    return Mono.just(userToSave).flatMap(DAO::save).map(UserDto::toJson);\n}",
    "parameters": "[UserDto userToSave]",
    "returnType": "Mono<UserJson>"
  },
  {
    "javadoc": "",
    "name": "updateAttribute",
    "body": "{\n    T originalValue = original.get();\n    T updatedValue = updated.get();\n    if (updatedValue != null && !Objects.equals(originalValue, updatedValue)) {\n        setter.accept(updatedValue);\n        return true;\n    }\n    return false;\n}",
    "parameters": "[Supplier<T> original, Supplier<T> updated, Consumer<T> setter]",
    "returnType": "boolean"
  },
  {
    "javadoc": "",
    "name": "verifyNames",
    "body": "{\n    return Optional.ofNullable(nameOrSurname).map(Util::TitleCase).orElse(null);\n}",
    "parameters": "[String nameOrSurname]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "verifyEmail",
    "body": "{\n    return Optional.ofNullable(email).filter(Util::isValidEmail).orElse(null);\n}",
    "parameters": "[String email]",
    "returnType": "String"
  },
  {
    "javadoc": "",
    "name": "verifyBirthdate",
    "body": "{\n    return Optional.ofNullable(localDate).filter(Util::isValidBirthdate).orElse(null);\n}",
    "parameters": "[LocalDate localDate]",
    "returnType": "LocalDate"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Activates a user account using the provided activation code.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the activation code'}]}', name=Optional[activationCode]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='HTML content indicating the result of the activation process'}]}', name=Optional.empty}]}",
    "name": "byActivationCodeSentByEmail",
    "body": "{\n    return Mono.just(activationCode).flatMap(activationService::findByCode).switchIfEmpty(UserServiceException.mono(\"This Code is Invalid\")).flatMap(activationDto -> {\n        if (ChronoUnit.HOURS.between(activationDto.getExpiration(), LocalDateTime.now()) > 24)\n            return UserServiceException.mono(\"This Code is Expired\");\n        else\n            return Mono.just(activationDto);\n    }).flatMap(activationDto -> DAO.findBy_id(activationDto.getId()).flatMap(userDTO -> {\n        if (userDTO.getAccountStatus() == AccountStatus.PENDING) {\n            userDTO.setAccountStatus(AccountStatus.OK);\n            return DAO.save(userDTO).then(activationService.deleteById(activationDto.getId())).thenReturn(userDTO);\n        } else {\n            return UserServiceException.mono(\"The Account Status is not correct to activate account\");\n        }\n    })).map(this::buildHtmlOkAccountActivatedContent).onErrorResume(this::buildHtmlFailAccountActivatedContent);\n}",
    "parameters": "[String activationCode]",
    "returnType": "Mono<String>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Builds HTML content for successful account activation.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the HTML content'}]}', name=Optional.empty}]}",
    "name": "buildHtmlOkAccountActivatedContent",
    "body": "{\n    return Htmls.SuccessActivation.get().replace(\"LOGO_WAC\", globalValues.getUrlWacLogoPngSmall()).replace(\"USER_NAME\", userDTO.getFirstName());\n}",
    "parameters": "[UserDto userDTO]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Builds HTML content for failed account activation.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the error occurred'}]}', name=Optional[error]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the HTML content'}]}', name=Optional.empty}]}",
    "name": "buildHtmlFailAccountActivatedContent",
    "body": "{\n    return Mono.just(Htmls.FailActivation.get().replace(\"LOGO_WAC\", globalValues.getUrlWacLogoPngSmall()).replace(\"PATH_TO_RESEND\", globalValues.getPathToResendActvationMail()).replace(\"EMAIL_WAC\", globalValues.getMailToWac()));\n}",
    "parameters": "[Throwable error]",
    "returnType": "Mono<String>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Resends the activation code to the user's email.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user's email'}]}', name=Optional[email]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional.empty}]}",
    "name": "resendActivationCode",
    "body": "{\n    return DAO.findByEmail(email).switchIfEmpty(UserServiceException.mono(\"This Email is Invalid\")).flatMap(userDTO -> activationService.findById(userDTO.get_id()).flatMap(activationDto -> {\n        if (ChronoUnit.HOURS.between(activationDto.getExpiration(), LocalDateTime.now()) <= 24) {\n            return emailService.sendActivationMail(activationDto, userDTO);\n        } else {\n            return emailService.createActivationCodeAndSendEmail(userDTO);\n        }\n    })).onErrorMap(UserServiceException::onErrorMap);\n}",
    "parameters": "[String email]",
    "returnType": "Mono<UserJson>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Resets password by code and returns a new password form.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the reset code'}]}', name=Optional[resetCode]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono of the HTML form'}]}', name=Optional.empty}]}",
    "name": "resetPasswordByCodeAndReturnNewPassForm",
    "body": "{\n    return Mono.just(resetCode).flatMap(resetService::findByCode).switchIfEmpty(UserServiceException.mono(\"This Code is Invalid\")).flatMap(resetDto -> {\n        if (ChronoUnit.HOURS.between(resetDto.getExpiration(), LocalDateTime.now()) > 1)\n            return UserServiceException.mono(\"This Code is Expired\");\n        else\n            return Mono.just(resetDto);\n    }).flatMap(resetDto -> DAO.findBy_id(resetDto.getId()).flatMap(userDTO -> resetService.createNew(userDTO).flatMap(newCode -> {\n        userDTO.setPassword(encryptPassword(newCode.getCode()));\n        userDTO.setAccountStatus(AccountStatus.OUTDATED);\n        return DAO.save(userDTO).thenReturn(newCode);\n    }))).map(this::buildHtmlFormToSendNewPassword).onErrorMap(UserServiceException::onErrorMap);\n}",
    "parameters": "[String resetCode]",
    "returnType": "Mono<String>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Builds HTML form for sending new password.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the reset details'}]}', name=Optional[resetDto]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the HTML form'}]}', name=Optional.empty}]}",
    "name": "buildHtmlFormToSendNewPassword",
    "body": "{\n    String endPoint = globalValues.getUrlSetNewPassword() + resetDto.getCode();\n    return Htmls.FormToSendNewPassword.get().replace(\"LOGO_WAC\", globalValues.getUrlWacLogoPngSmall()).replace(\"RESET_CODE\", resetDto.getCode()).replace(\"ENDPOINT_RESET_PASS\", endPoint);\n}",
    "parameters": "[ResetDto resetDto]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Sets a new password by code.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userJson]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono of the HTML response'}]}', name=Optional.empty}]}",
    "name": "setNewPasswordByCode",
    "body": "{\n    return resetService.findByCode(userJson.get_id()).switchIfEmpty(UserServiceException.mono(\"No user was found\")).flatMap(resetDto -> {\n        if (ChronoUnit.HOURS.between(resetDto.getExpiration(), LocalDateTime.now()) > 1)\n            return UserServiceException.mono(\"This Code is Expired\");\n        else\n            return DAO.findBy_id(resetDto.getId());\n    }).flatMap(userDTO -> {\n        // To not expose the ID, the ID provided is the same reset password code\n        if (Util.encryptMatches(userJson.get_id(), userDTO.getPassword()) && Util.isValidPassword(userJson.getNewPassword())) {\n            userDTO.setPassword(encryptPassword(userJson.getNewPassword()));\n            return DAO.save(userDTO);\n        } else\n            return UserServiceException.mono(\"Reset code is invalid\");\n    }).flatMap(this::buildHtmlSuccessSetNewPassword).onErrorResume(this::buildHtmlFailSetNewPassword);\n}",
    "parameters": "[UserJson userJson]",
    "returnType": "Mono<String>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Builds HTML for successful password reset.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono of the HTML response'}]}', name=Optional.empty}]}",
    "name": "buildHtmlSuccessSetNewPassword",
    "body": "{\n    return resetService.deleteById(userDTO.get_id()).then(Mono.fromCallable(() -> Htmls.SuccessSetNewPassword.get().replace(\"LOGO_WAC\", globalValues.getUrlWacLogoPngSmall()).replace(\"USER_NAME\", userDTO.getFirstName())));\n}",
    "parameters": "[UserDto userDTO]",
    "returnType": "Mono<String>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Builds HTML for failed password reset.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the error'}]}', name=Optional[throwable]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono of the HTML response'}]}', name=Optional.empty}]}",
    "name": "buildHtmlFailSetNewPassword",
    "body": "{\n    return Mono.just(Htmls.FailSetNewPassword.get().replace(\"LOGO_WAC\", globalValues.getUrlWacLogoPngSmall()).replace(\"EMAIL_WAC\", globalValues.getMailToWac()).replace(\"URL_FORGOT_PASS\", globalValues.getUrlForgotPassword()).replace(\"errorDescriptionValue\", throwable.getMessage()));\n}",
    "parameters": "[Throwable throwable]",
    "returnType": "Mono<String>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Saves a new user and sends an activation email.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details to save'}]}', name=Optional[userJustToSave]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the user details as UserJson'}]}', name=Optional.empty}]}",
    "name": "saveUser",
    "body": "{\n    return Mono.just(userJustToSave).flatMap(this::validateAttributes).flatMap(this::checkEmailNotRegistered).flatMap(this::saveUserByJtsReturnDto).flatMap(emailService::createActivationCodeAndSendEmail);\n}",
    "parameters": "[@Valid UserJustToSave userJustToSave]",
    "returnType": "Mono<UserJson>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Validates the attributes of the user.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details to validate'}]}', name=Optional[userJustToSave]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the validated user details'}]}', name=Optional.empty}]}",
    "name": "validateAttributes",
    "body": "{\n    Map<String, Object> errors = new LinkedHashMap<>();\n    if (isNullOrEmptyOrLiteralNull(userJustToSave.getEmail()))\n        errors.put(\"email\", \"E-mail is missing!\");\n    if (notValidEmail(userJustToSave.getEmail()))\n        errors.put(\"email\", \"This email has invalid format!\");\n    if (isNullOrEmptyOrLiteralNull(userJustToSave.getPassword()))\n        errors.put(\"password\", \"Password is missing!\");\n    if (notValidPassword(userJustToSave.getPassword()))\n        errors.put(\"password\", \"Password is invalid format: 8 characters \" + \"-> uppercase lowercase letters numbers and special characters !\");\n    if (isNullOrEmptyOrLiteralNull(userJustToSave.getFirstName()))\n        errors.put(\"firstName\", \"First Name is missing!\");\n    if (isNullOrEmptyOrLiteralNull(userJustToSave.getSurNames()))\n        errors.put(\"surNames\", \"Last Name is missing!\");\n    if (notValidBirthdate(userJustToSave.getBirthdate()))\n        errors.put(\"birthdate\", \"Missing or invalid format : 'YYYY-MM-DD' and more than 7 years!\");\n    if (!errors.isEmpty())\n        return UserServiceException.mono(\"Look in content for errors\", errors);\n    else\n        return Mono.just(userJustToSave);\n}",
    "parameters": "[UserJustToSave userJustToSave]",
    "returnType": "Mono<UserJustToSave>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Checks if the email is not already registered.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details to check'}]}', name=Optional[userJustToSave]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the user details if email is not registered'}]}', name=Optional.empty}]}",
    "name": "checkEmailNotRegistered",
    "body": "{\n    return DAO.existsByEmail(userJustToSave.getEmail()).flatMap(exists -> exists ? UserServiceException.mono(\"This email is already registered!\") : Mono.just(userJustToSave));\n}",
    "parameters": "[UserJustToSave userJustToSave]",
    "returnType": "Mono<UserJustToSave>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Saves the user and returns the UserDto.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details to save'}]}', name=Optional[userJustToSave]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the saved UserDto'}]}', name=Optional.empty}]}",
    "name": "saveUserByJtsReturnDto",
    "body": "{\n    return Mono.just(userJustToSave).flatMap(user -> {\n        user.setFirstName(TitleCase(user.getFirstName()));\n        user.setSurNames(TitleCase(user.getSurNames()));\n        return Mono.just(user);\n    }).map(UserJustToSave::toUserDTO).flatMap(DAO::save).doOnError(UserServiceException::doOnErrorMap);\n}",
    "parameters": "[UserJustToSave userJustToSave]",
    "returnType": "Mono<UserDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Checks and proceeds with the deletion if applicable.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userJson]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a response indicating the result of the deletion process'}]}', name=Optional.empty}]}",
    "name": "proceedIfApplicable",
    "body": "{\n    return DAO.findBy_id(userJson.get_id()).switchIfEmpty(UserServiceException.mono(\"User not found\")).flatMap(this::handleStatusChange);\n}",
    "parameters": "[UserJson userJson]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Handles the account status change during deletion.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a response indicating the result of the status change'}]}', name=Optional.empty}]}",
    "name": "handleStatusChange",
    "body": "{\n    return switch(userDTO.getAccountStatus()) {\n        case OK ->\n            handleOkStatus(userDTO);\n        case REQUEST_DELETE ->\n            handleRequestDeleteStatus(userDTO);\n        case MARKED_DELETE ->\n            handleMarkedDeleteStatus(userDTO);\n        default ->\n            UserServiceException.mono(\"Invalid account status to request deletion\");\n    };\n}",
    "parameters": "[UserDto userDTO]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Handles the OK status during deletion.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a response indicating the result of setting the REQUEST_DELETE status'}]}', name=Optional.empty}]}",
    "name": "handleOkStatus",
    "body": "{\n    userDTO.setAccountStatus(AccountStatus.REQUEST_DELETE);\n    userDTO.setRequestDeleteDate(LocalDateTime.now());\n    return DAO.save(userDTO).map(savedUserDTO -> Response.success(\"REQUEST_DELETE set, you have one year to revoke the deletion\", savedUserDTO.toJson())).onErrorResume(UserServiceException::mono);\n}",
    "parameters": "[UserDto userDTO]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Handles the REQUEST_DELETE status during deletion.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a response indicating the result of handling the REQUEST_DELETE status'}]}', name=Optional.empty}]}",
    "name": "handleRequestDeleteStatus",
    "body": "{\n    LocalDateTime requestDeleteDate = userDTO.getRequestDeleteDate();\n    if (requestDeleteDate != null && ChronoUnit.YEARS.between(requestDeleteDate, LocalDateTime.now()) >= 1) {\n        userDTO.setAccountStatus(AccountStatus.MARKED_DELETE);\n        return DAO.save(userDTO).map(savedUserDTO -> Response.success(\"MARKED_DELETE set, your account has been invalidated you have one year to request your data\", savedUserDTO.toJson())).onErrorResume(UserServiceException::mono);\n    }\n    return Mono.just(Response.success(\"REQUEST_DELETE request is not yet a year old\", userDTO.toJson()));\n}",
    "parameters": "[UserDto userDTO]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Handles the MARKED_DELETE status during deletion.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a response indicating the result of handling the MARKED_DELETE status'}]}', name=Optional.empty}]}",
    "name": "handleMarkedDeleteStatus",
    "body": "{\n    LocalDateTime requestDeleteDate = userDTO.getRequestDeleteDate();\n    if (requestDeleteDate != null && ChronoUnit.YEARS.between(requestDeleteDate, LocalDateTime.now()) >= 2) {\n        return DAO.delete(userDTO).thenReturn(Response.success(\"Your account has been terminated\", true)).onErrorResume(UserServiceException::mono);\n    }\n    String message = \"Your account is set to be deleted, but you still have time to request your data\";\n    return Mono.just(Response.success(message, userDTO.toJson()));\n}",
    "parameters": "[UserDto userDTO]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Checks if a user exists by email.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userJson]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono indicating if the user exists'}]}', name=Optional.empty}]}",
    "name": "checkIfExistsByEmail",
    "body": "{\n    return Mono.just(userJson).map(UserJson::getEmail).filter(Util::isValidEmail).flatMap(DAO::existsByEmail).switchIfEmpty(UserServiceException.mono(\"Email not found!\")).doOnError(UserServiceException::onErrorMap);\n}",
    "parameters": "[UserJson userJson]",
    "returnType": "Mono<Boolean>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Finds a user by email.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userJson]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono of the user details'}]}', name=Optional.empty}]}",
    "name": "findUserByEmail",
    "body": "{\n    return Mono.just(userJson).map(UserJson::getEmail).filter(Util::isValidEmail).flatMap(DAO::findByEmail).switchIfEmpty(UserServiceException.mono(\"This user does not exist or email is invalid!\")).map(UserDto::toJson).doOnError(UserServiceException::onErrorMap);\n}",
    "parameters": "[UserJson userJson]",
    "returnType": "Mono<UserJson>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Registers a new user.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details to save'}]}', name=Optional[userJson]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the response with the saved user details'}]}', name=Optional.empty}]}",
    "name": "registerNewUser",
    "body": "{\n    return create.saveUser(userJson).map(saved -> success(\"User successfully created\", saved)).onErrorResume(UserServiceException.class, Response::monoError).onErrorResume(Exception.class, Response::monoError);\n}",
    "parameters": "[UserJustToSave userJson]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Authenticates a user by login.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the authentication request details'}]}', name=Optional[authRequestDto]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the response entity with the authentication result'}]}', name=Optional.empty}]}",
    "name": "authenticationByLogin",
    "body": "{\n    Authentication authentication = new UsernamePasswordAuthenticationToken(authRequestDto.getUsername(), authRequestDto.getPassword());\n    return reactiveAuthenticationManager.authenticate(authentication).flatMap(auth -> Mono.just(ResponseEntity.ok(success(\"TOKEN\", jwtUtil.generateToken(authRequestDto))))).onErrorResume(e -> Mono.just(ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(error(\"Authentication failed: \" + e.getMessage()))));\n}",
    "parameters": "[@Valid AuthRequestDto authRequestDto]",
    "returnType": "Mono<ResponseEntity<Response>>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Sends an email with a reset code for password reset.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details for password reset'}]}', name=Optional[userJson]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the response entity with the result of the email sending'}]}', name=Optional.empty}]}",
    "name": "sendEmailCodeToResetPassword",
    "body": "{\n    return DAO.findByEmail(userJson.getEmail()).flatMap(userDTO -> {\n        if (userDTO.getBirthdate().equals(userJson.getBirthdate())) {\n            return emailService.createResetCodeAndSendEmail(userDTO).map(user -> ResponseEntity.ok(success(\"Email sent with reset code\", user)));\n        } else {\n            return Mono.just(ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(error(\"Incorrect information\")));\n        }\n    }).switchIfEmpty(Mono.just(ResponseEntity.ok(error(\"Unregistered email\"))));\n}",
    "parameters": "[@Valid UserJson userJson]",
    "returnType": "Mono<ResponseEntity<Response>>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new reset entry for a user.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the created reset entry'}]}', name=Optional.empty}]}",
    "name": "createNew",
    "body": "{\n    return DAO.save(ResetDto.to(userDTO));\n}",
    "parameters": "[UserDto userDTO]",
    "returnType": "Mono<ResetDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Finds a reset entry by ID.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the ID of the reset entry'}]}', name=Optional[id]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the found reset entry'}]}', name=Optional.empty}]}",
    "name": "findById",
    "body": "{\n    return DAO.findById(id);\n}",
    "parameters": "[String id]",
    "returnType": "Mono<ResetDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Finds a reset entry by code.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the reset code'}]}', name=Optional[code]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the found reset entry'}]}', name=Optional.empty}]}",
    "name": "findByCode",
    "body": "{\n    return DAO.findByCode(code);\n}",
    "parameters": "[String code]",
    "returnType": "Mono<ResetDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Deletes a reset entry by ID.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the ID of the reset entry'}]}', name=Optional[id]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono signaling completion'}]}', name=Optional.empty}]}",
    "name": "deleteById",
    "body": "{\n    return DAO.deleteById(id);\n}",
    "parameters": "[String id]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves the favorites of a user.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the favorite request containing the user ID'}]}', name=Optional[favoriteRequest]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the response with the user's favorites'}]}', name=Optional.empty}]}",
    "name": "getFavorites",
    "body": "{\n    return favoriteDao.findById(favoriteRequest.getUserId()).switchIfEmpty(createEmptyFavorite(favoriteRequest)).transform(this::ensureNonNullLists).map(favorites -> success(USER_FAVORITES_RETRIEVED, favorites)).onErrorResume(e -> handleError(\"getFavorites\", e));\n}",
    "parameters": "[FavoriteRequest favoriteRequest]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Adds a recipe to the user's favorites.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the favorite request containing the user ID and recipe ID'}]}', name=Optional[favoriteRequest]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the response with the updated favorites'}]}', name=Optional.empty}]}",
    "name": "addFavoriteRecipe",
    "body": "{\n    return favoriteDao.findById(favoriteRequest.getUserId()).switchIfEmpty(createEmptyFavorite(favoriteRequest)).transform(this::ensureNonNullLists).flatMap(favorites -> favorites.addRecipe(favoriteRequest.getRecipeId())).flatMap(favoriteDao::save).map(saved -> success(RECIPE_SUCCESSFULLY_ADDED_TO_FAVORITES, saved)).onErrorResume(e -> handleError(\"addFavoriteRecipe\", e));\n}",
    "parameters": "[FavoriteRequest favoriteRequest]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Adds an ingredient to the user's favorites.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the favorite request containing the user ID and ingredient ID'}]}', name=Optional[favoriteRequest]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the response with the updated favorites'}]}', name=Optional.empty}]}",
    "name": "addFavoriteIngredient",
    "body": "{\n    return favoriteDao.findById(favoriteRequest.getUserId()).switchIfEmpty(createEmptyFavorite(favoriteRequest)).transform(this::ensureNonNullLists).flatMap(favorites -> favorites.addIngredient(favoriteRequest.getIngredientId())).flatMap(favoriteDao::save).map(saved -> success(INGREDIENT_SUCCESSFULLY_ADDED_TO_FAVORITES, saved)).onErrorResume(e -> handleError(\"addFavoriteIngredient\", e));\n}",
    "parameters": "[FavoriteRequest favoriteRequest]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Removes a recipe from the user's favorites.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the favorite request containing the user ID and recipe ID'}]}', name=Optional[favoriteRequest]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the response with the updated favorites'}]}', name=Optional.empty}]}",
    "name": "removeFavoriteRecipe",
    "body": "{\n    return favoriteDao.findById(favoriteRequest.getUserId()).switchIfEmpty(createEmptyFavorite(favoriteRequest)).transform(this::ensureNonNullLists).flatMap(favorites -> favorites.removeRecipe(favoriteRequest.getRecipeId())).flatMap(favoriteDao::save).map(saved -> success(RECIPE_SUCCESSFULLY_REMOVED_FROM_FAVORITES, saved)).onErrorResume(e -> handleError(\"removeFavoriteRecipe\", e));\n}",
    "parameters": "[FavoriteRequest favoriteRequest]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Removes an ingredient from the user's favorites.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the favorite request containing the user ID and ingredient ID'}]}', name=Optional[favoriteRequest]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the response with the updated favorites'}]}', name=Optional.empty}]}",
    "name": "removeFavoriteIngredient",
    "body": "{\n    return favoriteDao.findById(favoriteRequest.getUserId()).switchIfEmpty(createEmptyFavorite(favoriteRequest)).transform(this::ensureNonNullLists).flatMap(favorites -> favorites.removeIngredient(favoriteRequest.getIngredientId())).flatMap(favoriteDao::save).map(saved -> success(INGREDIENT_SUCCESSFULLY_REMOVED_FROM_FAVORITES, saved)).onErrorResume(e -> handleError(\"removeFavoriteIngredient\", e));\n}",
    "parameters": "[FavoriteRequest favoriteRequest]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates an empty favorite entry for a user.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the favorite request containing the user ID'}]}', name=Optional[favoriteRequest]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the created empty favorite entry'}]}', name=Optional.empty}]}",
    "name": "createEmptyFavorite",
    "body": "{\n    return Mono.defer(() -> Mono.just(new FavoriteDto(favoriteRequest.getUserId(), new ArrayList<>(), new ArrayList<>())));\n}",
    "parameters": "[FavoriteRequest favoriteRequest]",
    "returnType": "Mono<FavoriteDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Ensures that the favorite lists are not null.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the Mono containing the favorite DTO'}]}', name=Optional[favoriteDtoMono]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the favorite DTO with non-null lists'}]}', name=Optional.empty}]}",
    "name": "ensureNonNullLists",
    "body": "{\n    return favoriteDtoMono.map(favorites -> {\n        favorites.setRecipes(Optional.ofNullable(favorites.getRecipes()).orElseGet(ArrayList::new));\n        favorites.setIngredients(Optional.ofNullable(favorites.getIngredients()).orElseGet(ArrayList::new));\n        return favorites;\n    });\n}",
    "parameters": "[Mono<FavoriteDto> favoriteDtoMono]",
    "returnType": "Mono<FavoriteDto>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Handles errors that occur during processing.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the name of the method where the error occurred'}]}', name=Optional[methodName]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the throwable representing the error'}]}', name=Optional[e]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the response with the error message'}]}', name=Optional.empty}]}",
    "name": "handleError",
    "body": "{\n    log.error(\"Error in {}: {}\", methodName, e.getMessage(), e);\n    return Response.monoError(e);\n}",
    "parameters": "[String methodName, Throwable e]",
    "returnType": "Mono<Response>"
  },
  {
    "javadoc": "",
    "name": "createNew",
    "body": "{\n    return DAO.save(ActivationDto.to(userDTO));\n}",
    "parameters": "[UserDto userDTO]",
    "returnType": "Mono<ActivationDto>"
  },
  {
    "javadoc": "",
    "name": "findById",
    "body": "{\n    return DAO.findById(id);\n}",
    "parameters": "[String id]",
    "returnType": "Mono<ActivationDto>"
  },
  {
    "javadoc": "",
    "name": "findByCode",
    "body": "{\n    return DAO.findByCode(code).doOnNext(dto -> log.info(\"ActivationDto encontrado: {}\", dto)).doOnError(e -> log.error(\"Error al buscar ActivationDto\", e));\n}",
    "parameters": "[String code]",
    "returnType": "Mono<ActivationDto>"
  },
  {
    "javadoc": "",
    "name": "deleteById",
    "body": "{\n    return DAO.deleteById(id);\n}",
    "parameters": "[String id]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates an activation code and sends an email.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details to save'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the user details without ID'}]}', name=Optional.empty}]}",
    "name": "createActivationCodeAndSendEmail",
    "body": "{\n    return activationService.createNew(userDTO).flatMap(activation -> sendActivationMail(activation, userDTO));\n}",
    "parameters": "[UserDto userDTO]",
    "returnType": "Mono<UserJson>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Sends an activation email.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the activation details'}]}', name=Optional[activationDto]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the user details without ID'}]}', name=Optional.empty}]}",
    "name": "sendActivationMail",
    "body": "{\n    return Mono.fromCallable(() -> buildMimeMessage(activationDto, userDTO)).flatMap(this::sendEmail).retry(2).thenReturn(userDTO.toJsonWithoutId()).doOnError(UserServiceException::doOnErrorMap);\n}",
    "parameters": "[ActivationDto activationDto, UserDto userDTO]",
    "returnType": "Mono<UserJson>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Builds a MimeMessage for activation.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the activation details'}]}', name=Optional[activationDto]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the built MimeMessage'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if an error occurs while building the message'}]}', name=Optional[MessagingException]}]}",
    "name": "buildMimeMessage",
    "body": "{\n    MimeMessage message = emailSender.createMimeMessage();\n    MimeMessageHelper helper = new MimeMessageHelper(message, true, \"UTF-8\");\n    helper.setFrom(springMailConfig.getSpringMailUser());\n    helper.setTo(userDTO.getEmail());\n    helper.setSubject(\"WhataCook : Activación de cuenta\");\n    String content = buildHtmlContentToActivateAccount(activationDto, userDTO);\n    helper.setText(content, true);\n    return message;\n}",
    "parameters": "[ActivationDto activationDto, UserDto userDTO]",
    "returnType": "MimeMessage"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Builds HTML content for the activation email.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the activation details'}]}', name=Optional[activationDto]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the HTML content'}]}', name=Optional.empty}]}",
    "name": "buildHtmlContentToActivateAccount",
    "body": "{\n    String activationLink = globalValues.getUrlActivationAccount() + activationDto.getCode();\n    return Htmls.ActivationEmail.get().replace(\"LOGO_WAC\", globalValues.getUrlWacLogoPngSmall()).replace(\"USER_NAME\", userDTO.getFirstName()).replace(\"ACTIVATION_LINK\", activationLink);\n}",
    "parameters": "[ActivationDto activationDto, UserDto userDTO]",
    "returnType": "String"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Sends an email.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the MimeMessage to send'}]}', name=Optional[message]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono signaling completion'}]}', name=Optional.empty}]}",
    "name": "sendEmail",
    "body": "{\n    return Mono.fromRunnable(() -> emailSender.send(message));\n}",
    "parameters": "[MimeMessage message]",
    "returnType": "Mono<Void>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a reset code and sends an email.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details to save'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the user details without ID'}]}', name=Optional.empty}]}",
    "name": "createResetCodeAndSendEmail",
    "body": "{\n    return resetService.createNew(userDTO).flatMap(resetCode -> sendResetMail(resetCode, userDTO));\n}",
    "parameters": "[UserDto userDTO]",
    "returnType": "Mono<UserJson>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Sends a reset email.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the reset details'}]}', name=Optional[resetCode]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Mono containing the user details without ID'}]}', name=Optional.empty}]}",
    "name": "sendResetMail",
    "body": "{\n    return Mono.fromCallable(() -> buildMimeMessage(resetCode, userDTO)).flatMap(this::sendEmail).retry(2).thenReturn(userDTO.toJsonWithoutId()).doOnError(UserServiceException::doOnErrorMap);\n}",
    "parameters": "[ResetDto resetCode, UserDto userDTO]",
    "returnType": "Mono<UserJson>"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Builds a MimeMessage for password reset.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the reset details'}]}', name=Optional[resetCode]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the built MimeMessage'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if an error occurs while building the message'}]}', name=Optional[MessagingException]}]}",
    "name": "buildMimeMessage",
    "body": "{\n    MimeMessage message = emailSender.createMimeMessage();\n    MimeMessageHelper helper = new MimeMessageHelper(message, true, \"UTF-8\");\n    helper.setFrom(springMailConfig.getSpringMailUser());\n    helper.setTo(userDTO.getEmail());\n    helper.setSubject(\"WhataCook : reset contraseña\");\n    String content = buildHtmlContentToResetAccount(resetCode, userDTO);\n    helper.setText(content, true);\n    return message;\n}",
    "parameters": "[ResetDto resetCode, UserDto userDTO]",
    "returnType": "MimeMessage"
  },
  {
    "javadoc": "Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Builds HTML content for the reset email.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the reset details'}]}', name=Optional[resetCode]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the user details'}]}', name=Optional[userDTO]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the HTML content'}]}', name=Optional.empty}]}",
    "name": "buildHtmlContentToResetAccount",
    "body": "{\n    String activationLink = globalValues.getUrlResetPassword() + resetCode.getCode();\n    return Htmls.ResetPasswordMail.get().replace(\"LOGO_WAC\", globalValues.getUrlWacLogoPngSmall()).replace(\"USER_NAME\", userDTO.getFirstName()).replace(\"ACTIVATION_LINK\", activationLink);\n}",
    "parameters": "[ResetDto resetCode, UserDto userDTO]",
    "returnType": "String"
  }
]